file C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\Gen4-uLCD-43D-CLB.fnc

000001  000001  #platform "Gen4-uLCD-43D-CLB"
000002  000001  #platform "Gen4-uLCD-43D-CLB"
000003  000008  */
000004  000009      #constant Gen4_ULCD_43D_CLB_DIABLO16_GFX
000005  000009      #constant Gen4_ULCD_43D_CLB_DIABLO16_GFX
000006  000010        
000007  000011      #IFNOT EXISTS DIABLO16_GFX2_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\Diablo16_Functions.fnc

000008  000012          #inherit "Diablo16_Functions.fnc"          // inherit the generic functions
000009  000012          #inherit "Diablo16_Functions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for Diablo16 platforms
000012  000003  //#constant ULCD_32PT_DIABLO16_GFX
000013  000004        
000014  000005        
000015  000006  // define the compiler dummy preambles
000016  000007  #constant LOCAL $//
000017  000007  #constant LOCAL $//
000018  000008  #constant EXTERN $ /**/
000019  000008  #constant EXTERN $ /**/
000020  000009        
000021  000010  #CONST
000022  000019  #END
000023  000020        
000024  000021  #CONST
000025  000037  #END
000026  000038        
000027  000039        
000028  000040        
000029  000041        
000030  000046  */
000031  000047        
000032  000048        
000033  000049  //------------------------------------------------------------------//
000034  000050  //     EVE  miscellaneous functions                                 //
000035  000051  //------------------------------------------------------------------//
000036  000052        
000037  000053  func to("device"), 0;                // output device redirection
000038  000054  // Syntax: to(outstream);
000039  000055  // Usage : to(APPEND); putstr("TWO ");
000040  000056  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000041  000057  //     :
000042  000058  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000043  000059  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000044  000060  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000045  000061  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000046  000062  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000047  000063  //     : completed its action. The APPEND argument is used to send the printed output to the same
000048  000064  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000049  000065  //     : sequential data to a media stream.
000050  000066  //     :
000051  000067  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000052  000068  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000053  000069  //     :                            appended to user memory if previous redirection was to an array.
000054  000070  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000055  000071  //     : TEXT           0xFF08      Output is directed to the screen (default).
000056  000072  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000057  000073  //     : I2C1           0xF820      Output is directed to the I2C1 port.
000058  000074  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000059  000075        
000060  000076  //------------------------------------------------------------------//
000061  000077  // to(..) redirection constants            //
000062  000078  //------------------------------------------------------------------//
000063  000079  #CONST
000064  000092  #END
000065  000093        
000066  000094        
000067  000095  func putch("char"), 0;                // write single char to current output device
000068  000096  // Syntax    : putch("char");
000069  000097  // Usage     : putch("A");
000070  000098  // Notes     : prints single characters to the current output stream, usually the
000071  000099  //           : display unless redirected with the ‘to’ redirection function.
000072  000100  //         : The arguments can be a variable, array element, expression or constant.
000073  000101        
000074  000102        
000075  000103  func putchXY("xpos", "ypos", "char"), 0;
000076  000104  // Syntax  : putchXY(x, y, '0x41'),
000077  000105  // Usage   : putchXY(100, 100, "HELLO");
000078  000106  // Notes   : Print a single character at position x, y.
000079  000107  //         : Char may be a constant or variable.
000080  000108  // Returns : nothing.
000081  000109        
000082  000110  func putstrXY("xpos", "ypos", "string"), 0;
000083  000111  // Syntax  : putstrXY(x, y, "string"),
000084  000112  // Usage   : putstrXY(100, 100, "HELLO");
000085  000113  // Notes   : Print a string at position x, y
000086  000114  //         : "String" may be a string constant, or pointer to a word aligned string.
000087  000115  // Returns : nothing.
000088  000116        
000089  000117        
000090  000118  func putstrCentred("xc", "yc", "string"), 0;
000091  000119  // Syntax  : putstrCentred(x, y, "string"),
000092  000120  // Usage   : putstrCentred(100, 100, "HELLO");
000093  000121  // Notes   : Print a string centred at position x, y
000094  000122  //         : "String" may be a string constant, or pointer to a word aligned string.
000095  000123  // Returns : nothing.
000096  000124        
000097  000125        
000098  000126  func pause("milliseconds"), 0;            // blocking delay
000099  000127  // Syntax: pause(milliseconds);
000100  000128  // Usage : pause(1000);                //pause for 1 second
000101  000129  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000102  000130        
000103  000131        
000104  000132  func putnum("arg1","arg2"), 1;            // print number to current output device
000105  000133  // Syntax: putnum(format, value);
000106  000134  // Usage : var := putnum(HEX, val);
000107  000135  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000108  000136  //     : Format: A constant that specifies the number format
000109  000137  //     : Value : The number to be printed
000110  000138  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000111  000139  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000112  000140  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000113  000141  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000114  000142  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000115  000143  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000116  000144  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000117  000145  //     :                                     BIN6     BIN6Z     BIN6ZB
000118  000146  //     :                                     BIN7     BIN7Z     BIN7ZB
000119  000147  //     :                                     BIN8     BIN8Z     BIN8ZB
000120  000148  //     :                                     BIN9     BIN9Z     BIN9ZB
000121  000149  //     :                                     BIN10     BIN10Z     BIN10ZB
000122  000150  //     :                                     BIN11     BIN11Z     BIN11ZB
000123  000151  //     :                                     BIN12     BIN12Z     BIN12ZB
000124  000152  //     :                                     BIN13     BIN13Z     BIN13ZB
000125  000153  //     :                                     BIN14     BIN14Z     BIN14ZB
000126  000154  //     :                                     BIN15     BIN15Z     BIN15ZB
000127  000155  //     :                                     BIN16     BIN16Z     BIN16ZB
000128  000156  //     : 
000129  000157  //     : bit 15 Leading spaces (1=space before signed number, 0=No space)
000130  000158  //     : bit 14 sign bit (0=signed, 1=unsigned)
000131  000159  //     : bit 13 Blanking (1=Leading zero blanking, 0=Show Zeros)
000132  000160  //     : bit 12 Leading zeros (1=Zeros included, 0=Zeros suppressed)
000133  000161  //     : bits 11-8 Displayed digit quantity
000134  000162  //     : bits 7-5 Reserved
000135  000163  //     : bits 4-0 Number base (usually 2,10 or 16)
000136  000164        
000137  000165        
000138  000166  func __translate("arg1","arg2","arg3","arg4"), 1; // list translator (*** internal compiler use only, not usable)
000139  000167        
000140  000168        
000141  000169  func putstr("string"), 1;                         // print var (word) aligned string to current output device
000142  000170  // Syntax: putstr(pointer);
000143  000171  // Usage : putstr("HELLO\n");
000144  000172  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000145  000173  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000146  000174  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000147  000175  //       : The output of putstr can be redirected to the communications port, the media, or memory
000148  000176  //       : using the to(...); function.
000149  000177  //       : A string constant is automatically terminated with a zero.
000150  000178  //       : A string in a data statement is not automatically terminated with a zero.
000151  000179  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000152  000180  //       : element packs 1 or 2 characters.
000153  000181        
000154  000182        
000155  000183  func strlen("varAddress"), 1;                   // return length of a var (word) aligned string in character units
000156  000184  // Syntax: strlen("varAddress);
000157  000185  // Usage : strlen("HELLO\n");
000158  000186  // Notes : gives the length of a string that is packed into regular var array
000159  000187  //       : Use str_Length(ptr)  for string pointer mode
000160  000188        
000161  000189        
000162  000190  func charwidth("char"), 1;
000163  000191  // Syntax  : charwidth(char);
000164  000192  // Usage   : wid := charwidth('W');
000165  000193  // Notes   : calculates width of a character in pixel units.
000166  000194  //         : 'char' may be a constant or variable.
000167  000195  // Returns : Width of character in pixel units.
000168  000196        
000169  000197        
000170  000198  func charheight("char"), 1;
000171  000199  // Syntax  : charheight(char);
000172  000200  // Usage   : ht := charheight('0x41');
000173  000201  // Notes   : Calculates height of a character in pixel units.
000174  000202  //         : 'char' may be a constant or variable.
000175  000203  // Returns : Height of character in pixel units.
000176  000204        
000177  000205        
000178  000206  func strwidth("pointer"), 1;
000179  000207  // Syntax  : strwidth(ptr);
000180  000208  // Usage   : x := strwidth("HELLO");
000181  000209  // Notes   : returns width of a string in pixel units.
000182  000210  //         : 'pointer' may be a constant or pointer to word aligned variable
000183  000211  // Returns : Width of string in pixel units, can be multi line.
000184  000212        
000185  000213        
000186  000214  func strheight(), 1;
000187  000215  // Syntax  : strheight();
000188  000216  // Usage   : h := strheight();
000189  000217  // Notes   : calculates height of a string in pixel units (after a call to strwidth );
000190  000218  //         : pointer may be a constant or pointer to word aligned variable
000191  000219  // Returns : Height of string in pixel units, can be multi line.
000192  000220        
000193  000221        
000194  000222  func unicode_page("charbeg","charend","charoffset"), 1;
000195  000223  // Syntax: unicode_page("charbeg","charend","charoffset");
000196  000224  // Usage : eg:  F_Traditional_0x20_0xFF
000197  000225  // Notes : After selecting a unicode image control with txt_FontID,
000198  000226  //       : this function is called to set the required font within the
000199  000227  //       : unicode set. The file "Unicode.inc" contains wrappers for
000200  000228  //       : this function, and it is not normally called directly.
000201  000229  //       : Returns count of characters in the set.
000202  000230  //       : Refer to "Unicode.inc" for further information.
000203  000231        
000204  000232        
000205  000233  //------------------------------------------------------------------//
000206  000234  //          Text Related Functions                                  //
000207  000235  //------------------------------------------------------------------//
000208  000236        
000209  000237  func txt_MoveCursor("line", "column"), 0;
000210  000238  // Syntax: txt_SetCursor(line, column);
000211  000239  // Usage : txt_SetCursor(arg1, arg2);
000212  000240  // Notes : Moves the text Cursor to a new screen position set by
000213  000241  //       : line,column parameters.
000214  000242        
000215  000243  func txt_Set("function", "value"), 0;
000216  000244  // Syntax: txt_Set(function, value);
000217  000245  // Usage : txt_Set(arg1, arg2);
000218  000246  // Returns : Original value before the change
000219  000247  // Notes : Sets various text related parameters used by other functions
000220  000248  //       : This allows the features to be set programatically with a
000221  000249  //       : single function call.It is strongly recommended to use the
000222  000250  //       : pre-defined constants rather than the mode numbers.
000223  000251  //       : NB:- It is often required to be able to set text
000224  000252  //       : functions with a single function call for graphics engine
000225  000253  //       : related functions, however, there is a complete set of single parameter
000226  000254  //       : shortcut functions that have exactly the same function as
000227  000255  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000228  000256  //       :
000229  000257  //       : txt_Set(TEXT_COLOUR, colour);        // function 0, TEXT_COLOUR, default colour = LIME
000230  000258  //       : txt_Set(TEXT_HIGHLIGHT, colour);     // function 1, TEXT_HIGHLIGHT)
000231  000259  //       : txt_Set(FONT_ID, fontNumer);         // function 2, FONT_ID)
000232  000260  //       : txt_Set(TEXT_WIDTH, multiplier);     // function 3, TEXT_WIDTH)
000233  000261  //       : txt_Set(TEXT_HEIGHT, multiplier);    // function 4, TEXT_HEIGHT)
000234  000262  //       : txt_Set(TEXT_XGAP, pixels);          // function 5, TEXT_XGAP)
000235  000263  //       : txt_Set(TEXT_YGAP, pixels);          // function 6, TEXT_YGAP)
000236  000264  //       : txt_Set(TEXT_PRINTDELAY, msecs);     // function 7, TEXT_PRINTDELAY)
000237  000265  //       : txt_Set(TEXT_OPACITY, value);        // function 8, TEXT_OPACITY)
000238  000266  //       : txt_Set(TEXT_BOLD, boldness);        // function 9, TEXT_BOLD)
000239  000267  //       : txt_Set(TEXT_ITALIC, slope);         // function 10, TEXT_ITALIC)
000240  000268  //       : txt_Set(TEXT_INVERSE, onoff);        // function 11, TEXT_INVERSE)
000241  000269  //       : txt_Set(TEXT_UNDERLINED, onoff);     // function 12, TEXT_UNDERLINED)
000242  000270  //       : txt_Set(TEXT_ATTRIBUTES, combine);   // function 13, TEXT_ATTRIBUTES)
000243  000271  //       : txt_Set(TEXT_WRAP, column);          // function 14, TEXT_WRAP)
000244  000272  //       : txt_Set(TEXT_ANGLE , degrees);       // function 15, TEXT_ANGLE)
000245  000273  //       :
000246  000274  //       : txt_Set(TEXT_COLOUR, colour);
000247  000275  //       : mode = TEXT_COLOUR (function 0)
000248  000276  //       : txt_Set(TEXT_COLOUR, value);
000249  000277  //       : value = 0 to 0xFFFF, Black to White
000250  000278  //       : Sets the Text colour for the display
000251  000279  //       : Default = LIME.
000252  000280  //       :
000253  000281  //       : mode = TEXT_HIGHLIGHT (function 1)
000254  000282  //       : txt_Set(TEXT_HIGHLIGHT, value);
000255  000283  //       : value = 0 to 0xFFFF, Black to White
000256  000284  //       : Sets the Text background colour for the display. Effective
000257  000285  //       : when text mode is Opaque.
000258  000286  //       : Default = BLACK.
000259  000287  //       :
000260  000288  //       : mode = FONT_ID (function 2)
000261  000289  //       : txt_Set(FONT_ID, value);
000262  000290  //       : value = FONT1 to FONT11 for internal fonts
000263  000291  //       : else this value is the name of a font included
000264  000292  //       : in a users program in a data statement.
000265  000293  //       : Default = FONT SIZE 3.
000266  000294  //       :
000267  000295  //       : mode = TEXT_WIDTH  (function 3)
000268  000296  //       : txt_Set(TEXT_WIDTH, value);
000269  000297  //       : value = 1 to 16
000270  000298  //       : Sets the Text Width multiplier
000271  000299  //       : text will be printed magnified horizontally
000272  000300  //       : by this factor, Default = 1.
000273  000301  //       :
000274  000302  //       : mode = TEXT_HEIGHT  (function 4)
000275  000303  //       : txt_Set(TEXT_HEIGHT, value);
000276  000304  //       : value = 1 to 16
000277  000305  //       : Sets the Text Height multiplier
000278  000306  //       : text will be printed magnified vertically
000279  000307  //       : by this factor, Default = 1.
000280  000308  //       :
000281  000309  //       : mode = TEXT_XGAP  (function 5)
000282  000310  //       : txt_Set(TEXT_XGAP, value);
000283  000311  //       : value = 1 to 32
000284  000312  //       : Sets the horizontal gap between characters
000285  000313  //       : The gap is in pixel units, Default = 0
000286  000314  //       :
000287  000315  //       : mode = TEXT_YGAP  (function 6)
000288  000316  //       : txt_Set(TEXT_YGAP, value);
000289  000317  //       : value = 1 to 32
000290  000318  //       : Sets the vertical gap below characters
000291  000319  //       : The gap is in pixel units, Default = 0
000292  000320  //       :
000293  000321  //       : mode = TEXT_PRINTDELAY  (function 7) DEPRECATED
000294  000322  //       : txt_Set(TEXT_PRINTDELAY, value);
000295  000323  //       : value = 0 to 255
000296  000324  //       : Sets the delay time (in ms) during character
000297  000325  //       : printing to give a 'teletype' like effect.
000298  000326  //       : Often used to attract attention to a string
000299  000327  //       : being printed which can often be missed if
000300  000328  //       : just suddenly appearing or changing.
000301  000329  //       : Default = 0 ms.
000302  000330  //       :
000303  000331  //       : mode = TEXT_OPACITY (function 8)
000304  000332  //       : txt_Set(TEXT_OPACITY, value);
000305  000333  //       : value = TRANSPARENT (0) = Text Trasparent
000306  000334  //       : value = OPAQUE (1) = Text Opaque
000307  000335  //       : Sets the Opacity/Transparency of the text
000308  000336  //       : Default = 0 or TRANSPARENT
000309  000337  //       :
000310  000338  //       : mode = TEXT_BOLD (function 9)
000311  000339  //       : txt_Set(TEXT_BOLD, value);
000312  000340  //       : value = dont care
000313  000341  //       : Sets Bold Text mode for the next string or char
000314  000342  //       : The feature automatically resets after printing
000315  000343  //       : using putstr or print has completed
000316  000344  //       :
000317  000345  //       : mode = TEXT_ITALIC (function10)
000318  000346  //       : txt_Set(TEXT_ITALIC, value);
000319  000347  //       : value = dont care
000320  000348  //       : Sets Italic Text mode for the next string or char
000321  000349  //       : The feature automatically resets after printing
000322  000350  //       : using putstr or print has completed
000323  000351        
000324  000352  //       : mode = TEXT_INVERSE (function 11)
000325  000353  //       : txt_Set(TEXT_INVERSE, value);
000326  000354  //       : value = dont care
000327  000355  //       : Sets Inverse Text mode for the next string or char
000328  000356  //       : The feature automatically resets after printing
000329  000357  //       : using putstr or print has completed
000330  000358  //       :
000331  000359  //       : mode = TEXT_UNDERLINED (function 12)
000332  000360  //       : txt_Set(TEXT_UNDERLINED, value);
000333  000361  //       : value = dont care
000334  000362  //       : Sets Underlined Text mode for the next string or char
000335  000363  //       : The feature automatically resets after printing
000336  000364  //       : using putstr or print has completed
000337  000365  //       :
000338  000366  //       : mode = TEXT_ATTRIBUTES (function 13)
000339  000367  //       : txt_Set(TEXT_ATTRIBUTES, value);
000340  000368  //       : value = bits are defined as:
000341  000369  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000342  000370  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000343  000371  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000344  000372  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000345  000373  //       : Allows a combination of text attributes to be defined together
000346  000374  //       : by 'or'ing the bits together.
000347  000375  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000348  000376  //       : The feature automatically resets after printing
000349  000377  //       : using putstr or print has completed.
000350  000378  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000351  000379  //       :
000352  000380  //       : mode = TEXT_WRAP (function 14)
000353  000381  //       : txt_Set(TEXT_WRAP , value);
000354  000382  //       : Sets the position where text wrap will occur
000355  000383  //       : The feature automatically resets when screen
000356  000384  //       : mode is changed. If the value is set to 0,
000357  000385  //       : text wrap is turned off.
000358  000386  //       : of the current screen. Default value is 0
000359  000387  // Notes : The value is in pixel units.
000360  000388  //       :
000361  000389  //       : mode = TEXT_ANGLE (function 15)
000362  000390  //       : txt_Set(TEXT_ANGLE , value);
000363  000391  //       : Sets the angle of plotted fonts
000364  000392  // Notes : The angle is in degrees.
000365  000393  //       :
000366  000394        
000367  000395  //------------------------------------------------------------------------------
000368  000396  //txt_Set() related constants
000369  000397  //------------------------------------------------------------------------------
000370  000398  #CONST
000371  000417  #END
000372  000418        
000373  000419  //------------------------------------------------------------------------------
000374  000420  //txt_Set() related arguments
000375  000421  //------------------------------------------------------------------------------
000376  000422  #CONST
000377  000448  #END
000378  000449        
000379  000450        
000380  000451  //=====================================================//
000381  000452  // Single parameter short-cuts                         //
000382  000453  // for the txt_Set functions                           //
000383  000454  // These functions return the existing value before    //
000384  000455  // the change is made.                                 //
000385  000456  //=====================================================//
000386  000457  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000387  000458  func txt_BGcolour("colour"), 1;             // 1  text background colour
000388  000459  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000389  000460  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000390  000461  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000391  000462  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000392  000463  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000393  000464  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000394  000465  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000395  000466  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000396  000467  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000397  000468  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000398  000469  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000399  000470  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000400  000471  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000401  000472  func txt_Angle("value"), 1;                 // 15 text set angle of plotted font
000402  000473        
000403  000474        
000404  000475        
000405  000476  //------------------------------------------------------------------//
000406  000477  // Memory Access Functions                                          //
000407  000478  //------------------------------------------------------------------//
000408  000479                                                  //
000409  000480  func peekW("address"), 1;                       // read a word from system memory
000410  000481  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000411  000482  // refer to address map of internal variables   //
000412  000483        
000413  000484        
000414  000485  //------------------------------------------------------------------//
000415  000486  //        CTYPE Function Prototypes
000416  000487  //------------------------------------------------------------------//
000417  000488        
000418  000489  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
000419  000490  // Syntax: isdigit("char");
000420  000491  // Usage : Var := isdigit(ch);
000421  000492  // Notes : char specifies the ascii character for the test
000422  000493  //     : 0 : char is not an ascii digit.
000423  000494  //     : 1 : char is an ascii digit..
000424  000495  //     : Valid range is "0123456789"
000425  000496        
000426  000497  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
000427  000498  // Syntax: isxdigit("char");
000428  000499  // Usage : Var := isxdigit(ch);
000429  000500  // Notes : char specifies the ascii character for the test
000430  000501  //     : 0 : char is not an ascii hexadecimal digit.
000431  000502  //     : 1 : char is an ascii hexadecimal digit..
000432  000503  //     : Valid range is "0123456789ABCDEF"
000433  000504        
000434  000505  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
000435  000506  // Syntax: isupper("char");
000436  000507  // Usage : Var := isupper(ch);
000437  000508  // Notes : char specifies the ascii character for the test
000438  000509  //     : 0 : char is not an ascii upper-case letter.
000439  000510  //     : 1 : char is an ascii upper-case letter.
000440  000511  //     : Valid range is "ABCD....WXYZ"
000441  000512        
000442  000513  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
000443  000514  // Syntax: islower("char");
000444  000515  // Usage : Var := islower(ch);
000445  000516  // Notes : char specifies the ascii character for the test
000446  000517  //     : 0 : char is not an ascii lower-case letter.
000447  000518  //     : 1 : char is an ascii lower-case letter.
000448  000519  //     : Valid range is "abcd....wxyz"
000449  000520        
000450  000521  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
000451  000522  // Syntax: isalpha("char");
000452  000523  // Usage : Var := isalpha(ch);
000453  000524  // Notes : char specifies the ascii character for the test
000454  000525  //     : 0 : char is not an ascii lower or upper case letter.
000455  000526  //     : 1 : char is an ascii lower or upper case letter.
000456  000527  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
000457  000528        
000458  000529  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
000459  000530  // Syntax: isalnum("char");
000460  000531  // Usage : Var := isalnum(ch);
000461  000532  // Notes : char specifies the ascii character for the test
000462  000533  //     : 0 : char is not an ascii alphanumeric character.
000463  000534  //     : 1 : char is an ascii alphanumeric character.
000464  000535  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
000465  000536        
000466  000537  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
000467  000538  // Syntax: isprint("char");
000468  000539  // Usage : Var := isprint(ch);
000469  000540  // Notes : char specifies the ascii character for the test
000470  000541  //     : 0 : char is not a printable ascii character.
000471  000542  //     : 1 : char is a printable ascii character.
000472  000543  //     : Valid range is "0x20...0x7F"
000473  000544        
000474  000545  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
000475  000546  // Syntax: isspace("char");
000476  000547  // Usage : Var := isspace(ch);
000477  000548  // Notes : char specifies the ascii character for the test
000478  000549  //     : 0 : char is not a space type character.
000479  000550  //     : 1 : char is a space type character.
000480  000551  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
000481  000552        
000482  000553  //unformatted
000483  000554  func iswhite("char"), 1;    //
000484  000555  // Syntax: iswhite("char");
000485  000556  // Usage : Var := iswhite(ch);
000486  000557  // Notes : char specifies the ascii character for the test
000487  000558  //     : 0 : char is not a space or tab character.
000488  000559  //     : 1 : char is not a space or tab character.
000489  000560  //     : Valid range is space or tab
000490  000561        
000491  000562  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
000492  000563  // Syntax: toupper("char");
000493  000564  // Usage : Var := toupper(ch);
000494  000565  // Notes : char specifies the ascii character for the test
000495  000566  //     : "ABCD....XYZ" : if character is a lower case letter.
000496  000567  //     : char : if character is not a lower case letter.
000497  000568  //     : Valid range is "abcd....wxyz"
000498  000569        
000499  000570  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
000500  000571  // Syntax: tolower("char");
000501  000572  // Usage : Var := tolower(ch);
000502  000573  // Notes : char specifies the ascii character for the test
000503  000574  //     : "abcd....xyz" : if character is an upper case letter.
000504  000575  //     : char : if character is not an upper case letter.
000505  000576  //     : Valid range is "ABCD....WXYZ"
000506  000577        
000507  000578  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
000508  000579  // Syntax: LObyte(var);
000509  000580  // Usage : myVar := LObyte(myvar2);
000510  000581  // Notes : var specifies the user variable
000511  000582  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
000512  000583        
000513  000584  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
000514  000585  // Syntax: HIbyte(var);
000515  000586  // Usage : myVar := HIbyte(myvar2);
000516  000587  // Notes : var specifies the user variable
000517  000588  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
000518  000589        
000519  000590        
000520  000591  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
000521  000592  // Syntax: ByteSwap(var);
000522  000593  // Usage : myVar := ByteSwap(myvar2);
000523  000594  // Notes : var specifies the user variable
000524  000595  //     : Returns the endian swapped value of a 16 bit variable
000525  000596        
000526  000597        
000527  000598  func NybleSwap("var"), 1;    //Returns the swapped lower bytes nybles, upper byte retained.
000528  000599  // Syntax: NybleSwap(var);
000529  000600  // Usage : myVar := NybleSwap(myvar2);
000530  000601  // Notes : var specifies the user variable
000531  000602  //     : Returns the 16 bit variable with swapped lower nybles
000532  000603        
000533  000604  func putnumXY("xpos", "ypos", "arg1","arg2"), 1;            // print number at the specified position
000534  000605  // Syntax: putnumXY(x, y, format, value);
000535  000606  // Usage : var := putnumXY(100, 100, HEX, val);
000536  000607  // Notes : prints a 16bit number in various formats at the specified XY coordinates.
000537  000608  //     : Format: A constant that specifies the number format
000538  000609  //     : Value : The number to be printed
000539  000610        
000540  000611  func txt_FontBank("flashbank", "address"), 1;               // use a font located in another bank
000541  000612  // Syntax: txt_FontBank(bank, offset);
000542  000613  // Usage : txt_FontBank(FLASHBANK_2, arg2);
000543  000614  // Returns : Current font before the change, or 0 if invalid or bank is protected
000544  000615  // Notes : Sets the current font to a font held in another bank
000545  000616        
000546  000617  //------------------------------------------------------------------//
000547  000618  // 16bit signed Math Functions                                      //
000548  000619  //------------------------------------------------------------------//
000549  000620                                                  //
000550  000621  func ABS("value"), 1;                           // return a positive number
000551  000622  // Syntax: ABS(value);
000552  000623  // Usage : var := ABS(arg);
000553  000624  // Notes : Returns the absolute value of an argument
000554  000625        
000555  000626  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000556  000627  // Syntax: MIN(value1, value2);
000557  000628  // Usage : var := MIN(arg1, arg2);
000558  000629  // Notes : Returns the minimum of 2 arguments
000559  000630        
000560  000631  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000561  000632  // Syntax: MAX(value1, value2);
000562  000633  // Usage : var := MAX(arg1, arg2);
000563  000634  // Notes : Returns the maximum of 2 arguments
000564  000635        
000565  000636  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000566  000637  // Syntax: SWAP(&var1, &var2);
000567  000638  // Usage : SWAP(&var1, &var2);
000568  000639  // Notes : Swaps the contents of 2 variables or memory locations
000569  000640        
000570  000641  func SIN("angle"), 1;                           // return SIN of angle
000571  000642  // Syntax: SIN(angle);
000572  000643  // Usage : var := SIN(arg);
000573  000644  // Notes : Returns the sine in radians of an argument in degrees
000574  000645  //       : the returned value range is from 127 to -127. The real
000575  000646  //       : cosine values vary from 1.0 to -1.0 so appropriate
000576  000647  //       : scaling must be done in user code.
000577  000648        
000578  000649  func COS("angle"), 1;                           // return COS of angle
000579  000650  // Syntax: COS(angle);
000580  000651  // Usage : var := COS(arg);
000581  000652  // Notes : Returns the cosine in radians of an argument in degrees
000582  000653  //       : the returned value range is from 127 to -127. The real
000583  000654  //       : cosine values vary from 1.0 to -1.0 so appropriate
000584  000655  //       : scaling must be done in user code.
000585  000656        
000586  000657  func RAND(), 1;                                 // return a pseudo random number
000587  000658  // Syntax: RAND();
000588  000659  // Usage : var := RAND();
000589  000660  // Notes : Returns a random number between 0 and 0xFFFF.
000590  000661  //       : The random number generator must first be seeded
000591  000662  //       : by using the SEED(number) function.
000592  000663        
000593  000664  func RANDVAL("low", "high"), 1;                 // return a ranged pseudo random number
000594  000665  // Syntax: RANDVAL("low", "high");
000595  000666  // Usage : var := RANDVAL(low, high);
000596  000667  // Notes : Returns a random number between low and high limits
000597  000668  //       : such that low <= N < high
000598  000669  //       : The random number generator may first be seeded
000599  000670  //       : by using the SEED(number) function.
000600  000671  //       : RANDVAL is the equivalent of aggregate functions:-
000601  000672  //       :     myvar = ABS( (RAND()%(high-low)+low) );
000602  000673  //       : Note that the lower limit is inclusive, but the upper limit is exclusive.
000603  000674        
000604  000675  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000605  000676  // Syntax: SEED(number);
000606  000677  // Usage : SEED(arg);
000607  000678  // Notes : Seeds the random number generator.
000608  000679        
000609  000680  func SQRT("number"), 1;                         // return square root of a number
000610  000681  // Syntax: SQRT(number);
000611  000682  // Usage : SQRT(arg);
000612  000683  // Notes : Returns the integer square root of a number.
000613  000684        
000614  000685  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000615  000686  // Syntax: OVF();
000616  000687  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000617  000688  //       : hiWord := OVF();
000618  000689  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000619  000690        
000620  000691  func CY(), 1;
000621  000692  // Syntax: CY();
000622  000693  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
000623  000694  //       : print(myvar," "CY(),"\n");           // carry = 1
000624  000695  // Notes : This function returns the carry status of an
000625  000696  // unsigned overflow from any 16 or 32bit additions or sutractions.
000626  000697        
000627  000698  func EVE_SP(), 1;
000628  000699  // Syntax: EVE_SP();
000629  000700  // Usage : eg:  print(EVE_SP());
000630  000701  // Notes : Used for debugging to assess the current stack level,
000631  000702  //       : mainly for checking stack leaks, see example EVE_SP.4dg
000632  000703        
000633  000704  func EVE_SSIZE(), 1;
000634  000705  // Syntax: EVE_SSIZE();
000635  000706  // Usage : eg:  print(EVE_SSIZE());
000636  000707  // Notes : Used to get the stack size,
000637  000708  //       : mainly for debugging purposes, EVE_SP.4dg
000638  000709        
000639  000710        
000640  000711  //------------------------------------------------------------------//
000641  000712  //
000642  000713  //------------------------------------------------------------------//
000643  000714  func mem_ArrayOp1("memarray", "count", "op", "value"), 0;                     // single array functions
000644  000715        
000645  000716        
000646  000717  // single word array operations
000647  000718  #CONST
000648  000739  #END
000649  000740        
000650  000741        
000651  000742  func mem_ArrayOp2("memarray1", "memarray2", "count", "op", "value"), 0;         // dual array functions
000652  000743        
000653  000744  // dual word array operations
000654  000745  #CONST
000655  000757  #END
000656  000758        
000657  000759        
000658  000760  func __reserved3(), 0; // do not remove
000659  000761  func __reserved4(), 0; // do not remove
000660  000762        
000661  000763        
000662  000764  //------------------------------------------------------------------//
000663  000765  // unsigned long (32 bit) operations                                //
000664  000766  //------------------------------------------------------------------//
000665  000767        
000666  000768  func uadd_3232("res32", "val1", "val2"), 1;
000667  000769  // Syntax   : cmp_3232(res32, varA, varB);
000668  000770  // Input    : DWORD res32 points to optional result (or zero for compare)
000669  000771  //          : DWORD val1 points to 32bit augend
000670  000772  //          : DWORD val2 points to 32bit addend
000671  000773  // Usage    : var res32[2];
000672  000774  //          : res := cmp_3232(res32, val1, val2);
000673  000775  // Notes    : performs an unsigned addition of 2 x 32bit values
000674  000776  //          : placing the 32bit result in a 2 word array.
000675  000777  // Returns  : returns 1 on 32bit unsigned overflow (carry).
000676  000778  //          ; carry flag is also set on 32bit unsigned overflow
000677  000779  //          ; and can be read with the CY() function.
000678  000780        
000679  000781        
000680  000782  func usub_3232("res32", "val1", "val2"), 1;
000681  000783  // Syntax   : cmp_3232(res32, varA, varB);
000682  000784  // Input    : DWORD res32 points to optional result (or zero for compare)
000683  000785  //          : DWORD val1 points to first 32bit minuend
000684  000786  //          : DWORD val2 points to 32bit subtrahend
000685  000787  // Usage    : var res32[2];
000686  000788  //          : res := cmp_3232(res32, val1, val2);
000687  000789  // Notes    : performs an unsigned subtraction of 2 x 32bit values
000688  000790  //          : placing the 32bit result in a 2 word array.
000689  000791  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
000690  000792  //          ; carry flag is also set on 32bit unsigned underflow
000691  000793  //          ; and can be read with the CY() function.
000692  000794        
000693  000795        
000694  000796  func umul_1616("&res32", "val1", "val2"), 1;
000695  000797  // Syntax   : umul_1616(&res32, varA, varB);
000696  000798  // Input    : DWORD result   points to 32bit result register.
000697  000799  //          : VAR   val1  16bit register or constant
000698  000800  //          : VAR   val2  16bit register or constant
000699  000801  // Usage    : var res32[2];
000700  000802  //          : umul_1616(&res32, myvar, 50000);
000701  000803  // Notes    : performs an unsigned multiply of 2 x 16bit values
000702  000804  //          : placing the 32bit result in a 2 word array.
000703  000805  // Returns  : the pointer to the 32bit result.
000704  000806  //          : carry and overflow are not affected.
000705  000807        
000706  000808        
000707  000809  func udiv_3232("res32", "val1", "val2"), 1;
000708  000810  // Syntax   : udiv_1616(res32, varA, varB);
000709  000811  // Input    : DWORD *result   points to 32bit result register.
000710  000812  //          : DWORD   val1  pointer to 32bit value (dividend)
000711  000813  //          : DWORD   val2  pointer to 32bit value (divisor)
000712  000814  // Usage    : var res32[2];
000713  000815  //          : umul_1616(res32, myvar, 50000);
000714  000816  // Notes    : performs an unsigned division of 2 x 32bit values
000715  000817  //          : placing the 32bit result in a 2 word array.
000716  000818  // Returns  : the pointer to the 32bit result.
000717  000819  //          : carry and overflow are not affected.
000718  000820        
000719  000821        
000720  000822  func ucmp_3232("val1", "val2"), 1;
000721  000823  // Syntax   : cmp_3232(varA, varB);
000722  000824  // Input    : DWORD val1 points to 32bit minuend
000723  000825  //          : DWORD val2 points to 32bit sutrahend
000724  000826  // Usage    : res := cmp_3232(val1, val2);
000725  000827  // Notes    : performs an unsigned comparison of 2 x 32bit values.
000726  000828  //          : The result of the subtraction is returned.
000727  000829  // Returns  : 0  if equal
000728  000830  //          : 1  if val1 > val2
000729  000831  //          : -1 if val1 < val2
000730  000832  //          : This function does not affect the carry flag.
000731  000833        
000732  000834  func __reserved5(), 0; // do not remove
000733  000835  func __reserved6(), 0; // do not remove
000734  000836        
000735  000837  //------------------------------------------------------------------//
000736  000838  // Floating point operations                                        //
000737  000839  // Note that source arguments may be a pointer to a float variable, //
000738  000840  // or a numeric text string.                                        //
000739  000841  // A string argument is converted at run-time by calling            //
000740  000842  // flt_Val for a string argument.                                   //
000741  000843  // Note that a float variable is a 2 word array, eg var myfloat[2]; //
000742  000844  //------------------------------------------------------------------//
000743  000845  func flt_VAL("fresult", "numstring"), 1;
000744  000846  // Syntax   : flt_VAL(float1, mystring);
000745  000847  // Input    : FLOAT  fresult  points to float result register
000746  000848  //          : numstring       a string constant or string variable
000747  000849  //          : that is holds valid floating point number.
000748  000850  // Usage    : var float1[2];
000749  000851  //          : flt_VAL(float1, "1.0594631");
000750  000852  // Notes    : The string argument can be a string constant, a pointer
000751  000853  //          : to a string variable, or a pointer to a data statement.
000752  000854  //          : The string may be a float, or a hex or binary integer value (no decimal point allowed).
000753  000855  //          : For hex or binary, the number is preceeded with 0x or 0b
000754  000856  // Returns  : the pointer to the float result.
000755  000857  //          : carry and overflow are not affected.
000756  000858        
000757  000859        
000758  000860  func flt_ITOF("fresult", "var16"), 1;
000759  000861  // Syntax   : flt_ITOF(resf, intval);
000760  000862  // Input    : FLOAT  fresult  points to float result register
000761  000863  //          : var16           a 16bit signed integer variable or string constant
000762  000864  // Usage    : var float1[2];
000763  000865  //          : var myvar := 30000;
000764  000866  //          : flt_VAL(float1, myvar);
000765  000867  // Notes    : Converts a 16bit signed integer value to a signed floating point number.
000766  000868  // Returns  : the pointer to the float result.
000767  000869        
000768  000870        
000769  000871  func flt_UITOF("fresult", "uvar16"), 1;
000770  000872  // Syntax   : flt_ITOF(resf, intval);
000771  000873  // Input    : FLOAT  fresult  points to float result register
000772  000874  //          : var16           a 16bit integer variable or constant (treated as unsigned)
000773  000875  // Usage    : var float1[2];
000774  000876  //          : var myuvar := 30000;
000775  000877  //          : flt_UITOF(float1, myuvar);
000776  000878  // Notes    : Converts a 16bit unsigned integer value to a positive floating point number.
000777  000879  // Returns  : the pointer to the float result.
000778  000880        
000779  000881  func flt_LTOF("fresult", "var32"), 1;
000780  000882  // Syntax   : flt_LTOF(resf, var32);
000781  000883  // Input    : FLOAT  fresult  points to float result register
000782  000884  //          : var32           points to a 32bit (long) signed variable or string constant
000783  000885  // Usage    : var float1[2];
000784  000886  //          : var mylong[2];
000785  000887  //          : flt_VAL(float1, mylong);
000786  000888  // Notes    : Converts a 32bit signed integer value to a signed floating point number.
000787  000889  // Returns  : the pointer to the float result.
000788  000890        
000789  000891        
000790  000892  func flt_ULTOF("fresult", "uvar32"), 1;
000791  000893  // Syntax   : flt_ITOF(resf, uvar32);
000792  000894  // Input    : FLOAT  fresult  points to float result register
000793  000895  //          : var32           points to a 32bit (unsigned long) unsigned variable or string constant
000794  000896  // Usage    : var float1[2];
000795  000897  //          : var myulong[2];
000796  000898  //          : flt_VAL(float1, myulong);
000797  000899  // Notes    : Converts a 32bit unsigned integer value to a positive floating point number.
000798  000900  // Returns  : the pointer to the float result.
000799  000901        
000800  000902        
000801  000903  func flt_PRINT("fvalue", "formatstring"), 1;
000802  000904  // Syntax   : flt_PRINT(resf, formatstr);
000803  000905  // Input    : FLOAT  fresult  points to float result register
000804  000906  //          : formatstring    zero, null string, of valid format string
000805  000907  // Usage    : var float1[2];
000806  000908  //          : flt_PRINT(float1, "");
000807  000909  // Notes    : The string argument can be a string constant, a pointer
000808  000910  //          : to a string variable, or a pointer to a data statement.
000809  000911  //          : If it is zero or an empty string, the number is
000810  000912  //          : automatically formatted for the best presentation.
000811  000913  //          : The format string is similar to the C language, but only
000812  000914  //          : a single '%' may be used to print a single variable.
000813  000915  // Returns  : zero if success.
000814  000916        
000815  000917        
000816  000918  func flt_ABS("result", "floatval"), 1;
000817  000919  // Syntax   : flt_ABS(&result, &fval);
000818  000920  // Input    : FLOAT  result   points to float result register
000819  000921  //          : numstring       a string that is a valid number
000820  000922  // Usage    : var float1[2];
000821  000923  //          : flt_VAL(float1, float1); // convert float1 to its ABS value
000822  000924  // Returns  : the pointer to the float result.
000823  000925  //          : carry and overflow are not affected.
000824  000926        
000825  000927        
000826  000928  func flt_ACOS("result", "floatval"), 1;
000827  000929  // Syntax   : flt_ACOS(result, fval);
000828  000930  // Input    : FLOAT  result (in radians) points to float result register
000829  000931  //          : FLOAT  floatval points to the float value to get arccos of
000830  000932  // Usage    : var float1[2];
000831  000933  //          : flt_ACOS(result, float1); // get the arccos of float1
000832  000934  // Notes    : the result is in radians.
000833  000935  // Returns  : the pointer to the float result.
000834  000936  //          : carry and overflow are not affected.
000835  000937        
000836  000938        
000837  000939  func flt_ASIN("result", "floatval"), 1;
000838  000940  // Syntax   : flt_ASIN(result, fval);
000839  000941  // Input    : FLOAT  result (in radians) points to float result register
000840  000942  //          : FLOAT  floatval points to the float value to get arcsin of
000841  000943  // Usage    : var float1[2];
000842  000944  //          : flt_ASIN(result, float1); // get the Arcsin of float1
000843  000945  // Notes    : the result is in radians.
000844  000946  // Returns  : the pointer to the float result.
000845  000947  //          : carry and overflow are not affected.
000846  000948        
000847  000949        
000848  000950  func flt_ATAN("result", "floatval"), 1;
000849  000951  // Syntax   : flt_ATAN(result, fval);
000850  000952  // Input    : FLOAT  result (in radians) points to float result register
000851  000953  //          : FLOAT  floatval points to the float value to get arctan of
000852  000954  // Usage    : var float1[2];
000853  000955  //          : flt_ATAN(result, float1); // get the Arctan of float1
000854  000956  // Notes    : the result is in radians.
000855  000957  // Returns  : the pointer to the float result.
000856  000958  //          : carry and overflow are not affected.
000857  000959        
000858  000960        
000859  000961  func flt_COS("result", "floatval"), 1;
000860  000962  // Syntax   : flt_COS(result, fval);
000861  000963  // Input    : FLOAT  result   points to float result register
000862  000964  //          : FLOAT  floatval (in radians) points to the float value to get Cos of
000863  000965  // Usage    : var float1[2];
000864  000966  //          : flt_COS(result, float1); // get the Cosine of float1
000865  000967  // Notes    : the result is in radians.
000866  000968  // Returns  : the pointer to the float result.
000867  000969  //          : carry and overflow are not affected.
000868  000970        
000869  000971        
000870  000972  func flt_EXP("result", "floatval"), 1;
000871  000973  // Syntax   : flt_EXP(result, fval);
000872  000974  // Input    : FLOAT  result   points to float result register
000873  000975  //          : FLOAT  floatval points to the float value to get Exponent of
000874  000976  // Usage    : var float1[2];
000875  000977  //          : flt_EXP(result, float1); // get the Exponent of float1
000876  000978  // Returns  : the pointer to the float result.
000877  000979  //          : carry and overflow are not affected.
000878  000980        
000879  000981        
000880  000982  func flt_CEIL("result", "floatval"), 1;
000881  000983  // Syntax   : flt_CEIL(result, floatval);
000882  000984  // Input    : FLOAT  floatval points to the float value to integerize up
000883  000985  // Usage    : var float1[2];
000884  000986  //          : n := flt_INT(float1, float1); // round value up to the integer value
000885  000987  // Notes    : Removes fractional part, rounding up correctly.
000886  000988  // Returns  : the pointer to the float result.
000887  000989  //          : carry and overflow are not affected.
000888  000990        
000889  000991        
000890  000992  func flt_FLOOR("result", "floatval"), 1;
000891  000993  // Syntax   : flt_FLOOR(result, floatval);
000892  000994  // Input    : FLOAT  floatval points to the float value to integerize down
000893  000995  // Usage    : var float1[2];
000894  000996  //          : n := flt_INT(float1, float1); // round value down to the integer value
000895  000997  // Notes    : Removes fractional part, rounding down correctly.
000896  000998  // Returns  : the pointer to the float result.
000897  000999  //          : carry and overflow are not affected.
000898  001000        
000899  001001        
000900  001002  func flt_SIN("result", "floatval"), 1;
000901  001003  // Syntax   : flt_SIN(result, fval);
000902  001004  // Input    : FLOAT  result   points to float result register
000903  001005  //          : FLOAT  floatval (in radians) points to the float value to get Sine of
000904  001006  // Usage    : var float1[2];
000905  001007  //          : flt_SIN(result, float1); // get the Sin of float1
000906  001008  // Notes    : the result is in radians.
000907  001009  // Returns  : the pointer to the float result.
000908  001010  //          : carry and overflow are not affected.
000909  001011        
000910  001012        
000911  001013  func flt_LOG("result", "floatval"), 1;
000912  001014  // Syntax   : flt_LOG(&result, &fval);
000913  001015  // Input    : FLOAT  result   points to float result register
000914  001016  //          : FLOAT  floatval points to the float value to get Log of
000915  001017  // Usage    : var float1[2];
000916  001018  //          : flt_LOG(result, float1); // get the natural Log of float1
000917  001019  // Returns  : the pointer to the float result.
000918  001020  //          : carry and overflow are not affected.
000919  001021        
000920  001022        
000921  001023  func flt_SQR("result", "floatval"), 1;
000922  001024  // Syntax   : flt_SQR(result, fval);
000923  001025  // Input    : FLOAT  result   points to float result register
000924  001026  //          : FLOAT  floatval points to the float value to get Log of
000925  001027  // Usage    : var float1[2];
000926  001028  //          : flt_SQR(result, float1); // get the square root of float1
000927  001029  // Returns  : the pointer to the float result, or zero if number was negative.
000928  001030  //          : carry and overflow are not affected.
000929  001031        
000930  001032        
000931  001033  func flt_TAN("result", "floatval"), 1;
000932  001034  // Syntax   : flt_TAN(result, fval);
000933  001035  // Input    : FLOAT  result   points to float result register
000934  001036  //          : FLOAT  floatval (in radians) points to the float value to get Tangent of
000935  001037  // Usage    : var float1[2];
000936  001038  //          : flt_TAN(result, float1); // get the Tangent of float1
000937  001039  // Returns  : the pointer to the float result.
000938  001040  //          : carry and overflow are not affected.
000939  001041        
000940  001042        
000941  001043  func flt_POW("result", "floatx", "floaty"), 1;
000942  001044  // Syntax   : flt_POW(result, fval1, fval2);
000943  001045  // Input    : FLOAT  result   points to float result register
000944  001046  //          : FLOAT  floatx   points to the float value to raise
000945  001047  //          : FLOAT  floaty   points to the float value for power
000946  001048  // Usage    : flt_POW(result, floatx, floaty); // raise x to power y
000947  001049  // Returns  : the pointer to the float result, or zero if error occurs.
000948  001050  //          : carry and overflow are not affected.
000949  001051        
000950  001052        
000951  001053  func flt_ADD("result", "floatA", "floatB"), 1;
000952  001054  // Syntax   : flt_ADD(result, floatA, floatB);
000953  001055  // Input    : FLOAT  result   points to float result register
000954  001056  //          : FLOAT  floatval points to the float value A
000955  001057  //          : FLOAT  floatval points to the float value B
000956  001058  // Usage    : flt_ADD(result, floatx, floaty); // add B to A
000957  001059  // Returns  : the pointer to the float result, or zero if error occurs.
000958  001060  //          : carry and overflow are not affected.
000959  001061        
000960  001062        
000961  001063  func flt_SUB("&result", "&floatA", "&floatB"), 1;
000962  001064  // Syntax   : flt_SUB(result, floatA, floatB);
000963  001065  // Input    : FLOAT  result   points to float result register
000964  001066  //          : FLOAT  floatval points to the float value A
000965  001067  //          : FLOAT  floatval points to the float value B
000966  001068  // Usage    : flt_SUB(&result, &floatx, &floaty); // subtract B from A
000967  001069  // Returns  : the pointer to the float result, or zero if error occurs.
000968  001070  //          : carry and overflow are not affected.
000969  001071        
000970  001072        
000971  001073  func flt_MUL("result", "floatA", "floatB"), 1;
000972  001074  // Syntax   : flt_MUL(result, floatA, floatB);
000973  001075  // Input    : FLOAT  result   points to float result register
000974  001076  //          : FLOAT  floatval points to the float value A
000975  001077  //          : FLOAT  floatval points to the float value B
000976  001078  // Usage    : flt_MUL(result, floatA, floatB); // multiply A by B
000977  001079  // Returns  : the pointer to the float result, or zero if error occurs.
000978  001080  //          : carry and overflow are not affected.
000979  001081        
000980  001082        
000981  001083  func flt_DIV("result", "floatA", "floatB"), 1;
000982  001084  // Syntax   : flt_DIV(result, floatA, floatB);
000983  001085  // Input    : FLOAT  result   points to float result register
000984  001086  //          : FLOAT  floatval points to the float value A
000985  001087  //          : FLOAT  floatval points to the float value B
000986  001088  // Usage    : flt_DIV(result, floatA, floatB); // divide A by B
000987  001089  // Returns  : the pointer to the float result, or zero if error occurs.
000988  001090  //          : carry and overflow are not affected.
000989  001091        
000990  001092        
000991  001093  //------------------------------------------------------------------//
000992  001094  // The following float functions all return integer values.
000993  001095  //------------------------------------------------------------------//
000994  001096  func flt_EQ("floatA", "floatB"), 1;
000995  001097  // Syntax   : flt_EQ(floatA, floatB);
000996  001098  // Input    : FLOAT  floatval points to the float value A
000997  001099  //          : FLOAT  floatval points to the float value B
000998  001100  // Usage    : if (flt_EQ(floatA, floatB)) // compare A to B, true if A == B
000999  001101  // Returns  : True if numbers are equal, false otherwise.
001000  001102        
001001  001103        
001002  001104  func flt_NE("floatA", "floatB"), 1;
001003  001105  // Syntax   : flt_NE(floatA, floatB);
001004  001106  // Input    : FLOAT  floatval points to the float value A
001005  001107  //          : FLOAT  floatval points to the float value B
001006  001108  // Usage    : if (flt_NE(floatA, floatB)) // compare A to B, true if A != B
001007  001109  // Returns  : True if numbers are not equal, false otherwise.
001008  001110        
001009  001111        
001010  001112        
001011  001113  func flt_GT("floatA", "floatB"), 1;
001012  001114  // Syntax   : flt_GT(floatA, floatB);
001013  001115  // Input    : FLOAT  floatval points to the float value A
001014  001116  //          : FLOAT  floatval points to the float value B
001015  001117  // Usage    : if (flt_GT(floatA, floatB)) // compare A to B, true if A > B
001016  001118  // Returns  : True if A > B, false otherwise.
001017  001119        
001018  001120        
001019  001121  func flt_GE("floatA", "floatB"), 1;
001020  001122  // Syntax   : flt_GE(floatA, floatB);
001021  001123  // Input    : FLOAT  floatval points to the float value A
001022  001124  //          : FLOAT  floatval points to the float value B
001023  001125  // Usage    : if (flt_GE(floatA, floatB)) // compare A to B, true if A >= B
001024  001126  // Returns  : True if A >= B, false otherwise.
001025  001127        
001026  001128        
001027  001129  func flt_LT("floatA", "floatB"), 1;
001028  001130  // Syntax   : flt_LT(floatA, floatB);
001029  001131  // Input    : FLOAT  floatval points to the float value A
001030  001132  //          : FLOAT  floatval points to the float value B
001031  001133  // Usage    : if (flt_LT(floatA, floatB)) // compare A to B, true if A < B
001032  001134  // Returns  : True if A < B, false otherwise.
001033  001135        
001034  001136        
001035  001137  func flt_LE("floatA", "floatB"), 1;
001036  001138  // Syntax   : flt_LE(floatA, floatB);
001037  001139  // Input    : FLOAT  floatval points to the float value A
001038  001140  //          : FLOAT  floatval points to the float value B
001039  001141  // Usage    : if (flt_LE(floatA, floatB )) // compare A to B, true if A <= B
001040  001142  // Returns  : True if A <= B, false otherwise.
001041  001143        
001042  001144        
001043  001145  func flt_SGN("floatval"), 1;
001044  001146  // Syntax   : flt_SGN(fval);
001045  001147  // Input    : FLOAT  floatval   points to the float value examine sign
001046  001148  // Usage    : var float1[2];
001047  001149  //          : n := flt_SGN(float1); // return -1 if float number negative
001048  001150  // Notes    : returns 0 if sign is positive or zero.
001049  001151  // Returns  : returns 16bit integer -1 if float sign is negative, or zero if positive.
001050  001152  //          : carry and overflow are not affected.
001051  001153        
001052  001154        
001053  001155  func flt_FTOI("floatvar"), 1;
001054  001156  // Syntax   : flt_FTOI(myfloat);
001055  001157  // Input    : FLOAT  fresult  points to float result register
001056  001158  // Usage    : var float1[2];
001057  001159  //          : myvar := flt_VAL(&float1, myvar);
001058  001160  // Notes    : Converts a floating point number to a 16bit integer.
001059  001161  //          : The floating point number is rounded up or down accordingly.
001060  001162  // Returns  : the integer value of the float.
001061  001163        
001062  001164  func flt_PRINTxy("xpos", "ypos", "fvalue", "formatstring"), 1;
001063  001165  // Syntax   : flt_PRINT(x, y, resf, formatstr);
001064  001166  // Input    : FLOAT  fresult  points to float result register
001065  001167  //          : formatstring    zero, null string, of valid format string
001066  001168  // Usage    : var float1[2];
001067  001169  //          : flt_PRINT(float1, "");
001068  001170  // Notes    : The string argument can be a string constant, a pointer
001069  001171  //          : to a string variable, or a pointer to a data statement.
001070  001172  //          : If it is zero or an empty string, the number is
001071  001173  //          : automatically formatted for the best presentation.
001072  001174  //          : The format string is similar to the C language, but only
001073  001175  //          : a single '%' may be used to print a single variable.
001074  001176  // Returns  : zero if success.
001075  001177        
001076  001178  func __reserved9(), 0; // do not remove
001077  001179  func __reserved10(), 0; // do not remove
001078  001180        
001079  001181  //------------------------------------------------------------------//
001080  001182  //------------------------------------------------------------------//
001081  001183  //------------------------------------------------------------------//
001082  001184  //------------------------------------------------------------------//
001083  001185  //------------------------------------------------------------------//
001084  001186  func pin_Set("mode", "pin"), 1;            // set pin to required mode
001085  001187  // Syntax: pin_Set(mode, pin);
001086  001188  // Usage : pin_Set(PIN_OUT,);
001087  001189  // Notes : Sets the selected pin to the desired mode. Refer to the manual
001088  001190  //       : for pin function compatitblilites.
001089  001191  //       : returns true if the pin number and mode is legal (usually ignored)
001090  001192  //       :    available pin modes
001091  001193  //       :    PIN_INP                 0        // pin is input, no pullup or pulldown
001092  001194  //       :    PIN_INP_HI              1        // pin is input with pullup to Vcc
001093  001195  //       :    PIN_INP_LO              2        // pin is input with pulldown to Gnd
001094  001196  //       :    PIN_OUT                 3        // pin is output
001095  001197  //       :    PIN_OUT_OD              4        // pin is output with open drain
001096  001198  //       :    PIN_AN                  5        // pin is analogue (PA0 to PA3 only)
001097  001199  //       :    PIN_ANAVG               6        // pin is analogue (PA0 to PA3 only), averaged - 16 samples
001098  001200  //       :
001099  001201        
001100  001202  func pin_HI("pin"), 1;                    // set pin to logic '1'
001101  001203  // Syntax: pin_HI(pin);
001102  001204  // Usage : pin_HI(PA4);        // make PA4 HI level
001103  001205  // Notes : Outputs a logic "High" to the pin latch
001104  001206  //       : The pin is automatically made an output.
001105  001207  //       : pullup, pulldown, and change notification will be disable for the selected pin.
001106  001208  //       : returns true if the pin number is legal (usually ignored)
001107  001209  //       :
001108  001210        
001109  001211  func pin_LO("pin"), 1;                    // set pin to logic '0'
001110  001212  // Syntax: pin_LO(pin);
001111  001213  // Usage : pin_LO(PA3);
001112  001214  // Notes : Outputs a logic "Low" to the pin latch
001113  001215  //       : The pin is automatically made an output.
001114  001216  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001115  001217  //       : returns true if the pin number is legal (usually ignored)
001116  001218  //       :
001117  001219        
001118  001220  func pin_Val("pin", "value"), 0;                    // set pin to to state of variable
001119  001221  // Syntax: pin_Var(pin, value);
001120  001222  // Usage : pin_Var(IO3, myvar);
001121  001223  // Notes : Outputs a logic state on a pin depending on the value of bit 0 of a variable
001122  001224  //       : The pin is automatically made an output.
001123  001225  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001124  001226  //       : returns true if the pin number is legal (usually ignored)
001125  001227        
001126  001228  func pin_Read("pin"), 1;                // read pin, logic or analogue
001127  001229  // Syntax: pin_Read(PA0);
001128  001230  // Usage : arg1 := pin_Read(arg2);
001129  001231  // Notes : Read a pin in various ways. If the pin is
001130  001232  //       : set to an input, read the state of the input pin.
001131  001233  //       : If set to an output, read the state of the output latch.
001132  001234  //       : If set to analogue, read the 12 bit analogue value.
001133  001235        
001134  001236  func bus_Read(), 1;
001135  001237  // Syntax: bus_Read();
001136  001238  // Usage : arg1 := pin_ReadBus();
001137  001239  // Notes : Read the 16 bit port regardless of pin configurations.
001138  001240  //       : If a pin is configured as input or analogue, the pin is read directly as
001139  001241  //       : if it were a digital input. If a pin is configured as an output, the pin
001140  001242  //       : is also read directly, giving the output latch state.
001141  001243  //       : Bit 0 coresponds to PA0 through to bit15 which coresponds to PA15
001142  001244  //       : (Refer to 'port bit position masks')
001143  001245  //Returns: Returns the 16 bit value of the bus.
001144  001246        
001145  001247  func bus_SetPins("value"), 0;
001146  001248  // Syntax: bus_SetPins(value);
001147  001249  // Usage : arg1 := bus_SetPins(15); // set PA0 to PA3 to output bits, making them HI
001148  001250  // Notes : Any '1' bits in "value" set the coresponding port pin to an output
001149  001251  //       : and forces its state to a '1'. The state of its previous open drain
001150  001252  //       : configuration is not altered. Any zero bits in "value" will not affect the pin.
001151  001253  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001152  001254  //       : Bit 0 coresponds to PA0 through to bit13 which coresponds to PA13
001153  001255        
001154  001256  func bus_ClearPins("value"), 0;
001155  001257  // Syntax: bus_ClearPins(value);
001156  001258  // Usage : bus_ClearPins(0x03F0); // set PA0 to PA5 to output bits, making them LO
001157  001259  // Notes : Any '1' bits in "value" set the coresponding port pin to an output
001158  001260  //       : and forces its state to a '0. The state of its previous open drain
001159  001261  //       : configuration is not altered. Any zero bits in "value" will not affect the pin.
001160  001262  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001161  001263  //       : Bit 0 coresponds to PA0 through to bit13 which coresponds to PA13
001162  001264        
001163  001265  func bus_SetChangeInterrupt("function", "portmask"), 1;
001164  001266  // Syntax: bus_SetChangeInterrupt(value);
001165  001267  // Usage : bus_SetChangeInterrupt(scanKeypad, 0x00F0); // set PA4 to PA7 to interrupt on change
001166  001268  // Notes : Any '1' bits in "portmask" marks that pin to generate an interrupt on change.
001167  001269  //       : A level change on that pin will cause "function" to be executed. If "function" is
001168  001270  //       : zero, the display may be put into sleep mode, and any change will cause a wakeup reset.
001169  001271  //       : Wakeup will always re-start code running in FLASHBANK_0
001170  001272  //       : Bit 0 coresponds to PA0 through to bit15 which coresponds to PA15
001171  001273  //       : (Refer to 'port bit position masks')
001172  001274  //       : Once armed, "function" will only be executed once, it is necessary to
001173  001275  //       : re-arm for any further events.
001174  001276  //Returns: Return the current state of the pins that are selected in "portmask"
001175  001277  //       : This can be saved and later used in "function" to see which pin(s) actually changed.
001176  001278        
001177  001279  func bus_Write8("var"), 0;
001178  001280  // Syntax: bus_Write8(var);
001179  001281  // Usage : bus_Write8(arg1);
001180  001282  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
001181  001283  //       : a settling delay of approx 50nsec, the BUS_WR(PA2) pin is strobed
001182  001284  //       : LO for approx 50nsec then set back HI.
001183  001285  //       : The upper 8 bits of arg1 are ignored.
001184  001286  //       : NB:- the BUS_WR(PA2) pin must be preset to the desired output state
001185  001287  //       : as must the bus pins to ensure BUS write integrity.
001186  001288  //       :
001187  001289  //       : BUS_0 is PA4
001188  001290  //       : BUS_1 is PA5
001189  001291  //       : BUS_2 is PA6
001190  001292  //       : BUS_3 is PA7
001191  001293  //       : BUS_4 is PA8
001192  001294  //       : BUS_5 is PA9
001193  001295  //       : BUS_6 is PA10
001194  001296  //       : BUS_7 is PA11
001195  001297        
001196  001298  func bus_Read8(), 1;
001197  001299  // Syntax: bus_Read();
001198  001300  // Usage : arg1 := bus_Read8();
001199  001301  // Notes : The BUS_RD(PA3) pin set to LO, then, after a settling delay
001200  001302  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
001201  001303  //       : (the upper 8 bits being set to 0)
001202  001304  //       : the BUS_RD(PA3) pin is then set back to a HI level.
001203  001305  //       : NB:- the BUS_RD(PA3) pin must be preset to the desired output state
001204  001306  //       : as must the bus pins to ensure BUS read integrity.
001205  001307  //       :
001206  001308  //       : BUS_0 is PA4
001207  001309  //       : BUS_1 is PA5
001208  001310  //       : BUS_2 is PA6
001209  001311  //       : BUS_3 is PA7
001210  001312  //       : BUS_4 is PA8
001211  001313  //       : BUS_5 is PA9
001212  001314  //       : BUS_6 is PA10
001213  001315  //       : BUS_7 is PA11
001214  001316        
001215  001317  func __reserved13(), 0; // do not remove
001216  001318  func __reserved14(), 0; // do not remove
001217  001319  //------------------------------------------------------------------//
001218  001320  // Pin related constants                                            //
001219  001321  //------------------------------------------------------------------//
001220  001322        
001221  001323  // pin_Set(...) pin modes
001222  001324  #CONST
001223  001332  #END
001224  001333        
001225  001334        
001226  001335  // pin name             constant    connector H1 I/O Pin referencesnumbers
001227  001336  #CONST
001228  001357  #END
001229  001358        
001230  001359  // bit position masks
001231  001360  #CONST
001232  001377  #END
001233  001378        
001234  001379        
001235  001380        
001236  001381  //------------------------------------------------------------------//
001237  001382  //   Graphics Functions
001238  001383  //------------------------------------------------------------------//
001239  001384  func gfx_Set("mode", "value"), 0;            // set various graphics functions
001240  001385  // Syntax: gfx_Set(mode, value);
001241  001386  // Usage : gfx_Set(arg1, arg2);
001242  001387  // Notes : Sets various graphics parameters used by other functions
001243  001388  //       : This allows the features to be set programatically with a
001244  001389  //       : single function call.It is strongly recommended to use the
001245  001390  //       : pre-defined constants rather than the mode numbers.
001246  001391  //       : NB:- Although it is often required to be able to set graphics
001247  001392  //       : functions with a single function call for graphics engine
001248  001393  //       : related functions, there is a complete set of single parameter
001249  001394  //       : shortcut functions that have exactly the same function as
001250  001395  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
001251  001396  //       :
001252  001397  //       : mode = PEN_SIZE (mode 16)
001253  001398  //       : gfx_Set(PEN_SIZE, value);
001254  001399  //       : value = SOLID (value 0) rectangle and circle objects are solid
001255  001400  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
001256  001401  //       : Sets the mode of the Pen used by most graphics objects
001257  001402  //       :
001258  001403  //       : mode = BACKGROUND_COLOUR (mode 17)
001259  001404  //       : gfx_Set(BACKGROUND_COLOUR, value);
001260  001405  //       : value = 0 to 0xFFFF, Black to White
001261  001406  //       : Sets the Background colour of the screen
001262  001407  //       :
001263  001408  //       : mode = OBJECT_COLOUR (mode 18)
001264  001409  //       : gfx_Set(OBJECT_COLOUR, value);
001265  001410  //       : value = 0 to 0xFFFF, Black to White
001266  001411  //       : Sets the Object colour used in various functions
001267  001412  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
001268  001413  //       :
001269  001414  //       : mode = CLIPPING (mode 19)
001270  001415  //       : gfx_Set(CLIPPING, value);
001271  001416  //       : value = OFF (value 0) Clipping disabled
001272  001417  //       : value = ON (value 1) Clipping enabled
001273  001418  //       : Enables/Disables the Clipping feature
001274  001419  //       :
001275  001420  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
001276  001421  //       : gfx_Set(TRANSPARENT_COLOUR, value);
001277  001422  //       : value = 0 to 0xFFFF Black to White
001278  001423  //       : Sets Bitmap, Image or Animation Transparency Colour.
001279  001424  //       : NB not implemented
001280  001425  //       :
001281  001426  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
001282  001427  //       : gfx_Set(5, value);
001283  001428  //       : value = OFF (value 0) Transparency disabled
001284  001429  //       : value = ON (value 1) Transparency enabled
001285  001430  //       : Enables/Disables the Transparency feature
001286  001431  //       : NB not implemented
001287  001432  //       :
001288  001433  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
001289  001434  //       : gfx_Set(FRAME_DELAY, value);
001290  001435  //       : value = 0 to 65535 ms
001291  001436  //       : Sets the Video/Animation clip inter-frame delay. This setting will
001292  001437  //       : over-ride the embedded frame delay of the clip. After the event,
001293  001438  //       : the setting will auto disable and if further inter-frame delays need
001294  001439  //       : overriding the setting must be re-issued.
001295  001440  //       :
001296  001441  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
001297  001442  //       : gfx_Set(SCREEN_MODE, value);
001298  001443  //       : value = LANDSCAPE   (value 0)
001299  001444  //       : value = LANDSCAPE_R (value 1)
001300  001445  //       : value = PORTRAIT    (value 2)
001301  001446  //       : value = PORTRAIT_R  (value 3)
001302  001447  //       :
001303  001448  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
001304  001449  //       : gfx_Set(OUTLINE_COLOUR, value);
001305  001450  //       : value = 1 to 0xFFFF, if 0, featre is OFF
001306  001451  //       : Sets the filled Rectangle or Circle objects outline colour
001307  001452  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
001308  001453  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
001309  001454  //       :
001310  001455  //       : Only supports variable contrast for uOLED Modules
001311  001456  //       : mode = CONTRAST (mode 25) : Contrast
001312  001457  //       : gfx_Set(CONTRAST, value);
001313  001458  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
001314  001459  //       : when contrast=0, display is placed in low power mode.
001315  001460  //       : This function should be called with contrast=0 when
001316  001461  //       : powering down the module.
001317  001462  //       :
001318  001463  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
001319  001464  //       : gfx_Set(LINE_PATTERN, value);
001320  001465  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
001321  001466  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
001322  001467  //       : a value of 0 turns the feature off
001323  001468  //       :
001324  001469  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
001325  001470  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
001326  001471  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
001327  001472  //       : NB not implemented, default is COLOUR16
001328  001473  //       :
001329  001474  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
001330  001475  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
001331  001476  //       : sets the button and slider objects bevel width
001332  001477  //       :
001333  001478  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
001334  001479  //       : gfx_Set(BEVEL_SHADOW , 5);
001335  001480  //       : sets the button and slider objects darken and lighten depth for the bevel colour
001336  001481  //       :
001337  001482  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
001338  001483  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
001339  001484  //       : sets the origin of drawn objects to a position other than 0,0
001340  001485  //       :
001341  001486  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
001342  001487  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
001343  001488  //       : sets the origin of drawn objects to a position other than 0,0
001344  001489        
001345  001490  //------------------------------------------------------------------------------
001346  001491  //gfx_Set() related constants
001347  001492  //------------------------------------------------------------------------------
001348  001493  #CONST
001349  001510  #END
001350  001511        
001351  001512        
001352  001513  func gfx_Cls(), 0;                    // clear the screen
001353  001514  // Syntax: gfx_Cls();
001354  001515  // Usage : gfx_Cls();
001355  001516  // Notes : Clears the screen with current background colour
001356  001517        
001357  001518  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
001358  001519  // Syntax: gfx_MoveTo(x, y);
001359  001520  // Usage : gfx_MoveTo(arg1, arg2);
001360  001521  // Notes : Moves the origin to a new x,y position
001361  001522        
001362  001523  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
001363  001524  // Syntax: gfx_MoveRel(x, y);
001364  001525  // Usage : gfx_MoveRel(arg1, arg2);
001365  001526  // Notes : Moves the origin to a new x,y position
001366  001527  //       : relative to the current origing
001367  001528        
001368  001529  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
001369  001530  // Syntax: gfx_LineTo(x1, y1);
001370  001531  // Usage : gfx_LineTo(arg1, arg2);
001371  001532  // Notes : Draws a Line from the origin x,y to x1,y1.
001372  001533  //       : The new origin is then set to x1, y1. Line colour needs
001373  001534  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
001374  001535        
001375  001536  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
001376  001537  // Syntax: gfx_LineRel(x1, y1);
001377  001538  // Usage : gfx_LineRel(arg1, arg2);
001378  001539  // Notes : Draws a Line from the origin x,y to x1,y1.
001379  001540  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
001380  001541  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
001381  001542        
001382  001543  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
001383  001544  // Syntax: gfx_Line(x1, x2, y2, colr);
001384  001545  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
001385  001546  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
001386  001547        
001387  001548  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
001388  001549  // Syntax: gfx_Line(x1, x2, y, colr);
001389  001550  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
001390  001551  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
001391  001552        
001392  001553  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
001393  001554  // Syntax: gfx_Line(y1, y2, x, colr);
001394  001555  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
001395  001556  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
001396  001557        
001397  001558  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
001398  001559  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
001399  001560  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
001400  001561  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
001401  001562  //       : bottom corner (x2,y2) on the screen.
001402  001563        
001403  001564  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
001404  001565  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
001405  001566  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
001406  001567  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
001407  001568  //       : bottom corner (x2,y2) on the screen.
001408  001569        
001409  001570  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
001410  001571  // Syntax: gfx_Circle(x, y, rad, colr);
001411  001572  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
001412  001573  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
001413  001574        
001414  001575  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
001415  001576  // Syntax: gfx_Circle(x, y, rad, colr);
001416  001577  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
001417  001578  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
001418  001579        
001419  001580  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
001420  001581  // Syntax: gfx_PutPixel(x, y, colr);
001421  001582  // Usage : gfx_PutPixel(arg1, arg2, arg3);
001422  001583  // Notes : Plots a coloured pixel on the screen at x,y location
001423  001584        
001424  001585  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
001425  001586  // Syntax: gfx_GetPixel(x, y);
001426  001587  // Usage : var := gfx_GetPixel(arg1, arg2);
001427  001588  // Notes : Reads and returns the colour value of a pixel at location x,y
001428  001589        
001429  001590  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
001430  001591  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
001431  001592  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
001432  001593  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
001433  001594  //       : Vertices must be specified in an anti-clockwise fashion
001434  001595        
001435  001596  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
001436  001597  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
001437  001598  // Usage : gfx_OrbitInit(&arg1, &arg2);
001438  001599  // Notes : Sets up the Orbit function parameters.
001439  001600  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
001440  001601  //       : variables that get updated after calling gfx_Orbit(,,) function.
001441  001602  //       : The coordiantaes are calculated relative to the origin
001442  001603  //       : obtained by using the gfx_MoveTo(x, y) function.
001443  001604        
001444  001605  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
001445  001606  // Syntax: gfx_Orbit(angle, distance);
001446  001607  // Usage : gfx_Orbit(arg1, arg2);
001447  001608  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
001448  001609  //       : only known parameters are the angle and the distance from the current origin.
001449  001610        
001450  001611  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
001451  001612  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
001452  001613  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
001453  001614  // Notes : This function is very similar to the Ploygon function
001454  001615  //       : with the exception of the 1st and the last vertices not joined.
001455  001616        
001456  001617  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
001457  001618  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
001458  001619  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
001459  001620  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001460  001621  //       : Vertices must be minimum of 3 and can be specified in any fashion
001461  001622        
001462  001623  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
001463  001624  // Syntax: gfx_Dot();
001464  001625  // Usage : gfx_Dot();
001465  001626  // Notes : Places a coloured dot at the origin
001466  001627        
001467  001628        
001468  001629  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
001469  001630  // Syntax: gfx_Bullet();
001470  001631  // Usage : gfx_Bullet();
001471  001632  // Notes : Places a coloured circle at the origin
001472  001633  //       : filled or unfilled state is controlled by PenSize
001473  001634        
001474  001635  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
001475  001636  // Syntax: gfx_IncX();
001476  001637  // Usage : var := gfx_IncX();
001477  001638  // Notes : Increments the x coordinate of the origin
001478  001639        
001479  001640  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
001480  001641  // Syntax: gfx_IncY();
001481  001642  // Usage : var := gfx_IncY();
001482  001643  // Notes : Increments the y coordinate of the origin
001483  001644        
001484  001645  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
001485  001646  // Syntax: gfx_BoxTo(x1, y1);
001486  001647  // Usage : gfx_BoxTo(arg1, arg2);
001487  001648  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
001488  001649  //       : The new origin is then set to x1,y1. Rectangle colour needs
001489  001650  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
001490  001651  //       : and the PenSize setting determines if Box is solid or outline.
001491  001652        
001492  001653  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
001493  001654  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
001494  001655  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
001495  001656  // Notes : Specifies a clipping window region on the screen such that any objects
001496  001657  //       : and text placed onto the screen will be clipped and displayed only
001497  001658  //       : within that region. For the clipping window to take effect, "Clipping"
001498  001659  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
001499  001660        
001500  001661        
001501  001662  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
001502  001663  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
001503  001664  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
001504  001665  // *Notes:
001505  001666        
001506  001667  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
001507  001668  // Syntax: gfx_SetClipRegion();
001508  001669  // Usage : var := gfx_SetClipRegion();
001509  001670  // *Notes:
001510  001671        
001511  001672  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
001512  001673  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
001513  001674  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
001514  001675  // Notes : Plots a coloured Ellipse on the screen at centre x,y
001515  001676  //       : with xradius = xrad and yradius = yrad.
001516  001677  //       : if PenSize = 0 Ellipse is Solid
001517  001678  //       : if PenSize = 1 Ellipse is Outline
001518  001679        
001519  001680        
001520  001681  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
001521  001682  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
001522  001683  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
001523  001684  // Notes : Plots a coloured Ellipse on the screen at centre x,y
001524  001685  //       : with xradius = xrad and yradius = yrad.
001525  001686        
001526  001687        
001527  001688  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 1;
001528  001689  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
001529  001690  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
001530  001691  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001531  001692  //       : x,y arguments (top left corner). The size of the button depends on
001532  001693  //       : the font, width, height and length of the text.
001533  001694  //       : The button appearance will depend on the state parameter setting:
001534  001695  //       :         state = 0 : Button Pressed
001535  001696  //       :         state = 1 : Button Raised
001536  001697  //       : The button is automatically sized, determined by text.
001537  001698        
001538  001699        
001539  001700  func gfx_Button2("state", "x", "y", "Width", "Height", "buttonColour", "textColour", "text"), 0;
001540  001701  // Syntax: gfx_Button2(mode, x, y, width, height, buttoncolour, textcolour, text);
001541  001702  // Usage : gfx_Button2(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001542  001703  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001543  001704  //       : x,y arguments (top left corner). The size of the button is defined by the width
001544  001705  //       : and height parameters. The text is centered within those bounds.
001545  001706  //       : The button appearance will depend on the state parameter setting:
001546  001707  //       :         state = 0 : Button Pressed
001547  001708  //       :         state = 1 : Button Raised
001548  001709  //       : The button has square corners.
001549  001710        
001550  001711  func gfx_Button3("state", "x", "y", "Width", "Height", "buttonColour", "textColour", "text"), 0;
001551  001712  // Syntax: gfx_Button3(mode, x, y, width, height, buttoncolour, textcolour, text);
001552  001713  // Usage : gfx_Button3(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001553  001714  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001554  001715  //       : x,y arguments (top left corner). The size of the button is defined by the width
001555  001716  //       : and height parameters. The text is centered within those bounds.
001556  001717  //       : The button appearance will depend on the state parameter setting:
001557  001718  //       :         state = 0 : Button Pressed
001558  001719  //       :         state = 1 : Button Raised
001559  001720  //       : The button has rounded corners depending upon gfx_BevelRadius.
001560  001721        
001561  001722  func gfx_CheckBox("state", "x", "y", "Width", "Height", "boxColour", "textColour", "text"), 0;
001562  001723  // Syntax: gfx_CheckBox(state, x, y, Width, Height, boxColour, textColour, text);
001563  001724  // Usage : gfx_CheckBox(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001564  001725  // Notes : Draws a CheckBox at screen location defined by x,y arguments (top left corner).
001565  001726  //       : The size of the button is defined by the width and height parameters.
001566  001727  //       : The text is to the right of the checkbox and truncated if necessary.
001567  001728  //       : The check appearance will depend on the state parameter setting:
001568  001729  //       :         state = 0 = CHECKED    : Checkbox Checked
001569  001730  //       :         state = 1 = UNCHECKED  : CheckBox Unchecked
001570  001731        
001571  001732  func gfx_RadioButton("state", "x", "y", "Width", "Height", "boxColour", "textColour", "text"), 0;
001572  001733  // Syntax: gfx_RadioButton(state, x, y, Width, Height, boxColour, textColour, text);
001573  001734  // Usage : gfx_RadioButton(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001574  001735  // Notes : Draws a RadioButton at screen location defined by x,y arguments (top left corner).
001575  001736  //       : The size of the button is defined by the width and height parameters.
001576  001737  //       : The text is to the right of the radiobutton and truncated if necessary.
001577  001738  //       : The check appearance will depend on the state parameter setting:
001578  001739  //       :         state = 0 = CHECKED    : Radiobutton Checked
001579  001740  //       :         state = 1 = UNCHECKED  : Radiobutton Unchecked
001580  001741        
001581  001742  func gfx_Slider2("mode", "x1", "y1", "width", "height", "colour", "scale", "value"), 1;
001582  001743  // Syntax: gfx_Slider2(mode, x, y, width, height, colour, scale, value);
001583  001744  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001584  001745  // Notes : Draws a 3 dimensional Slider Bar on the screen.
001585  001746  //       : Slider parameters are as follows:
001586  001747  //       :         mode = 0 : Slider recessed
001587  001748  //       :         mode = 1 : Slider raised
001588  001749  //       :         x1, y1 = top left corner
001589  001750  //       :         x2, y2 = bottom right corner
001590  001751  //       :         scale = n : sets the full scale range from 0 to n
001591  001752  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
001592  001753  //returns: scaled value of thumb position
001593  001754        
001594  001755        
001595  001756        
001596  001757        
001597  001758  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
001598  001759  // Syntax: gfx_Panel(style, x, y, width, height, colour);
001599  001760  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
001600  001761  // Notes : Draws a panel (groupbox) at screen location defined by
001601  001762  //       : x, y, width and height with colour "colour".
001602  001763  //       :         state = 0 : sunken
001603  001764  //       :         state = 1 : raised
001604  001765  //       :         state = 2 : hide (draw object in background colour)
001605  001766  //returns: nothing
001606  001767        
001607  001768        
001608  001769        
001609  001770  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
001610  001771  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
001611  001772  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001612  001773  // Notes : Draws a 3 dimensional Slider Bar on the screen.
001613  001774  //       : Slider parameters are as follows:
001614  001775  //       :         mode = 0 : Slider recessed
001615  001776  //       :         mode = 1 : Slider raised
001616  001777  //       :         x1, y1 = top left corner
001617  001778  //       :         x2, y2 = bottom right corner
001618  001779  //       :         scale = n : sets the full scale range from 0 to n
001619  001780  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
001620  001781  //returns: scaled value of thumb position
001621  001782        
001622  001783        
001623  001784        
001624  001785  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
001625  001786  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
001626  001787  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
001627  001788  // Notes : Copies an area of a screen from xs,ys of size given by width and height
001628  001789  //       : and pastes it to another location determined by xd, yd.
001629  001790        
001630  001791  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
001631  001792  // Syntax: gfx_RGBto565(red, green, blue);
001632  001793  // Usage : gfx_RGBto565(arg1, arg2, arg3);
001633  001794  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
001634  001795        
001635  001796  func gfx_332to565("COLOUR8BIT"), 1;
001636  001797  // Syntax: gfx_332to565(colour);
001637  001798  // Usage : gfx_332to565(arg);
001638  001799  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
001639  001800        
001640  001801  func gfx_565to332("COLOUR16BIT"), 1;
001641  001802  // Syntax: gfx_565to332(colour);
001642  001803  // Usage : clor332 := gfx_565to332(arg);
001643  001804  // Notes : Returns the 8bit (332 format) colour value of an 16 bit (565 format) colour
001644  001805        
001645  001806  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
001646  001807  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
001647  001808  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
001648  001809  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
001649  001810  //       : Vertices must be specified in an anti-clockwise fashion
001650  001811        
001651  001812        
001652  001813  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
001653  001814  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
001654  001815  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001655  001816  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001656  001817  //       : Vertices must be minimum of 3 and can be specified in any fashion
001657  001818        
001658  001819        
001659  001820  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001660  001821  // Syntax: gfx_Offset(x, y);
001661  001822  // Usage : gfx_Offset(arg1, arg2);
001662  001823  // Notes : Set the screen offset
001663  001824        
001664  001825        
001665  001826        
001666  001827  func gfx_FillPattern("patptr", "mode"), 1;
001667  001828  // Syntax  : gfx_FillPattern(patternpointer);
001668  001829  // Usage   : gfx_FillPattern(PTN_BRICKS);
001669  001830  //         : Provides graphics fill pattern, (8 linear bytes, 1=pixel off)
001670  001831  // Notes   : "patptr" points to an 8x8 tile for rendering filled areas.
001671  001832  //         : Rendering is turned off with gfx_FillPattern(0);
001672  001833  //         : or gfx_FillPattern(OFF);
001673  001834  //         : "mode" maybe TRANSPARENT or OPAQUE (0 or 1), for OPAQUE
001674  001835  //         : mode, the current screen colour is used for the 'off'
001675  001836  //         : pixels, for transparent mode, the 'off' pixels are not drawn.
001676  001837  //         : gfx_FillPattern affects all filled object, including polygons.
001677  001838  //         : There are 32 builtin patterns, these are obtained using the
001678  001839  //         : pre-defined constants FILLPATTERN_0 to FILLPATTERN_31, or the
001679  001840  //         : names, eg PTN_BRICKS, PTN_CARGONET, PTN_CIRCUITS, etc.
001680  001841  //         : Note that the constants range from 0xFFE0 to 0xFFFF, any
001681  001842  //         : other value is assumed to be a pointer to a users 8 byte
001682  001843  //         : block pattern.
001683  001844  // Returns : returns the handle of the previous pattern.
001684  001845        
001685  001846        
001686  001847  func gfx_PieSlice("cx", "cy", "spread", "radius", "step", "startangle", "endangle", "mode", "colour"), 0;
001687  001848  // Syntax  : gfx_PieSlice(cx, cy, spread, radius, step, startangle, endangle, mode, colour);
001688  001849  // Usage   : gfx_PieSlice(120, 120, 0, 100, 8, 75, 145, 0, YELLOW);
001689  001850  // Notes   : Draws a 'pie slice' (filled arc) at "cx":"cy" with radius "radius", starting at "startangle"
001690  001851  //         : and ending at "endangle". "spread" is used to offset the centrepoint of the pieslice
001691  001852  //         : to shift a pie chart piece away from the centrepoint.
001692  001853  //         : Rendering can be obtained with gfx_FillPattern(PATTRN);
001693  001854  //         : or gfx_FillPattern(OFF); for no fill pattern.
001694  001855  //         : Step is the stepping angle increment for the fineness of the pie Slice.
001695  001856  //         : "mode" has the following effect
001696  001857  //         :   if mode = 0, no outline
001697  001858  //         :   if mode = 1, outer circumference line (using current object colour)
001698  001859  //         :   if mode = 2, outer circumference and slice lines ( (using current object colour)
001699  001860  // Returns : nothing.
001700  001861        
001701  001862        
001702  001863  func gfx_Arc("xc", "yc", "radius", "step", "startangle", "endangle", "mode"), 0;
001703  001864  // Syntax  : gfx_Arc(cx, cy, radius, step, startangle, endangle, mode);
001704  001865  // Usage   : gfx_Arc(120, 120, 0, 100, 8, 75, 145, 0);
001705  001866  // Notes   : Draws an arc at "cx":"cy" with radius "radius", starting at "startangle"
001706  001867  //         : and ending at "endangle". Colour is determined by curent object colour.
001707  001868  //         : Step is the stepping angle increment for the fineness of the arc.
001708  001869  //         : "mode" has the following effect
001709  001870  //         :   if mode = 0, outer circumference line only
001710  001871  //         :   if mode = 1, outer circumference and lines back to cy:cy
001711  001872  // Returns : nothing.
001712  001873        
001713  001874        
001714  001875  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
001715  001876  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
001716  001877  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
001717  001878  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
001718  001879  //         : determined by "radius".
001719  001880  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
001720  001881  // Returns : nothing.
001721  001882        
001722  001883        
001723  001884  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
001724  001885  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
001725  001886  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
001726  001887  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
001727  001888  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
001728  001889  //         : If "radius1" is zero, the inner rectangle will have square corners.
001729  001890  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
001730  001891  // Returns : nothing.
001731  001892        
001732  001893        
001733  001894  func gfx_RoundPanel("state", "x", "y", "width", "height", "radius", "bevelwidth", "colour"), 0;
001734  001895  // Syntax  : gfx_RoundPanel(style, x, y, width, height, radius, bevelwidth, colour);
001735  001896  // Usage   : gfx_RoundPanel(PANEL_RAISED, 100, 100, 30, 20, GRAY);
001736  001897  // Notes   : Draws a rounded panel at x, y, width and height may be zero allowing the function
001737  001898  //         : to be used for rounded panels, rounded buttons, circular buttons.
001738  001899  //         :         state = 0 : sunken
001739  001900  //         :         state = 1 : raised
001740  001901  //         :         state = 2 : hide (draw object in background colour)
001741  001902  //         : Bounding rectangle is x1-radius-bevelwidth, y1-radius-bevelwidth, x2+radius+bevelwidth, y2+radius+bevelwidth.
001742  001903  // Returns : nothing.
001743  001904        
001744  001905        
001745  001906  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
001746  001907  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
001747  001908  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
001748  001909  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
001749  001910  //         : "style" specifies the drawing mode
001750  001911  //         :     GRAD_DOWN         // gradient changes in the vertical direction
001751  001912  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
001752  001913  //         :     GRAD_UP           // gradient changes in the vertical direction
001753  001914  //         :     GRAD_LEFT         // gradient change in the horizontal direction
001754  001915  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
001755  001916  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
001756  001917  // Returns : nothing.
001757  001918        
001758  001919        
001759  001920  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
001760  001921  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
001761  001922  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
001762  001923  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
001763  001924  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
001764  001925  //         : to be used for rounded panels, rounded buttons, circular buttons.
001765  001926  //         : "style" specifies the drawing mode
001766  001927  //         :     GRAD_DOWN         // gradient changes in the vertical direction
001767  001928  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
001768  001929  //         :     GRAD_UP           // gradient changes in the vertical direction
001769  001930  //         :     GRAD_LEFT         // gradient change in the horizontal direction
001770  001931  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
001771  001932  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
001772  001933  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
001773  001934  // Returns : nothing.
001774  001935        
001775  001936        
001776  001937  func gfx_ReadBresLine("x1", "y1", "x2", "y2", "ptr"), 1;
001777  001938  // Syntax  : gfx_readBrezLine(x1, y1, x2, y2, ptr);
001778  001939  // Usage   : anArrayPtr := gfx_readBrezLine(10, 10, 50, 50, 0);  // read arbitrary line to array, let the function make the array for me
001779  001940  // Notes   : reads an arbitrary line from the display to an array.
001780  001941  //         : If "ptr" is 0, the correctly sized array is created, in which case
001781  001942  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
001782  001943  //         : is expected to point to a correctly sized array.
001783  001944  //         : NB if an array is supplied, its size must be large enough, and may
001784  001945  //         : be calculated:-
001785  001946  //         : bytecount := (MAX(ABS(x2-x1), ABS(y2-y1) + 1) * 2; // calc array size for mem_Alloc (which allocates byte storage)
001786  001947  //         : wordcount := (MAX(ABS(x2-x1), ABS(y2-y1) + 1);     // calc array size for fixed word array
001787  001948  // Returns : A pointer to the created aray, or the users array.
001788  001949  //         : In the case of ptr=0, if there is insufficient
001789  001950  //         : memory to create the array, zero is returned
001790  001951        
001791  001952        
001792  001953  func gfx_WriteBresLine("x1", "y1", "x2", "y2", "ptr"), 0;
001793  001954  // Syntax  : gfx_writeBrezLine(x1, y1, x2, y2, ptr), 0;
001794  001955  // Usage   : gfx_writeBrezLine(20, 20, 50, 50, anArrayPtr);   // write an array back to the arbitrary line
001795  001956  // Notes   : cast pixel values from array to arbitrary line "x1", "y1", "x2", "y2"
001796  001957  //         : "ptr" points to the array to be written.
001797  001958  // Returns : nothing
001798  001959        
001799  001960        
001800  001961  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
001801  001962  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
001802  001963  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
001803  001964  // Notes   : reads an arbitrary rectangular area from the display to an array.
001804  001965  //         : If "ptr" is 0, the correctly sized array is created, in which case
001805  001966  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
001806  001967  //         : is expected to point to a correctly sized array.
001807  001968  //         : NB if an array is supplied, its size must be large enough, and may
001808  001969  //         : be calculated:-
001809  001970  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
001810  001971  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
001811  001972  // Returns : A pointer to the created aray, or the users array.
001812  001973  //         : In the case of ptr=0, if there is insufficient
001813  001974  //         : memory to create the array, zero is returned
001814  001975        
001815  001976        
001816  001977  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
001817  001978  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
001818  001979  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
001819  001980  // Notes   : "ptr" points to the array to be written.
001820  001981  // Returns : nothing
001821  001982        
001822  001983        
001823  001984  func gfx_Get("mode"), 1;
001824  001985  // Syntax: gfx_Get(mode);
001825  001986  // Usage : arg1 := gfx_Get(arg);
001826  001987  // Notes : Returns various parameters to caller
001827  001988  //       :
001828  001989  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001829  001990  //       : var := gfx_Get(X_MAX);
001830  001991  //       : Returns the maximum horizontal value of the display
001831  001992  //       :
001832  001993  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001833  001994  //       : var := gfx_Get(Y_MAX);
001834  001995  //       : Returns the maximum vertical value of the display
001835  001996  //       :
001836  001997  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001837  001998  //       : var := gfx_Get(LEFT_POS);
001838  001999  //       : Returns the left location of the last drawn object
001839  002000  //       : such as a slider or button or an image/video
001840  002001  //       :
001841  002002  //       : mode = TOP_POS (mode 3) : Top location of Object
001842  002003  //       : var := gfx_Get(TOP_POS);
001843  002004  //       : Returns the top location of the last drawn object
001844  002005  //       : such as a slider or button or an image/video
001845  002006  //       :
001846  002007  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001847  002008  //       : var := gfx_Get(RIGHT_POS);
001848  002009  //       : Returns the right location of the last drawn object
001849  002010  //       : such as a slider or button or an image/video
001850  002011  //       :
001851  002012  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001852  002013  //       : var := gfx_Get(BOTTOM_POS );
001853  002014  //       : Returns the bottom location of the last drawn object
001854  002015  //       : such as a slider or button or an image/video
001855  002016  //       :
001856  002017  //       : mode = X_ORG (mode 6) : get current internal X position
001857  002018  //       : var := gfx_Get(X_ORG);
001858  002019  //       : Returns the internal X position that was set with
001859  002020  //       : gfx_MoveTo(x, y); or gfx_Set(X_ORG, pos);
001860  002021  //       :
001861  002022  //       : mode = Y_ORG (mode 7) : get current internal Y position
001862  002023  //       : var := gfx_Get(Y_ORG);
001863  002024  //       : Returns the internal X position that was set with
001864  002025  //       : gfx_MoveTo(x, y); or gfx_Set(Y_ORG, pos);
001865  002026  //       :
001866  002027        
001867  002028        
001868  002029  //------------------------------------------------------------------//
001869  002030  // Single parameter short-cuts                                      //
001870  002031  // for the gfx_Set functions                                        //
001871  002032  // These functions return the existing value before                 //
001872  002033  // the change is made.                                              //
001873  002034  //------------------------------------------------------------------//
001874  002035  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001875  002036  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001876  002037  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001877  002038  func gfx_Clipping("mode"), 1;                       // 3  graphics clipping ON/OFF
001878  002039  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001879  002040  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001880  002041  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001881  002042  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001882  002043  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001883  002044  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001884  002045  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001885  002046  func gfx_BevelRadius("radius"), 1;                  // 11 graphics button bevel radius
001886  002047  func gfx_BevelWidth("value"), 1;                    // 12 graphics button bevel width
001887  002048  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001888  002049  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001889  002050  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001890  002051        
001891  002052        
001892  002053  func gfx_PointWithinBox("x", "y", "&rectr"), 1;
001893  002054  // Syntax   : gfx_PointWithinBox(x, y, rect);
001894  002055  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=20; r[3]:=30;
001895  002056  //          : result := gfx_PointWithinBox(x, y, r); // check area at 100,200,119,229
001896  002057  // Notes    : rect is an array of 4 vars, x1, y1, width, height - using width co-ordinates
001897  002058  // returns  : Returns true if last touch co-ordinates are within the box test area.
001898  002059        
001899  002060        
001900  002061  func gfx_PointWithinRectangle("x", "y", "&recta"), 1;
001901  002062  // Syntax   : gfx_PointWithinRectangle(x, y, recta);
001902  002063  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=119; r[3]:=129;
001903  002064  //          : result := gfx_PointWithinRectangle(x, y, r); // check if point within area at 100,200,119,229
001904  002065  // Notes    : rect is an array of 4 vars, x1, y1, x2, y2 using absolute co-ordinates
001905  002066  // returns  : Returns true if x:y co-ordinates are within the rectangle test area.
001906  002067        
001907  002068        
001908  002069  func __reserved17(), 0; // do not remove
001909  002070  func __reserved18(), 0; // do not remove
001910  002071  func __reserved19(), 0; // do not remove
001911  002072  func __reserved20(), 0; // do not remove
001912  002073  func __reserved21(), 0; // do not remove
001913  002074  func __reserved22(), 0; // do not remove
001914  002075        
001915  002076        
001916  002077  // built in fill pattern constants for function gfx_FillPattern
001917  002078  #CONST
001918  002111  #END
001919  002112        
001920  002113  #CONST
001921  002146  #END
001922  002147        
001923  002148  //------------------------------------------------------------------//
001924  002149  //     gradient control constants                                   //
001925  002150  //------------------------------------------------------------------//
001926  002151  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
001927  002151  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
001928  002152  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
001929  002152  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
001930  002153  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
001931  002153  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
001932  002154  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
001933  002154  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
001934  002155  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
001935  002155  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
001936  002156  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
001937  002156  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
001938  002157        
001939  002158        
001940  002159        
001941  002160        
001942  002161  //------------------------------------------------------------------//
001943  002162  // uSD/FLASH Function Prototypes                                    //
001944  002163  //------------------------------------------------------------------//
001945  002164  func media_Video("x", "y"), 0;                      // display movie at position x y
001946  002165  // Syntax: media_Video(x, y);
001947  002166  // Usage : media_Video(arg1, arg2);
001948  002167  // Notes : Play a Video/Animation clip from the uSD card at screen location
001949  002168  //       : specified by x,y (top left corner). The location of the clip in the
001950  002169  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001951  002170        
001952  002171  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001953  002172  // Syntax: media_VideoFrame(Frame_number);
001954  002173  // Usage : arg1 := media_VideoFrame();
001955  002174  // Notes : After a pointer to a valid video has been set with media_SetSector,
001956  002175  //       : calling this function shows each fram sequentially, returning
001957  002176  //       : the number of frames remaining. The position of the image is
001958  002177  //     : at the current origin as set with gfx_MoveTo(...);
001959  002178        
001960  002179  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001961  002180  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001962  002181  // Usage : media_SetAdd(arg1, arg2);
001963  002182  // Notes : Set uSD internal Address pointer for bytewise access
001964  002183        
001965  002184  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001966  002185  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001967  002186  // Usage : media_SetSector(arg1, arg2);
001968  002187  // Notes : Set uSD internal Sector pointer for sector block access
001969  002188        
001970  002189  func media_RdSector("*destination"), 1;
001971  002190  // Syntax: media_RdSector(*destination);
001972  002191  // Usage : media_RdSector(rdblock);
001973  002192  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001974  002193  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001975  002194  //       : After the read the Sector pointer is automatically incremented by 1.
001976  002195  //       : Returns TRUE if uSD response was TRUE
001977  002196        
001978  002197  func media_WrSector("*source"), 1;
001979  002198  // Syntax: media_WrSector(*source);
001980  002199  // Usage : media_WrSector(wrblock);
001981  002200  // Notes : Writes 512 bytes (256 words) from a source memory block
001982  002201  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001983  002202  //       : pointer is automatically incremented by 1.
001984  002203  //       : Returns TRUE if uSD response was TRUE
001985  002204        
001986  002205  func media_ReadByte(), 1;                // read a byte at the current stream position
001987  002206  // Syntax: media_RdByte();
001988  002207  // Usage : var := media_RdByte();
001989  002208  // Notes : Reads and Returns a single byte of data from the
001990  002209  //       : uSD card pointed to by the internal Address pointer.
001991  002210  //       : After the read the Address pointer is automatically
001992  002211  //       : incremented by 1.
001993  002212        
001994  002213  func media_ReadWord(), 1;                // read a word at the current stream position
001995  002214  // Syntax: media_ReadWord();
001996  002215  // Usage : var := media_ReadWord();
001997  002216  // *Notes : Reads and Returns a single word of data from the
001998  002217  //       : uSD card pointed to by the internal Address pointer.
001999  002218  //       : After the read the Address pointer is automatically
002000  002219  //       : incremented by 2.
002001  002220        
002002  002221  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
002003  002222  // Syntax: media_WriteByte(arg1);
002004  002223  // Usage : var := media_WriteByte(arg1);
002005  002224  // *Notes : Writes and Returns xxxxx
002006  002225  //       : After the write the Address pointer is automatically
002007  002226  //       : incremented by 1.
002008  002227        
002009  002228  func media_WriteWord("word"), 1;            // write a word to the current stream position
002010  002229  // Syntax: media_WriteWord(arg1);
002011  002230  // Usage : var := media_WriteWord(arg1);
002012  002231  // *Notes : Writes and Returns xxxxx
002013  002232  //       : After the write the Address pointer is automatically
002014  002233  //       : incremented by 2.
002015  002234        
002016  002235  func media_Image("x", "y"), 0;            // display image at position x y
002017  002236  // Syntax: media_Image(x, y);
002018  002237  // Usage : media_Image(arg1, arg2);
002019  002238  // Notes : Display an image from the uSD card at screen location
002020  002239  //       : specified by x,y (top left corner). The location of the
002021  002240  //       : Image in the uSD card must be specified by
002022  002241  //       : media_setSector(Image_Sector_Add) function.
002023  002242        
002024  002243  func media_Flush(), 1;                    // after writing to media, flush the sector and write
002025  002244  // Syntax: media_Flush();
002026  002245  // Usage : var := media_Flush();
002027  002246  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
002028  002247  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
002029  002248        
002030  002249  func media_Init(), 1;                    // initialize uSD card
002031  002250  // Usage : media_Init();
002032  002251  // Notes : Initialise uSD CARD
002033  002252  //       : Response: 0 = No Card
002034  002253  //       :           1 = Card Initialised
002035  002254        
002036  002255  func __reserved23(), 0; // do not remove
002037  002256  func __reserved24(), 0; // do not remove
002038  002257  func __reserved25(), 0; // do not remove
002039  002258  func __reserved26(), 0; // do not remove
002040  002259        
002041  002260  //==============================================//
002042  002261  // Communications Function Prototypes           //
002043  002262  // NB Primary COM port has fixed pins,          //
002044  002263  // COM1, COM2 and COM3 must have pins assigned. //
002045  002264  //==============================================//
002046  002265  func setbaud("baudnum"), 0;            // set baud rate of COM0
002047  002266  // Syntax: setbaud(baud_number);
002048  002267  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
002049  002268  // *Notes : argument specifies the baud rate using pre-defined constant.
002050  002269  //       : The pre-defined constant is a value of 0-19 , and internally
002051  002270  //       : this is used as a table pointer to get the baud rate divisor
002052  002271  //       : value for one of the 20 selected baud rates, control is then
002053  002272  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
002054  002273  //       : The pre-defined constants equate to a value of 0-19.
002055  002274  //       : If a value other than 0-19 is used, a run time error (eror 25)
002056  002275  //       : will occur.
002057  002276        
002058  002277  // baud divisor rates for legacy setbaud(n);
002059  002278  #CONST
002060  002300  #END
002061  002301        
002062  002302        
002063  002303  func com_SetBaud("comport","baudrate/10"), 1;
002064  002304  // Syntax: com_SetBaud("comport","baudrate/10");
002065  002305  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
002066  002306  // Notes : sets to any viable baud rate from 160 to 655350
002067  002307  // return true if baud rate was acceptable
002068  002308        
002069  002309        
002070  002310  func COM1_RX_pin("pin"), 1;        // select the hardware pin for the COM1 receive line
002071  002311  // Usage : COM1_RX_pin(PA0); // set COM1 RX to PA0 pin
002072  002312  // Notes : Selects the hardware pin for COM1 receive line.
002073  002313  //       : Note that only a single pin can be mapped to COM1 RX.
002074  002314  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002075  002315  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002076  002316  //       : If the pin argument is 0 the function has no effect
002077  002317  //       : The pin is automatically set to an input.
002078  002318  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002079  002319  //       : it is necessary to configure the input pin first, eg
002080  002320  //       :     COM1_RX_pin(PA7);     // configure COM1 RX to PA7 (this disconnects anything else)
002081  002321  //       :     COM1_TX_pin(PA7));    // configure COM1 TX to PA7
002082  002322  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002083  002323        
002084  002324  func COM2_RX_pin("pin"), 1;        // select the hardware pin for the COM2 receive line
002085  002325  // Usage : COM2_RX_pin(PA0); // set COM2 RX to PA0 pin
002086  002326  // Notes : Selects the hardware pin for COM2 receive line.
002087  002327  //       : Note that only a single pin can be mapped to COM2 RX.
002088  002328  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002089  002329  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002090  002330  //       : If the pin argument is 0 the function has no effect
002091  002331  //       : The pin is automatically set to an input.
002092  002332  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002093  002333  //       : it is necessary to configure the input pin first, eg
002094  002334  //       :     COM2_RX_pin(PA7);     // configure COM2 RX to PA7 (this disconnects anything else)
002095  002335  //       :     COM2_TX_pin(PA7));    // configure COM2 TX to PA7
002096  002336  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002097  002337        
002098  002338  func COM3_RX_pin("pin"), 1;        // select the hardware pin for the COM3 receive line
002099  002339  // Usage : COM3_RX_pin(PA0); // set COM3 RX to PA0 pin
002100  002340  // Notes : Selects the hardware pin for COM3 receive line.
002101  002341  //       : Note that only a single pin can be mapped to COM3 RX.
002102  002342  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002103  002343  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002104  002344  //       : If the pin argument is 0 the function has no effect
002105  002345  //       : The pin is automatically set to an input.
002106  002346  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002107  002347  //       : it is necessary to configure the input pin first, eg
002108  002348  //       :     COM3_RX_pin(PA7);     // configure COM3 RX to PA7 (this disconnects anything else)
002109  002349  //       :     COM3_TX_pin(PA7));    // configure COM3 TX to PA7
002110  002350  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002111  002351        
002112  002352        
002113  002353  func COM1_TX_pin("pin"), 1;        // select the hardware pin for COM1 transmit line
002114  002354  // Syntax: COM1_TX_pin(pin);
002115  002355  // Usage : COM1_TX_pin(PA2); // set COM1 TX to PA2 pin
002116  002356  // Notes : Select the hardware pin for COMx transmit line.
002117  002357  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002118  002358  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002119  002359  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002120  002360  //       : The pin is automatically set to an output.
002121  002361  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002122  002362        
002123  002363  func COM2_TX_pin("pin"), 1;        // select the hardware pin for COM2 transmit line
002124  002364  // Syntax: COM2_TX_pin(pin);
002125  002365  // Usage : COM2_TX_pin(PA2); // set COM2 TX to PA2 pin
002126  002366  // Notes : Select the hardware pin for COMx transmit line.
002127  002367  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002128  002368  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002129  002369  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002130  002370  //       : The pin is automatically set to an output.
002131  002371  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002132  002372        
002133  002373  func COM3_TX_pin("pin"), 1;        // select the hardware pin for COM3 transmit line
002134  002374  // Syntax: COM3_TX_pin(pin);
002135  002375  // Usage : COM3_TX_pin(PA2); // set COM3 TX to PA2 pin
002136  002376  // Notes : Select the hardware pin for COMx transmit line.
002137  002377  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002138  002378  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002139  002379  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002140  002380  //       : The pin is automatically set to an output.
002141  002381  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002142  002382        
002143  002383  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
002144  002384  // Syntax: com_Init(buffer, bufsize, qualifier);
002145  002385  // Usage1: com_Init(mybuf, 20, 0);
002146  002386  // Usage2: com_Init(mybuf, 20, ':');
002147  002387  // Notes : initialize a serial capture buffer for the comms input
002148  002388  //       : The program must declare a var array as a circular buffer.
002149  002389  //       : Usage1 declares a circular buffer which will continually
002150  002390  //       : buffer characters.
002151  002391  //       : Usage2 must receive ':' before any characters will
002152  002392  //       : accumulate in the buffer.
002153  002393        
002154  002394  func com1_Init("buf","bufsize","qualifier"), 0;
002155  002395  // Syntax: com1_Init(buffer, bufsize, qualifier);
002156  002396  // Usage1: com1_Init(mybuf, 20, 0);
002157  002397  // Usage2: com1_Init(mybuf, 20, ':');
002158  002398  // Notes : initialize a serial capture buffer for the comms input
002159  002399  //       : The program must declare a var array as a circular buffer.
002160  002400  //       : Usage1 declares a circular buffer which will continually
002161  002401  //       : buffer characters.
002162  002402  //       : Usage2 must receive ':' before any characters will
002163  002403  //       : accumulate in the buffer.
002164  002404        
002165  002405  func com2_Init("buf","bufsize","qualifier"), 0;
002166  002406  // Syntax: com2_Init(buffer, bufsize, qualifier);
002167  002407  // Usage1: com2_Init(mybuf, 20, 0);
002168  002408  // Usage2: com2_Init(mybuf, 20, ':');
002169  002409  // Notes : initialize a serial capture buffer for the comms input
002170  002410  //       : The program must declare a var array as a circular buffer.
002171  002411  //       : Usage1 declares a circular buffer which will continually
002172  002412  //       : buffer characters.
002173  002413  //       : Usage2 must receive ':' before any characters will
002174  002414  //       : accumulate in the buffer.
002175  002415        
002176  002416  func com3_Init("buf","bufsize","qualifier"), 0;
002177  002417  // Syntax: com3_Init(buffer, bufsize, qualifier);
002178  002418  // Usage1: com3_Init(mybuf, 20, 0);
002179  002419  // Usage2: com3_Init(mybuf, 20, ':');
002180  002420  // Notes : initialize a serial capture buffer for the comms input
002181  002421  //       : The program must declare a var array as a circular buffer.
002182  002422  //       : Usage1 declares a circular buffer which will continually
002183  002423  //       : buffer characters.
002184  002424  //       : Usage2 must receive ':' before any characters will
002185  002425  //       : accumulate in the buffer.
002186  002426        
002187  002427        
002188  002428  func serin(), 1;                // read a byte from primary com port COM0
002189  002429  // Syntax: serin();
002190  002430  // Usage : char := serin();
002191  002431  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
002192  002432  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002193  002433  //     : The default Baud Rate for COM0 is 115,200 bits per second or 115,200 baud.
002194  002434  //     : The baud rate can be changed under program control by using the setbaud(...)
002195  002435  //     : or the com_SetBaud(...) function.
002196  002436  //     : COM0 pins cannot be mapped, and are fixed as pins 42 and 33 (host adaptor / programming)
002197  002437  //     : serin may be buffered (refer to com_Init function above)
002198  002438  //     : Returns: -1 if no character is available
002199  002439  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002200  002440  //     : Returns: positive value 0 to 255 for a valid character received
002201  002441        
002202  002442  func serin1(), 1;
002203  002443  // Syntax: serinx();
002204  002444  // Usage : char := serinx();
002205  002445  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002206  002446  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002207  002447  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002208  002448  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002209  002449  //     : serinx may be buffered (refer to comx_Init function above)
002210  002450  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002211  002451  //     : Returns: -1 if no character is available
002212  002452  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002213  002453  //     : Returns: positive value 0 to 255 for a valid character received
002214  002454        
002215  002455  func serin2(), 1;
002216  002456  // Syntax: serinx();
002217  002457  // Usage : char := serinx();
002218  002458  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002219  002459  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002220  002460  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002221  002461  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002222  002462  //     : serinx may be buffered (refer to comx_Init function above)
002223  002463  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002224  002464  //     : Returns: -1 if no character is available
002225  002465  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002226  002466  //     : Returns: positive value 0 to 255 for a valid character received
002227  002467        
002228  002468  func serin3(), 1;
002229  002469  // Syntax: serinx();
002230  002470  // Usage : char := serinx();
002231  002471  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002232  002472  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002233  002473  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002234  002474  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002235  002475  //     : serinx may be buffered (refer to comx_Init function above)
002236  002476  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002237  002477  //     : Returns: -1 if no character is available
002238  002478  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002239  002479  //     : Returns: positive value 0 to 255 for a valid character received
002240  002480        
002241  002481  func serout("char"), 0;                // write a byte to COM0
002242  002482  // Syntax: serout1("char");
002243  002483  // Usage : serout1(ch);
002244  002484  // Notes : send character to COM0
002245  002485        
002246  002486  func serout1("char"), 0;
002247  002487  // Syntax: seroutx("char");
002248  002488  // Usage : serout1(ch);
002249  002489  // Notes : send character to COMx
002250  002490        
002251  002491  func serout2("char"), 0;
002252  002492  // Syntax: seroutx("char");
002253  002493  // Usage : serout1(ch);
002254  002494  // Notes : send character to COMx
002255  002495        
002256  002496  func serout3("char"), 0;
002257  002497  // Syntax: seroutx("char");
002258  002498  // Usage : serout1(ch);
002259  002499  // Notes : send character to COMx
002260  002500        
002261  002501  func com_Reset(), 0;                 // reset the comms receiver
002262  002502  // Syntax: com_Reset();
002263  002503  // Usage : com_Reset();
002264  002504  // Notes : reset comms to default polled mode
002265  002505        
002266  002506  func com1_Reset(), 0;
002267  002507  // Syntax: com_Reset();
002268  002508  // Usage : com_Reset();
002269  002509  // Notes : reset comms to default polled mode
002270  002510        
002271  002511  func com2_Reset(), 0;
002272  002512  // Syntax: com_Reset();
002273  002513  // Usage : com_Reset();
002274  002514  // Notes : reset comms to default polled mode
002275  002515        
002276  002516  func com3_Reset(), 0;
002277  002517  // Syntax: com_Reset();
002278  002518  // Usage : com_Reset();
002279  002519  // Notes : reset comms to default polled mode
002280  002520        
002281  002521  func com_Count(), 1;                // return count of characters in receive buffer
002282  002522  // Syntax: com_Count();
002283  002523  // Usage : arg := com_Count();
002284  002524  // Notes : return count of buffered characters in buffer attachment
002285  002525        
002286  002526  func com1_Count(), 1;
002287  002527  // Syntax: com_Count();
002288  002528  // Usage : arg := com_Count();
002289  002529  // Notes : return count of buffered characters in buffer attachment
002290  002530        
002291  002531  func com2_Count(), 1;
002292  002532  // Syntax: com_Count();
002293  002533  // Usage : arg := com_Count();
002294  002534  // Notes : return count of buffered characters in buffer attachment
002295  002535        
002296  002536  func com3_Count(), 1;
002297  002537  // Syntax: com_Count();
002298  002538  // Usage : arg := com_Count();
002299  002539  // Notes : return count of buffered characters in buffer attachment
002300  002540        
002301  002541  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
002302  002542  // Syntax: com_Full();
002303  002543  // Usage : if (com_Full() ,,,, go read buffer;
002304  002544  // Notes : return true if buffer full (not necessarily an error if
002305  002545  //       : buffer is sized to a packet size)
002306  002546        
002307  002547  func com1_Full(), 1;
002308  002548  // Syntax: com_Full();
002309  002549  // Usage : if (com_Full() ,,,, go read buffer;
002310  002550  // Notes : return true if buffer full (not necessarily an error if
002311  002551  //       : buffer is sized to a packet size)
002312  002552        
002313  002553  func com2_Full(), 1;
002314  002554  // Syntax: com_Full();
002315  002555  // Usage : if (com_Full() ,,,, go read buffer;
002316  002556  // Notes : return true if buffer full (not necessarily an error if
002317  002557  //       : buffer is sized to a packet size)
002318  002558        
002319  002559  func com3_Full(), 1;
002320  002560  // Syntax: com_Full();
002321  002561  // Usage : if (com_Full() ,,,, go read buffer;
002322  002562  // Notes : return true if buffer full (not necessarily an error if
002323  002563  //       : buffer is sized to a packet size)
002324  002564        
002325  002565  func com_Error(), 1;                // return comms errors comms error occurred
002326  002566  // Syntax: comx_Error();
002327  002567  // Usage : if (com_Error() ) ...... take recovery action;
002328  002568  // Notes : return non zero if any errors low level comms errors occured
002329  002569  // returns :
002330  002570  // bit0 = Receiver Overflow Error
002331  002571  // bit1 = Receiver Framing Error
002332  002572  // bit2 = Transmit Buffer Overflow
002333  002573        
002334  002574  func com1_Error(), 1;
002335  002575  // Syntax: comx_Error();
002336  002576  // Usage : if (com_Error() ) ...... take recovery action;
002337  002577  // Notes : return non zero if any errors low level comms errors occured
002338  002578  // returns :
002339  002579  // bit0 = Receiver Overflow Error
002340  002580  // bit1 = Receiver Framing Error
002341  002581  // bit2 = Transmit Buffer Overflow
002342  002582        
002343  002583  func com2_Error(), 1;
002344  002584  // Syntax: comx_Error();
002345  002585  // Usage : if (com_Error() ) ...... take recovery action;
002346  002586  // Notes : return non zero if any errors low level comms errors occured
002347  002587  // returns :
002348  002588  // bit0 = Receiver Overflow Error
002349  002589  // bit1 = Receiver Framing Error
002350  002590  // bit2 = Transmit Buffer Overflow
002351  002591        
002352  002592  func com3_Error(), 1;
002353  002593  // Syntax: comx_Error();
002354  002594  // Usage : if (com_Error() ) ...... take recovery action;
002355  002595  // Notes : return non zero if any errors low level comms errors occured
002356  002596  // returns :
002357  002597  // bit0 = Receiver Overflow Error
002358  002598  // bit1 = Receiver Framing Error
002359  002599  // bit2 = Transmit Buffer Overflow
002360  002600        
002361  002601  func com_Sync(), 1;                // returns TRUE if qualifier has been received
002362  002602  // Usage : comx_Sync();
002363  002603  // return true if sync character has been received in com_Init("...") mode
002364  002604        
002365  002605  func com1_Sync(), 1;
002366  002606  // Usage : comx_Sync();
002367  002607  // return true if sync character has been received in com_Init("...") mode
002368  002608        
002369  002609  func com2_Sync(), 1;
002370  002610  // Usage : comx_Sync();
002371  002611  // return true if sync character has been received in com_Init("...") mode
002372  002612        
002373  002613  func com3_Sync(), 1;
002374  002614  // Usage : comx_Sync();
002375  002615  // return true if sync character has been received in com_Init("...") mode
002376  002616        
002377  002617        
002378  002618  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
002379  002619  // Usage : com_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002380  002620  // Usage : com_TXbuffer(0, 0, 0);             // revert to non buffered service
002381  002621  // Notes : initialize a serial buffer for the COM0 output.
002382  002622  //       : The program must declare a var array as a circular buffer.
002383  002623  //       : When a TX buffer is declared for comms, the transmission
002384  002624  //       : of characters becomes non blocking. If the buffer has
002385  002625  //       : insufficient space to accept the next character from a
002386  002626  //       : serout_x() function, the excess characters will be ignored,
002387  002627  //       : and the com_Full_x() error will be asserted.   If the
002388  002628  //       : TX buffer is no longer required, just set the buffer pointer
002389  002629  //       : to zero, the size in this case doesnt matter and is ignored.
002390  002630  //       : The function can resize or reallocated to another buffer at
002391  002631  //       : any time. The buffer is flushed before any changes are made.
002392  002632  //       : "pin" designates an IO pin to control a bi-directional
002393  002633  //       : control device for half duplex mode. "pin" will go HI at the
002394  002634  //       : start of a transmission, and will return low after the final
002395  002635  //       : byte is transmitted. If not required, just set "pin" to zero.
002396  002636        
002397  002637  func com1_TXbuffer("buf", "bufsize", "pin"), 0;
002398  002638  // Usage : com1_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002399  002639  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
002400  002640  // Notes : initialize a serial buffer for the COM0 output.
002401  002641  //       : The program must declare a var array as a circular buffer.
002402  002642  //       : When a TX buffer is declared for comms, the transmission
002403  002643  //       : of characters becomes non blocking. If the buffer has
002404  002644  //       : insufficient space to accept the next character from a
002405  002645  //       : serout_x() function, the excess characters will be ignored,
002406  002646  //       : and the com_Full_x() error will be asserted.   If the
002407  002647  //       : TX buffer is no longer required, just set the buffer pointer
002408  002648  //       : to zero, the size in this case doesnt matter and is ignored.
002409  002649  //       : The function can resize or reallocated to another buffer at
002410  002650  //       : any time. The buffer is flushed before any changes are made.
002411  002651  //       : "pin" designates an IO pin to control a bi-directional
002412  002652  //       : control device for half duplex mode. "pin" will go HI at the
002413  002653  //       : start of a transmission, and will return low after the final
002414  002654  //       : byte is transmitted. If not required, just set "pin" to zero.
002415  002655        
002416  002656  func com2_TXbuffer("buf", "bufsize", "pin"), 0;
002417  002657  // Usage : com2_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002418  002658  // Usage : com2_TXbuffer(0, 0, 0);              // revert to non buffered service
002419  002659  // Notes : initialize a serial buffer for the COM0 output.
002420  002660  //       : The program must declare a var array as a circular buffer.
002421  002661  //       : When a TX buffer is declared for comms, the transmission
002422  002662  //       : of characters becomes non blocking. If the buffer has
002423  002663  //       : insufficient space to accept the next character from a
002424  002664  //       : serout_x() function, the excess characters will be ignored,
002425  002665  //       : and the com_Full_x() error will be asserted.   If the
002426  002666  //       : TX buffer is no longer required, just set the buffer pointer
002427  002667  //       : to zero, the size in this case doesnt matter and is ignored.
002428  002668  //       : The function can resize or reallocated to another buffer at
002429  002669  //       : any time. The buffer is flushed before any changes are made.
002430  002670  //       : "pin" designates an IO pin to control a bi-directional
002431  002671  //       : control device for half duplex mode. "pin" will go HI at the
002432  002672  //       : start of a transmission, and will return low after the final
002433  002673  //       : byte is transmitted. If not required, just set "pin" to zero.
002434  002674        
002435  002675  func com3_TXbuffer("buf", "bufsize", "pin"), 0;
002436  002676  // Usage : com3_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002437  002677  // Usage : com3_TXbuffer(0, 0, 0);              // revert to non buffered service
002438  002678  // Notes : initialize a serial buffer for the COM0 output.
002439  002679  //       : The program must declare a var array as a circular buffer.
002440  002680  //       : When a TX buffer is declared for comms, the transmission
002441  002681  //       : of characters becomes non blocking. If the buffer has
002442  002682  //       : insufficient space to accept the next character from a
002443  002683  //       : serout_x() function, the excess characters will be ignored,
002444  002684  //       : and the com_Full_x() error will be asserted.   If the
002445  002685  //       : TX buffer is no longer required, just set the buffer pointer
002446  002686  //       : to zero, the size in this case doesnt matter and is ignored.
002447  002687  //       : The function can resize or reallocated to another buffer at
002448  002688  //       : any time. The buffer is flushed before any changes are made.
002449  002689  //       : "pin" designates an IO pin to control a bi-directional
002450  002690  //       : control device for half duplex mode. "pin" will go HI at the
002451  002691  //       : start of a transmission, and will return low after the final
002452  002692  //       : byte is transmitted. If not required, just set "pin" to zero.
002453  002693        
002454  002694        
002455  002695  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
002456  002696  // Syntax: com_TXcount();
002457  002697  // Usage : arg := com_Count();
002458  002698  // Notes : return count of characters remaining in COM0 transmit buffer
002459  002699  //       : that was previously allocated with com_TXbuffer(...);
002460  002700        
002461  002701  func com1_TXcount(), 1;
002462  002702  // Syntax: com_TXcount();
002463  002703  // Usage : arg := com_Count();
002464  002704  // Notes : return count of characters remaining in COM0 transmit buffer
002465  002705  //       : that was previously allocated with com_TXbuffer(...);
002466  002706        
002467  002707  func com2_TXcount(), 1;
002468  002708  // Syntax: com_TXcount();
002469  002709  // Usage : arg := com_Count();
002470  002710  // Notes : return count of characters remaining in COM0 transmit buffer
002471  002711  //       : that was previously allocated with com_TXbuffer(...);
002472  002712        
002473  002713  func com3_TXcount(), 1;
002474  002714  // Syntax: com_TXcount();
002475  002715  // Usage : arg := com_Count();
002476  002716  // Notes : return count of characters remaining in COM0 transmit buffer
002477  002717  //       : that was previously allocated with com_TXbuffer(...);
002478  002718        
002479  002719  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
002480  002720  // Usage : arg := com_TXemptyEvent();
002481  002721  // Notes : If a comms TX buffer that was previously allocated with
002482  002722  //       : com_TXbuffer(...);, this function can be used to set up
002483  002723  //       : a function to be called when the COM0 TX buffer is empty.
002484  002724  //       : This is useful for either reloading the TX buffer, setting
002485  002725  //       : or clearing a pin to change the direction of eg a RS485
002486  002726  //       : line driver, or any other form of traffic control.
002487  002727  //       : The event function must not have any parameters.
002488  002728  //       : To disable the event, simply call com_TXemptyEvent(0).
002489  002729  //       : com_TXbuffer(...); also resets any active event.
002490  002730  //       : com_TXemptyEvent returns any previous event function
002491  002731  //       : address, or zero if there was no previous function.
002492  002732        
002493  002733  func com1_TXemptyEvent("function"), 1;
002494  002734  // Usage : arg := com1_TXemptyEvent();
002495  002735  // Notes : If a comms TX buffer that was previously allocated with
002496  002736  //       : com_TXbuffer(...);, this function can be used to set up
002497  002737  //       : a function to be called when the COM0 TX buffer is empty.
002498  002738  //       : This is useful for either reloading the TX buffer, setting
002499  002739  //       : or clearing a pin to change the direction of eg a RS485
002500  002740  //       : line driver, or any other form of traffic control.
002501  002741  //       : The event function must not have any parameters.
002502  002742  //       : To disable the event, simply call com_TXemptyEvent(0).
002503  002743  //       : com_TXbuffer(...); also resets any active event.
002504  002744  //       : com_TXemptyEvent returns any previous event function
002505  002745  //       : address, or zero if there was no previous function.
002506  002746        
002507  002747  func com2_TXemptyEvent("function"), 1;
002508  002748  // Usage : arg := com2_TXemptyEvent();
002509  002749  // Notes : If a comms TX buffer that was previously allocated with
002510  002750  //       : com_TXbuffer(...);, this function can be used to set up
002511  002751  //       : a function to be called when the COM0 TX buffer is empty.
002512  002752  //       : This is useful for either reloading the TX buffer, setting
002513  002753  //       : or clearing a pin to change the direction of eg a RS485
002514  002754  //       : line driver, or any other form of traffic control.
002515  002755  //       : The event function must not have any parameters.
002516  002756  //       : To disable the event, simply call com_TXemptyEvent(0).
002517  002757  //       : com_TXbuffer(...); also resets any active event.
002518  002758  //       : com_TXemptyEvent returns any previous event function
002519  002759  //       : address, or zero if there was no previous function.
002520  002760        
002521  002761  func com3_TXemptyEvent("function"), 1;
002522  002762  // Usage : arg := com3_TXemptyEvent();
002523  002763  // Notes : If a comms TX buffer that was previously allocated with
002524  002764  //       : com_TXbuffer(...);, this function can be used to set up
002525  002765  //       : a function to be called when the COM0 TX buffer is empty.
002526  002766  //       : This is useful for either reloading the TX buffer, setting
002527  002767  //       : or clearing a pin to change the direction of eg a RS485
002528  002768  //       : line driver, or any other form of traffic control.
002529  002769  //       : The event function must not have any parameters.
002530  002770  //       : To disable the event, simply call com_TXemptyEvent(0).
002531  002771  //       : com_TXbuffer(...); also resets any active event.
002532  002772  //       : com_TXemptyEvent returns any previous event function
002533  002773  //       : address, or zero if there was no previous function.
002534  002774        
002535  002775  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
002536  002776  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
002537  002777  // Notes : Expecting that a comms TX buffer that was previously allocated with
002538  002778  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002539  002779  //       : the buffer being sent wile it is being loaded. Mormally, when
002540  002780  //       : using buffered comms, the transmit process will begin
002541  002781  //       : immediately. This is often undesirable for 2 reasons,
002542  002782  //       : 1] you may wish to build a packet then send it later
002543  002783  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002544  002784  //       : as the FIFO buffer is constantly trying to empty while
002545  002785  //       : you are busy tring to fill it.
002546  002786  // return -1 if function is called illegally when TX comms is not buffered.
002547  002787  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002548  002788  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002549  002789        
002550  002790  func com1_TXbufferHold("state"), 1;
002551  002791  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
002552  002792  // Notes : Expecting that a comms TX buffer that was previously allocated with
002553  002793  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002554  002794  //       : the buffer being sent wile it is being loaded. Mormally, when
002555  002795  //       : using buffered comms, the transmit process will begin
002556  002796  //       : immediately. This is often undesirable for 2 reasons,
002557  002797  //       : 1] you may wish to build a packet then send it later
002558  002798  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002559  002799  //       : as the FIFO buffer is constantly trying to empty while
002560  002800  //       : you are busy tring to fill it.
002561  002801  // return -1 if function is called illegally when TX comms is not buffered.
002562  002802  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002563  002803  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002564  002804        
002565  002805  func com2_TXbufferHold("state"), 1;
002566  002806  // Usage : arg := com2_TXbufferHold(OFF);  // start sending the buffer
002567  002807  // Notes : Expecting that a comms TX buffer that was previously allocated with
002568  002808  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002569  002809  //       : the buffer being sent wile it is being loaded. Mormally, when
002570  002810  //       : using buffered comms, the transmit process will begin
002571  002811  //       : immediately. This is often undesirable for 2 reasons,
002572  002812  //       : 1] you may wish to build a packet then send it later
002573  002813  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002574  002814  //       : as the FIFO buffer is constantly trying to empty while
002575  002815  //       : you are busy tring to fill it.
002576  002816  // return -1 if function is called illegally when TX comms is not buffered.
002577  002817  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002578  002818  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002579  002819        
002580  002820  func com3_TXbufferHold("state"), 1;
002581  002821  // Usage : arg := com3_TXbufferHold(OFF);  // start sending the buffer
002582  002822  // Notes : Expecting that a comms TX buffer that was previously allocated with
002583  002823  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002584  002824  //       : the buffer being sent wile it is being loaded. Mormally, when
002585  002825  //       : using buffered comms, the transmit process will begin
002586  002826  //       : immediately. This is often undesirable for 2 reasons,
002587  002827  //       : 1] you may wish to build a packet then send it later
002588  002828  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002589  002829  //       : as the FIFO buffer is constantly trying to empty while
002590  002830  //       : you are busy tring to fill it.
002591  002831  // return -1 if function is called illegally when TX comms is not buffered.
002592  002832  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002593  002833  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002594  002834        
002595  002835  func com_Mode("8" ,"N", "1", "comport"), 1 ;
002596  002836  // Syntax   : comx_Mode("databits", "parity", "Stopbits", "comport");
002597  002837  // Usage    : comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
002598  002838  // *Notes   : Data Bits must be 8
002599  002839  //          : Parity may be 'N', 'O' or 'E'.
002600  002840  //          : Stop Bits may be 1 or 2.
002601  002841  // returns true if mode was acceptable
002602  002842        
002603  002843  func com_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
002604  002844  // Syntax   : com_TXblock("buf", "bufsize");
002605  002845  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
002606  002846  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
002607  002847  //          : if a transmit buffer is active and space is available this function will return almost
002608  002848  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
002609  002849        
002610  002850  func com_RXblock("buf", "bufsize"), 0;                       // commence a block reception
002611  002851  // Syntax   : com_RXblock("buf", "bufsize");
002612  002852  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
002613  002853  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
002614  002854  //          : if a receive buffer is active and bufsize characters are available this function will return almost
002615  002855  //          : immediately otherwise it will block until until the required bytes are received.
002616  002856        
002617  002857  func __reserved30(), 0; // do not remove
002618  002858        
002619  002859  //------------------------------------------------------------------//
002620  002860  //        Function Prototypes for I2C
002621  002861  //------------------------------------------------------------------//
002622  002862  func I2C1_Open("speed", "SCLpin", "SDApin"), 1;
002623  002863  // Syntax : I2C1_Openx(speed, SCLpin, SDApin),
002624  002864  // Usage  : I2C1_Open(I2C_MED, PA2, PA3);
002625  002865  // Notes  : configures the required I2C module
002626  002866  //        : see 'I2C timing related constants' and 'pin constants'
002627  002867  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002628  002868  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002629  002869  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002630  002870  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002631  002871  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002632  002872  // Returns: True if successful
002633  002873        
002634  002874        
002635  002875  func I2C2_Open("speed", "SCLpin", "SDApin"), 1;
002636  002876  // Syntax : I2C2_Openx(speed, SCLpin, SDApin),
002637  002877  // Usage  : I2C2_Open(I2C_MED, PA2, PA3);
002638  002878  // Notes  : configures the required I2C module
002639  002879  //        : see 'I2C timing related constants' and 'pin constants'
002640  002880  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002641  002881  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002642  002882  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002643  002883  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002644  002884  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002645  002885  // Returns: True if successful
002646  002886        
002647  002887        
002648  002888  func I2C3_Open("speed", "SCLpin", "SDApin"), 1;
002649  002889  // Syntax : I2C3_Openx(speed, SCLpin, SDApin),
002650  002890  // Usage  : I2C3_Open(I2C_MED, PA2, PA3);
002651  002891  // Notes  : configures the required I2C module
002652  002892  //        : see 'I2C timing related constants' and 'pin constants'
002653  002893  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002654  002894  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002655  002895  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002656  002896  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002657  002897  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002658  002898  // Returns: True if successful
002659  002899        
002660  002900        
002661  002901  func I2C1_Close(), 0;
002662  002902  // Usage : I2C1_Close();
002663  002903  // Notes : disables the I2C1 module.
002664  002904        
002665  002905  func I2C2_Close(), 0;
002666  002906  // Usage : I2C2_Close();
002667  002907  // Notes : disables the I2C2 module.
002668  002908        
002669  002909  func I2C3_Close(), 0;
002670  002910  // Usage : I2C3_Close();
002671  002911  // Notes : disables the I2C3 module.
002672  002912        
002673  002913  func I2C1_Start(), 1;
002674  002914  // Syntax: I2C1_Start();
002675  002915  // Usage : I2C1_Start();
002676  002916  // Notes : generates a Start condition.
002677  002917  //       : returns true if successful (usually ignored)
002678  002918        
002679  002919  func I2C2_Start(), 1;
002680  002920  // Syntax: I2C2_Start();
002681  002921  // Usage : I2C2_Start();
002682  002922  // Notes : generates a Start condition.
002683  002923  //       : returns true if successful (usually ignored)
002684  002924        
002685  002925  func I2C3_Start(), 1;
002686  002926  // Syntax: I2C3_Start();
002687  002927  // Usage : I2C3_Start();
002688  002928  // Notes : generates a Start condition.
002689  002929  //       : returns true if successful (usually ignored)
002690  002930        
002691  002931  func I2C1_Stop(), 1;
002692  002932  // Syntax: I2C1_Stop();
002693  002933  // Usage : I2C1_Stop();
002694  002934  // Notes : generates a Stop condition.
002695  002935  //       : returns true if successful (usually ignored)
002696  002936        
002697  002937  func I2C2_Stop(), 1;
002698  002938  // Syntax: I2C2_Stop();
002699  002939  // Usage : I2C2_Stop();
002700  002940  // Notes : generates a Stop condition.
002701  002941  //       : returns true if successful (usually ignored)
002702  002942        
002703  002943  func I2C3_Stop(), 1;
002704  002944  // Syntax: I2C3_Stop();
002705  002945  // Usage : I2C3_Stop();
002706  002946  // Notes : generates a Stop condition.
002707  002947  //       : returns true if successful (usually ignored)
002708  002948        
002709  002949  func I2C1_Restart(), 1;
002710  002950  // Syntax: I2C1_Restart();
002711  002951  // Usage : I2C1_Restart();
002712  002952  // Notes : generates a Restart condition.
002713  002953  //       : returns true if successful (usually ignored)
002714  002954        
002715  002955  func I2C2_Restart(), 1;
002716  002956  // Syntax: I2C2_Restart();
002717  002957  // Usage : I2C2_Restart();
002718  002958  // Notes : generates a Restart condition.
002719  002959  //       : returns true if successful (usually ignored)
002720  002960        
002721  002961  func I2C3_Restart(), 1;
002722  002962  // Syntax: I2C3_Restart();
002723  002963  // Usage : I2C3_Restart();
002724  002964  // Notes : generates a Restart condition.
002725  002965  //       : returns true if successful (usually ignored)
002726  002966        
002727  002967  func I2C1_Read(), 1;
002728  002968  // Syntax: I2C1_Read();
002729  002969  // Usage : ch := I2C1_Read();
002730  002970  // Notes : reads a single byte from the I2C Bus.
002731  002971        
002732  002972  func I2C2_Read(), 1;
002733  002973  // Syntax: I2C2_Read();
002734  002974  // Usage : ch := I2C2_Read();
002735  002975  // Notes : reads a single byte from the I2C Bus.
002736  002976        
002737  002977  func I2C3_Read(), 1;
002738  002978  // Syntax: I2C3_Read();
002739  002979  // Usage : ch := I2C3_Read();
002740  002980  // Notes : reads a single byte from the I2C Bus.
002741  002981        
002742  002982  func I2C1_Write("byte"), 1;
002743  002983  // Syntax: I2C1_Write(byte);
002744  002984  // Usage : r := I2C1_Write(ch);
002745  002985  // Notes : is used to write a byte to the I2C bus.
002746  002986  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002747  002987        
002748  002988  func I2C2_Write("byte"), 1;
002749  002989  // Syntax: I2C2_Write(byte);
002750  002990  // Usage : r := I2C2_Write(ch);
002751  002991  // Notes : is used to write a byte to the I2C bus.
002752  002992  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002753  002993        
002754  002994  func I2C3_Write("byte"), 1;
002755  002995  // Syntax: I2C3_Write(byte);
002756  002996  // Usage : r := I2C3_Write(ch);
002757  002997  // Notes : is used to write a byte to the I2C bus.
002758  002998  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002759  002999        
002760  003000  func I2C1_Ack(), 0;
002761  003001  // Syntax: I2C1_Ack();
002762  003002  // Usage : I2C1_Ack();
002763  003003  // Notes : generates the acknowledge condition.
002764  003004        
002765  003005  func I2C2_Ack(), 0;
002766  003006  // Syntax: I2C2_Ack();
002767  003007  // Usage : I2C2_Ack();
002768  003008  // Notes : generates the acknowledge condition.
002769  003009        
002770  003010  func I2C3_Ack(), 0;
002771  003011  // Syntax: I2C3_Ack();
002772  003012  // Usage : I2C3_Ack();
002773  003013  // Notes : generates the acknowledge condition.
002774  003014        
002775  003015  func I2C1_Nack(), 0;
002776  003016  // Syntax: I2C1_Nack();
002777  003017  // Usage : I2C1_Nack();
002778  003018  // Notes : generates the negative acknowledge condition.
002779  003019        
002780  003020  func I2C2_Nack(), 0;
002781  003021  // Syntax: I2C2_Nack();
002782  003022  // Usage : I2C2_Nack();
002783  003023  // Notes : generates the negative acknowledge condition.
002784  003024        
002785  003025  func I2C3_Nack(), 0;
002786  003026  // Syntax: I2C3_Nack();
002787  003027  // Usage : I2C3_Nack();
002788  003028  // Notes : generates the negative acknowledge condition.
002789  003029        
002790  003030  func I2C1_AckStatus(), 1;
002791  003031  // Syntax: I2C1_AckStatus();
002792  003032  // Usage : r := I2C1_AckStatus();
002793  003033  // Notes : returns the ACK status from the device.
002794  003034        
002795  003035  func I2C2_AckStatus(), 1;
002796  003036  // Syntax: I2C2_AckStatus();
002797  003037  // Usage : r := I2C2_AckStatus();
002798  003038  // Notes : returns the ACK status from the device.
002799  003039        
002800  003040  func I2C3_AckStatus(), 1;
002801  003041  // Syntax: I2C3_AckStatus();
002802  003042  // Usage : r := I2C3_AckStatus();
002803  003043  // Notes : returns the ACK status from the device.
002804  003044        
002805  003045  func I2C1_AckPoll("control"), 1;
002806  003046  // Syntax: I2C1_AckPoll();
002807  003047  // Usage : r := I2C1_AckPoll(0xA0);
002808  003048  // Notes : waits for a device to return from ACK polling.
002809  003049        
002810  003050  func I2C2_AckPoll("control"), 1;
002811  003051  // Syntax: I2C2_AckPoll();
002812  003052  // Usage : r := I2C2_AckPoll(0xA0);
002813  003053  // Notes : waits for a device to return from ACK polling.
002814  003054        
002815  003055  func I2C3_AckPoll("control"), 1;
002816  003056  // Syntax: I2C3_AckPoll();
002817  003057  // Usage : r := I2C3_AckPoll(0xA0);
002818  003058  // Notes : waits for a device to return from ACK polling.
002819  003059        
002820  003060  func I2C1_Idle(), 1;
002821  003061  // Syntax : I2C1_Idle();
002822  003062  // Usage  : r := I2C1_Idle();
002823  003063  // Notes  : waits until the I2C Bus is Inactive.
002824  003064  //        : Times out if bus not idle within 1 second
002825  003065  // Returns: TRUE if successful, else failed (timed out)
002826  003066        
002827  003067  func I2C2_Idle(), 1;
002828  003068  // Syntax : I2C2_Idle();
002829  003069  // Usage  : r := I2C2_Idle();
002830  003070  // Notes  : waits until the I2C Bus is Inactive.
002831  003071  //        : Times out if bus not idle within 1 second
002832  003072  // Returns: TRUE if successful, else failed (timed out)
002833  003073        
002834  003074  func I2C3_Idle(), 1;
002835  003075  // Syntax : I2C3_Idle();
002836  003076  // Usage  : r := I2C3_Idle();
002837  003077  // Notes  : waits until the I2C Bus is Inactive.
002838  003078  //        : Times out if bus not idle within 1 second
002839  003079  // Returns: TRUE if successful, else failed (timed out)
002840  003080        
002841  003081        
002842  003082  func I2C1_Gets("buffer", "size"), 1;
002843  003083  // Syntax: I2C1_Gets("buffer", "size");
002844  003084  // Usage : r := I2C1_Gets(mybuf, 16);
002845  003085  // Notes : only reads up to "size" characters into "buffer"
002846  003086  //       : Reads up to asciiz terminator including terminator
002847  003087        
002848  003088  func I2C2_Gets("buffer", "size"), 1;
002849  003089  // Syntax: I2C2_Gets("buffer", "size");
002850  003090  // Usage : r := I2C2_Gets(mybuf, 16);
002851  003091  // Notes : only reads up to "size" characters into "buffer"
002852  003092  //       : Reads up to asciiz terminator including terminator
002853  003093        
002854  003094  func I2C3_Gets("buffer", "size"), 1;
002855  003095  // Syntax: I2C3_Gets("buffer", "size");
002856  003096  // Usage : r := I2C3_Gets(mybuf, 16);
002857  003097  // Notes : only reads up to "size" characters into "buffer"
002858  003098  //       : Reads up to asciiz terminator including terminator
002859  003099        
002860  003100  func I2C1_Getn("buffer", "size"), 1;
002861  003101  // Syntax: I2C1_Gets("buffer", "size");
002862  003102  // Usage : r := I2C1_Gets(mybuf, 16);
002863  003103  // Notes : reads "size" bytes into "buffer"
002864  003104  //       :
002865  003105        
002866  003106  func I2C2_Getn("buffer", "size"), 1;
002867  003107  // Syntax: I2C2_Gets("buffer", "size");
002868  003108  // Usage : r := I2C2_Gets(mybuf, 16);
002869  003109  // Notes : reads "size" bytes into "buffer"
002870  003110  //       :
002871  003111        
002872  003112  func I2C3_Getn("buffer", "size"), 1;
002873  003113  // Syntax: I2C3_Gets("buffer", "size");
002874  003114  // Usage : r := I2C3_Gets(mybuf, 16);
002875  003115  // Notes : reads "size" bytes into "buffer"
002876  003116  //       :
002877  003117        
002878  003118  func I2C1_Puts("buffer"), 1;
002879  003119  // Syntax: I2C1_Puts("buffer");
002880  003120  // Usage : r := I2C1_Puts(mybuf);
002881  003121  // Notes : writes an asciiz string to the I2C device
002882  003122  //       : returns count of characters written
002883  003123        
002884  003124  func I2C2_Puts("buffer"), 1;
002885  003125  // Syntax: I2C2_Puts("buffer");
002886  003126  // Usage : r := I2C2_Puts(mybuf);
002887  003127  // Notes : writes an asciiz string to the I2C device
002888  003128  //       : returns count of characters written
002889  003129        
002890  003130  func I2C3_Puts("buffer"), 1;
002891  003131  // Syntax: I2C3_Puts("buffer");
002892  003132  // Usage : r := I2C3_Puts(mybuf);
002893  003133  // Notes : writes an asciiz string to the I2C device
002894  003134  //       : returns count of characters written
002895  003135        
002896  003136  func I2C1_Putn("buffer", "count"), 1;
002897  003137  // Syntax: I2C1_Putn("buffer","count");
002898  003138  // Usage : r := I2C1_Puts(mybuf,10);
002899  003139  // Notes : writes up to "size" bytes to the I2C device
002900  003140  //       : returns number of bytes written
002901  003141        
002902  003142  func I2C2_Putn("buffer", "count"), 1;
002903  003143  // Syntax: I2C2_Putn("buffer","count");
002904  003144  // Usage : r := I2C2_Puts(mybuf,10);
002905  003145  // Notes : writes up to "size" bytes to the I2C device
002906  003146  //       : returns number of bytes written
002907  003147        
002908  003148  func I2C3_Putn("buffer", "count"), 1;
002909  003149  // Syntax: I2C3_Putn("buffer","count");
002910  003150  // Usage : r := I2C3_Puts(mybuf,10);
002911  003151  // Notes : writes up to "size" bytes to the I2C device
002912  003152  //       : returns number of bytes written
002913  003153        
002914  003154        
002915  003155  func spi_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002916  003156  // Syntax   : spi_ReadBlock("buf", "bufsize");
002917  003157  // Usage    : spi_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002918  003158  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002919  003159        
002920  003160  func spi1_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002921  003161  // Syntax   : spi1_ReadBlock("buf", "bufsize");
002922  003162  // Usage    : spi1_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002923  003163  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002924  003164        
002925  003165  func spi2_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002926  003166  // Syntax   : spi2_ReadBlock("buf", "bufsize");
002927  003167  // Usage    : spi2_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002928  003168  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002929  003169        
002930  003170  func spi3_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002931  003171  // Syntax   : spi3_ReadBlock("buf", "bufsize");
002932  003172  // Usage    : spi3_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002933  003173  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002934  003174        
002935  003175  // I2C timing related constants
002936  003176  #CONST
002937  003184  #END
002938  003185        
002939  003186        
002940  003187        
002941  003188  //------------------------------------------------------------------//
002942  003189  // Direct uSD (SPI0) card SPI functions                             //
002943  003190  //------------------------------------------------------------------//
002944  003191  func spi_Init("speed","mode"), 0;  // set the SPI port, not used if uSD active
002945  003192  // Syntax   : spi_Init(SPI_FAST,0);
002946  003193  // Usage    : spi_Init(SPI_FAST,0);              // init SPI at maximum speed
002947  003194  // *Notes   : mode needs to be SPI_ADDRESS_MODE4 for flash devices with more than 16MB of capacity
002948  003195        
002949  003196  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
002950  003197  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
002951  003198  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
002952  003199                                                  //
002953  003200        
002954  003201  //------------------------------------------------------------------//
002955  003202  // Function prototypes for SPI1, SPI2 and SPI3                      //
002956  003203  //------------------------------------------------------------------//
002957  003204  func SPI1_SDO_pin("pin"), 1;                // select the hardware pin for SPI1 transmit line
002958  003205  // Syntax: SPI_SDO_pin(pin);
002959  003206  // Usage : SPI_SDO_pin(PA1); // set SPI SDO to PA1 pin
002960  003207  // Notes : Select the hardware pin for SPIx transmit line.
002961  003208  //       : Note that multiple pins can be connected simmultaneously.
002962  003209  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002963  003210  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002964  003211  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002965  003212  //       : The pin is automatically set to an output.
002966  003213  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002967  003214        
002968  003215  func SPI2_SDO_pin("pin"), 1;                // select the hardware pin for SPI2 transmit line
002969  003216  // Syntax: SPI2_SDO_pin(pin);
002970  003217  // Usage : SPI2_SDO_pin(PA1); // set SPI2 SDO to PA1 pin
002971  003218  // Notes : Select the hardware pin for SPIx transmit line.
002972  003219  //       : Note that multiple pins can be connected simmultaneously.
002973  003220  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002974  003221  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002975  003222  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002976  003223  //       : The pin is automatically set to an output.
002977  003224  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002978  003225        
002979  003226  func SPI3_SDO_pin("pin"), 1;                // select the hardware pin for SPI3 transmit line
002980  003227  // Syntax: SPI3_SDO_pin(pin);
002981  003228  // Usage : SPI3_SDO_pin(PA1); // set SPI3 SDO to PA1 pin
002982  003229  // Notes : Select the hardware pin for SPIx transmit line.
002983  003230  //       : Note that multiple pins can be connected simmultaneously.
002984  003231  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002985  003232  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002986  003233  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002987  003234  //       : The pin is automatically set to an output.
002988  003235  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002989  003236        
002990  003237  func SPI1_SDI_pin("pin"), 1;                // select the hardware pin for SPI1 receive line
002991  003238  // Syntax: SPI1_SDI_pin(pin);
002992  003239  // Usage : SPI1_SDI_pin(PA3); // set SPI1 SDI to PA3 pin
002993  003240  // Notes : Selects the hardware pin for SPIx receive line.
002994  003241  //       : Note that only a single pin can be mapped to SPI SDI.
002995  003242  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
002996  003243  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
002997  003244  //       : If the pin argument is 0 the function has no effect
002998  003245  //       : The pin is automatically set to an input.
002999  003246  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003000  003247  //       : it is necessary to configure the SDI pin first, eg
003001  003248  //       :     SPI1_SDI_pin(PA3);     // configure SPI1 SDI to PA3 (this disconnects anything else)
003002  003249  //       :     SPI1_SDO_pin(PA3));    // configure SPI1 SDO to PA3
003003  003250  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003004  003251        
003005  003252  func SPI2_SDI_pin("pin"), 1;                // select the hardware pin for SPI2 receive line
003006  003253  // Syntax: SPI2_SDI_pin(pin);
003007  003254  // Usage : SPI2_SDI_pin(PA3); // set SPI2 SDI to PA3 pin
003008  003255  // Notes : Selects the hardware pin for SPIx receive line.
003009  003256  //       : Note that only a single pin can be mapped to SPI SDI.
003010  003257  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003011  003258  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003012  003259  //       : If the pin argument is 0 the function has no effect
003013  003260  //       : The pin is automatically set to an input.
003014  003261  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003015  003262  //       : it is necessary to configure the SDI pin first, eg
003016  003263  //       :     SPI2_SDI_pin(PA3);     // configure SPI2 SDI to PA3 (this disconnects anything else)
003017  003264  //       :     SPI2_SDO_pin(PA3));    // configure SPI2 SDO to PA3
003018  003265  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003019  003266        
003020  003267  func SPI3_SDI_pin("pin"), 1;                // select the hardware pin for SPI2 receive line
003021  003268  // Syntax: SPI3_SDI_pin(pin);
003022  003269  // Usage : SPI3_SDI_pin(PA3); // set SPI3 SDI to PA3 pin
003023  003270  // Notes : Selects the hardware pin for SPIx receive line.
003024  003271  //       : Note that only a single pin can be mapped to SPI SDI.
003025  003272  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003026  003273  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003027  003274  //       : If the pin argument is 0 the function has no effect
003028  003275  //       : The pin is automatically set to an input.
003029  003276  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003030  003277  //       : it is necessary to configure the SDI pin first, eg
003031  003278  //       :     SPI3_SDI_pin(PA3);     // configure SPI3 SDI to PA3 (this disconnects anything else)
003032  003279  //       :     SPI3_SDO_pin(PA3));    // configure SPI3 SDO to PA3
003033  003280  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003034  003281        
003035  003282  func SPI1_SCK_pin("pin"), 1;                // select the hardware pin for SPI1 clock line
003036  003283  // Syntax: SPI1_SCK_pin(pin);
003037  003284  // Usage : SPI1_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003038  003285  // Notes : Selects the hardware pin for SPI clock line.
003039  003286  //       : Note that only a single pin should be mapped to spi SCK.
003040  003287  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003041  003288  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003042  003289  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003043  003290  //       : The pin is automatically set to an output.
003044  003291  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003045  003292        
003046  003293  func SPI2_SCK_pin("pin"), 1;                // select the hardware pin for SPI2 clock line
003047  003294  // Syntax: SPI2_SCK_pin(pin);
003048  003295  // Usage : SPI2_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003049  003296  // Notes : Selects the hardware pin for SPI clock line.
003050  003297  //       : Note that only a single pin should be mapped to spi SCK.
003051  003298  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003052  003299  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003053  003300  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003054  003301  //       : The pin is automatically set to an output.
003055  003302  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003056  003303        
003057  003304  func SPI3_SCK_pin("pin"), 1;                // select the hardware pin for SPI3 clock line
003058  003305  // Syntax: SPI3_SCK_pin(pin);
003059  003306  // Usage : SPI3_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003060  003307  // Notes : Selects the hardware pin for SPI clock line.
003061  003308  //       : Note that only a single pin should be mapped to spi SCK.
003062  003309  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003063  003310  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003064  003311  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003065  003312  //       : The pin is automatically set to an output.
003066  003313  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003067  003314        
003068  003315        
003069  003316  func SPI1_Init("speed","mode", "enablepin"), 1;              // set the SPI1 port
003070  003317  func SPI2_Init("speed","mode", "enablepin"), 1;              // set the SPI2 port
003071  003318  func SPI3_Init("speed","mode", "enablepin"), 1;              // set the SPI3 port
003072  003319        
003073  003320        
003074  003321  //------------------------------------------------------------------------------
003075  003322  // Constants for SPI1, SPI2 an SPI3 "mode"
003076  003323  //------------------------------------------------------------------------------
003077  003324  #CONST
003078  003343  #END
003079  003344        
003080  003345  //------------------------------------------------------------------------------
003081  003346  // Constants for SPI1, SPI2 an SPI3 "speed"
003082  003347  //------------------------------------------------------------------------------
003083  003348  #CONST
003084  003369  #END
003085  003370        
003086  003371        
003087  003372  func SPI1_Read(), 1;                                 // read a raw byte from SPI1
003088  003373  func SPI2_Read(), 1;                                 // read a raw byte from SPI2
003089  003374  func SPI3_Read(), 1;                                 // read a raw byte from SPI3
003090  003375        
003091  003376  func SPI1_Write("byte"), 1;                          // write a raw byte to SPI1
003092  003377  func SPI2_Write("byte"), 1;                          // write a raw byte to SPI2
003093  003378  func SPI3_Write("byte"), 1;                          // write a raw byte to SPI3
003094  003379        
003095  003380  func spi_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003096  003381  // Syntax   : spi_WriteBlock("buf", "bufsize");
003097  003382  // Usage    : spi_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003098  003383  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003099  003384        
003100  003385  func spi1_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003101  003386  // Syntax   : spi1_WriteBlock("buf", "bufsize");
003102  003387  // Usage    : spi1_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003103  003388  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003104  003389        
003105  003390  func spi2_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003106  003391  // Syntax   : spi2_WriteBlock("buf", "bufsize");
003107  003392  // Usage    : spi2_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003108  003393  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003109  003394        
003110  003395  func spi3_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003111  003396  // Syntax   : spi3_WriteBlock("buf", "bufsize");
003112  003397  // Usage    : spi3_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003113  003398  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003114  003399        
003115  003400  //------------------------------------------------------------------//
003116  003401  // Display Access                                                   //
003117  003402  //------------------------------------------------------------------//
003118  003403  func disp_SetReg("register", "data"), 0;
003119  003404  // Syntax: display_SetReg(register, data);
003120  003405  // Usage : display_SetReg(arg1, arg2);
003121  003406  // Notes : Sets uLCD specific display driver registers. Refer
003122  003407  //       : to appropriate display driver data sheet.
003123  003408        
003124  003409  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
003125  003410  // Syntax: disp_setGRAM(x1, y1, x2, y2);
003126  003411  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
003127  003412  // Notes : Prepares the GRAM area for user access.
003128  003413  //       : Data can now be written with disp_GRAM.
003129  003414  //       : GRAM will be set accordingly for the correct screen mode.
003130  003415  //       : the LO word of the 32 bit pixel count is returned. This is
003131  003416  //       : usually all that is needed unlse GRAM area exceeds 256^2
003132  003417  //       : A copy of the 32bit value can be found in
003133  003418  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
003134  003419        
003135  003420  func disp_WrGRAM("colour"), 0;
003136  003421  // Syntax: display_WrGRAM(colour);
003137  003422  // Usage : display_WrGRAM(arg);
003138  003423  // Notes : Data can be written to the GRAM consecutively using
003139  003424  //       : this function once the GRAM access window has been setup.
003140  003425        
003141  003426  func disp_WriteControl("value"), 0;             // write a control byte to the display
003142  003427        
003143  003428  func disp_WriteWord("value"), 0;                // write a word to the display
003144  003429        
003145  003430        
003146  003431  func disp_ReadWord(), 1;                        // read a word from the display
003147  003432  // Syntax: disp_ReadWord();
003148  003433  // Usage : x:=disp_ReadWord();
003149  003434  // Notes : Read a word from the controller
003150  003435  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
003151  003436  //       : print(disp_ReadWord());        // print ID
003152  003437  //       : (Many displays are write only)
003153  003438        
003154  003439        
003155  003440  // NB only available on certain displays, check individual data sheets
003156  003441  func sys_StoreTouchCalibration(), 1;
003157  003442  // Syntax: sys_StoreTouchCalibration();
003158  003443  // Usage : r := sys_StoreTouchCalibration();
003159  003444  // Notes : Store the touch calibration values in non-volatile memory.
003160  003445  //       : Returns true if the values have been accepted and stored,
003161  003446  //       : else returns false if write could not be performed, or
003162  003447  //       : touch calibration values are improbable.
003163  003448  //       : The values that are stored are obtained from:-
003164  003449  //       : TOUCH_XMINCAL             78  // touch calibration value
003165  003450  //       : TOUCH_YMINCAL             79  // touch calibration value
003166  003451  //       : TOUCH_XMAXCAL             80  // touch calibration value
003167  003452  //       : TOUCH_YMAXCAL             81  // touch calibration value
003168  003453  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
003169  003454  //       : This function is not supported on uVGA, Capacitive touch
003170  003455  //       : and 4.3" resistive touch modules.
003171  003456        
003172  003457  // NB only available on certain displays, check individual data sheets
003173  003458  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
003174  003459  // Syntax: disp_Sync(line);
003175  003460  // Usage : disp_Sync(480);
003176  003461  // Notes : Waits till the hardware gets to a certain line.
003177  003462  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
003178  003463  //       : Some experimentation may be needed to find an optimum line for disp_Sync
003179  003464  //       : depending on the graphics operation. The higher the value, the slower
003180  003465  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
003181  003466  //       : within the vertical retrace period) where it will just 'hang up' stopping the
003182  003467  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
003183  003468  //       : be slowest (as its actually right at the end of the blanking period) and 508
003184  003469  //       : will cause a hangup situation as it is above the highes scanline value.
003185  003470  //       : Currently, this function is only supported on displays with SSD1963 driver.
003186  003471        
003187  003472  func disp_Init(), 0;                           // initialize display with required tables. New in v0.7
003188  003473  // Syntax: disp_Init();                        New in v0.7
003189  003474  // Usage : disp_Init();
003190  003475  // Notes : Initialises or reinitialises the display.
003191  003476  //       : Normally used after restoration of peripheral power
003192  003477  //       : and after DeepSleep.
003193  003478        
003194  003479  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v0.7
003195  003480  // Syntax: disp_Disconnect();                  New in v0.7
003196  003481  // Usage : disp_Disconnect();
003197  003482  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
003198  003483  //       : its lowest possible power consumption. Use after disabling peripheral power
003199  003484  //       : to ensure the minimal power usage by the display.
003200  003485  //       : disp_Init() should be used to reinitialise the display.
003201  003486        
003202  003487  func disp_BlitPixelsFromCOM0(), 0;                     // Writes current GRAM window pixels to the display from the COM port
003203  003488  // Syntax: disp_BlitPixelsFromCOM0();                  New in v1.1
003204  003489  // Usage : disp_BlitPixelsFromCOM0();
003205  003490  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
003206  003491  //       : display from the specified com port.
003207  003492        
003208  003493  func __reserved42(), 0; // do not remove
003209  003494        
003210  003495        
003211  003496  //------------------------------------------------------------------//
003212  003497  //        Image Control Function Prototypes                         //
003213  003498  //------------------------------------------------------------------//
003214  003499  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
003215  003500  // Syntax: img_SetPosition(handle, index, xpos, ypos);
003216  003501  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
003217  003502  // Notes : set the position where the image will be displayed
003218  003503  //       : returns true if index was ok and function was successful.
003219  003504  //       : you may turn off an image so when img_Refresh is called,
003220  003505  //       : the image will not be shown
003221  003506        
003222  003507  func img_Enable("handle", "index"), 1;
003223  003508  // Syntax: img_Enable(handle, index);
003224  003509  // Usage : r := img_Enable(hImageList, imagenum);
003225  003510  // Notes : enable image in a image list
003226  003511  //       : returns true if index was ok and function was successful.
003227  003512  //       : this is the default state so when img_Refresh is called,
003228  003513  //       : all the images in the list will be shown
003229  003514  //       : if index is set to -1, all of the images are enabled
003230  003515        
003231  003516  func img_Disable("handle", "index"), 1;
003232  003517  // Syntax: img_Disable(handle, index);
003233  003518  // Usage : r := img_Disable(hImageList, imagenum);
003234  003519  // Notes : disable image in a image list
003235  003520  //       : returns true if index was ok and function was successful.
003236  003521  //       : you must turn off an image so when img_Refresh is called,
003237  003522  //       : the image will not be shown.
003238  003523  //       : if index is set to -1, all of the images are disabled
003239  003524        
003240  003525        
003241  003526  func img_Darken("handle", "index"), 1;
003242  003527  // Syntax: img_Darken(handle, index);
003243  003528  // Usage : r := img_Darken(hImageList, imagenum);
003244  003529  // Notes : darken image in a image list
003245  003530  //       : returns true if index was ok and function was successful.
003246  003531  //       : if index is set to -1, all of the images are darkened
003247  003532  //       : NB:- this feature will only work for the next refresh, then
003248  003533  //       : the image reverts back to normal when displayed again.
003249  003534        
003250  003535        
003251  003536  func img_Lighten("handle", "index"), 1;
003252  003537  // Syntax: img_Lighten(handle, index);
003253  003538  // Usage : r := img_Lighten(hImageList, imagenum);
003254  003539  // Notes : lighten image in a image list
003255  003540  //       : returns true if index was ok and function was successful.
003256  003541  //       : if index is set to -1, all of the images are lightened
003257  003542  //       : NB:- this feature will only work for the next refresh, then
003258  003543  //       : the image reverts back to normal when displayed again.
003259  003544        
003260  003545  func img_SetWord("handle", "index", "offset", "word"), 1;
003261  003546  // Syntax: img_SetWord(handle, index, offset, word);
003262  003547  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
003263  003548  // Notes : set specified word (0-7) in a image entry
003264  003549  //       : returns TRUE if successful, return value usually ignored.
003265  003550        
003266  003551  func img_GetWord("handle", "index", "offset"), 1;
003267  003552  // Syntax: myvar := img_GetWord("handle", "index", "offset");
003268  003553  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
003269  003554  // Notes : returns specified word (0-14) from an image entry
003270  003555  //       : refer to image control entry offsets.
003271  003556        
003272  003557  func img_Show("handle", "index"), 1;
003273  003558  // Syntax: img_Show(handle, index);
003274  003559  // Usage : display image entry (regardless of enable/disable)
003275  003560  //       : returns TRUE if successful, return value usually ignored.
003276  003561        
003277  003562  func img_SetAttributes("handle", "index","value"), 1;
003278  003563  // Syntax: img_SetAttributes("handle", "index","offset");
003279  003564  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
003280  003565  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
003281  003566  //       : of an image control entry. "value" refers to various bits in
003282  003567  //       : the image control entry (see image attribute flags).
003283  003568  //       : A '1' bit in the "value" field SETS the respective bit
003284  003569  //       : in the IMAGE_FLAGS field of the image control entry.
003285  003570  //       : returns TRUE if successful, return value usually ignored.
003286  003571        
003287  003572  func img_ClearAttributes("handle", "index","value"), 1;
003288  003573  // Syntax: img_ClearAttributes("handle", "index","offset");
003289  003574  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
003290  003575  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
003291  003576  //       : of an image control entry. "value" refers to various bits in
003292  003577  //       : the image control entry (see image attribute flags)
003293  003578  //       : a '1' bit in the "value" field CLEARS the respective bit
003294  003579  //       : in the IMAGE_FLAGS field of the image control entry.
003295  003580  //       : returns TRUE if successful, return value usually ignored.
003296  003581        
003297  003582  func img_Touched("handle", "index"), 1;
003298  003583  // Syntax: r := img_Touched(handle, index);
003299  003584  // Usage : img_Touched(hndl, 17);
003300  003585  //       : returns -1 if image not touched, or returns index
003301  003586  // Notes : if index is passed as -1, function tests all images,
003302  003587  //       : and returns -1 if image not touched, or returns index.
003303  003588        
003304  003589        
003305  003590  func img_SelectReadPosition("handle", "index", "frame", "x", "y"), 1;
003306  003591  // Syntax: img_SelectReadPosition(handle, index, frame, xpos, ypos);
003307  003592  // Usage : r := img_SelectReadPosition(hImageList, imagenum, frame, x, y);
003308  003593  // Notes : set a position in an image control for sequential reading
003309  003594  //       : of pixels from the uSD card (fat16 or raw modes supported)
003310  003595  //       : No image window area is set, the image will not be shown
003311  003596  //       : This function provides a means of preparing to load an image,
003312  003597  //       : or part of an image, to an array. (see img_SequentialRead)
003313  003598  //Returns: returns true if index was ok and function was successful.
003314  003599        
003315  003600        
003316  003601  func img_SequentialRead("count", "ptr"), 1;  // read pixels from selected read position of an image
003317  003602  // Syntax: img_SequentialRead(count, ptr);
003318  003603  // Usage1: r := img_SequentialRead(imgwidth, myArray);    // read 1 line from image control to array
003319  003604  // Usage2: r := img_SequentialRead(123, 0);            // skip 123 words from sequential stream
003320  003605  // Usage3: r := img_SequentialRead(20, 1);            // write 20 pixels to current GRAM position from stream
003321  003606  // Notes : once a position has ben set with the img_SelectReadPosition function,
003322  003607  //       : this function can then used for sequential reading of pixels from
003323  003608  //       : image storage.
003324  003609  //       : if "ptr" is 0, "count" pixels from the stream are simply skipped.
003325  003610  //       : if "ptr" is 1, "count" pixels are written to the GRAM area,
003326  003611  //       : else "ptr" must point to a valid array that is at least
003327  003612  //       : the size of "count".
003328  003613  //       : or part of an image, to an array. (see img_SequentialRead)
003329  003614  //       : returns TRUE if function succeded.
003330  003615        
003331  003616  func __reserved43(), 0; // do not remove
003332  003617  func __reserved44(), 0; // do not remove
003333  003618  func __reserved45(), 0; // do not remove
003334  003619  func __reserved46(), 0; // do not remove
003335  003620        
003336  003621  // image control header offsets
003337  003622  #CONST
003338  003629  #END
003339  003630        
003340  003631  // image control entry offsets
003341  003632  #CONST
003342  003647  #END
003343  003648        
003344  003649  // image attribute flags (in IMAGE_FLAGS)
003345  003650  // for img_SetAttributes(...) and img_ClearAttributes(...)
003346  003651  #CONST
003347  003665  #END
003348  003666        
003349  003667        
003350  003668  //------------------------------------------------------------------//
003351  003669  //        Timer Function Prototypes
003352  003670  //------------------------------------------------------------------//
003353  003671  func sys_T(), 1;
003354  003672  // Syntax: sys_T();
003355  003673  // Usage : t := sys_T();
003356  003674  // Notes : return the current value of the rolling system timer (1msec) LO word
003357  003675        
003358  003676  func sys_T_HI(), 1;
003359  003677  // Syntax: sys_T_HI();
003360  003678  // Usage : t := sys_T_HI();
003361  003679  // Notes : return the current value of the rolling system timer (1msec) HI word
003362  003680        
003363  003681  func sys_SetTimer("timernum","value"), 0;
003364  003682  // Syntax: sys_SetTimer("timernum", "value");
003365  003683  // Usage : sys_SetTimer(TIMER5, 10000);
003366  003684  // Notes : set a countdown on the selected timer, or 'top up' if required.
003367  003685  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
003368  003686  //       : Maximum timeout period is 65.535 seconds
003369  003687  //       : A timer can be read with the sys_GetTimer("timernum") function
003370  003688        
003371  003689  func sys_GetTimer("timernum"), 1;
003372  003690  // Syntax: t := sys_GetTimer("timernum");
003373  003691  // Usage : t := sys_GetTimer(TIMER3);
003374  003692  // Notes : returns 0 if timer has expired, or the current countdown value.
003375  003693  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
003376  003694  //       : Maximum timeout period is 65.535 seconds
003377  003695  //       : A timer must be set with the sys_SetTimer("timernum","value") function
003378  003696        
003379  003697  func sys_SetTimerEvent("timernum","function"), 1;
003380  003698  // Syntax: sys_SetTimerFunction("timernum", "function");
003381  003699  // Usage : sys_SetTimer(TIMER5, myfunc);
003382  003700  // Notes : set a function to be called for selected timer.
003383  003701  //       : When the timer reaches zero, the function is called.
003384  003702  //       : The called function must not have any parameters
003385  003703  //       : sys_SetTimerEvent returns any previous event function
003386  003704  //       : address, or zero if there was no previous function.
003387  003705        
003388  003706  func sys_EventQueue(), 1;
003389  003707  // Syntax: sys_EventQueue();
003390  003708  // Usage : tasks := sys_EventQueue();
003391  003709  // Notes : returns the max number of events that were pending
003392  003710  //       : in the timer queue since the last call to this function.
003393  003711  //       : This can be used to assess timer event overhead burden,
003394  003712  //       : especially after or during a sys_EventsPostpone action.
003395  003713        
003396  003714  func sys_EventsPostpone(), 0;
003397  003715  // Syntax: sys_EventPostpone();
003398  003716  // Usage : sys_EventPostpone();   // postpone the event queue
003399  003717  // Notes : postpone any events until the sys_EventResume function is executed
003400  003718  //       : The timer event queue will continue to queue events, but no action
003401  003719  //       : will take place untill a sys_EventResume function is encountered.
003402  003720  //       : The queue will continue to receive up to 32 events before discarding
003403  003721  //       : any further events. This function is required to allow a sequence of
003404  003722  //       : instructions or functions to occur that would otherwise be corrupted
003405  003723  //       : by an event occuring during the sequence of instructions or functions.
003406  003724  //       : A good example of this is when you set a position to print, if there
003407  003725  //       : was no way of locking the current sequence, an event may occur which
003408  003726  //       : does a similar thing, and a contention would occur - printing to
003409  003727  //       : the wrong position. This function should be used wisely, if any action
003410  003728  //       : that is required would take considerable time, it is better to disable
003411  003729  //       : any conflicting event functions with a bypass flag, then restart the
003412  003730  //       : conflicting event by re-issuing a timer value.
003413  003731        
003414  003732  func sys_EventsResume(), 0;
003415  003733  // Syntax: sys_EventsResume();
003416  003734  // Usage : sys_EventsResume();   // resume the event queue
003417  003735  // Notes : resume any postponed events. The queue will try to execute any timer
003418  003736  //       : events that were incurred during the postponed period.
003419  003737        
003420  003738        
003421  003739  func sys_GetTime(), 0;
003422  003740  // Syntax: sys_GetTime();
003423  003741  // Usage : to(mystring); sys_GetTime();   // save current time string to buffer
003424  003742  // Notes : print the system time in the format eg "6:10:45"
003425  003743  //       : Can be captured to a buffer using the to( function
003426  003744  //       : Returns nothing.
003427  003745        
003428  003746  func sys_SetTime("hours", "mins", "secs"), 1;
003429  003747  // Syntax: sys_SetTime(h, m, s);
003430  003748  // Usage : sys_SetTime(10, 0, 0);   // set the system time
003431  003749  // Notes : Used to set clock to correct time after power up or suspension
003432  003750  //Returns: Returns true if valid time.
003433  003751        
003434  003752  func sys_GetDate(), 0;
003435  003753  // Syntax: sys_GetDate();
003436  003754  // Usage : to(mystring); sys_GetDate();   // save current time string to buffer
003437  003755  // Notes : print the system date in the format eg "25-09-2012"
003438  003756  //       : Can be captured to a buffer using the to( function
003439  003757  //       : Returns nothing.
003440  003758        
003441  003759  func sys_SetDate("year", "month", "day"), 1;
003442  003760  // Syntax: sys_SetDate(y, m, d);
003443  003761  // Usage : sys_SetDate(10, 0, 0);   // set the system time
003444  003762  // Notes : Used to set clock to correct date after power up or suspension
003445  003763  //Returns: Returns true if valid date.
003446  003764        
003447  003765  func sys_Sleep("units"), 1;
003448  003766  // Syntax: t := sys_Sleep("units");
003449  003767  // Usage : t := sys_Sleep(10);
003450  003768  // Notes : sets the display into low power mode for a period of time.
003451  003769  //       : Touching the touch screen will also wake from sleep.
003452  003770  //       : as will bus Change Interrupts.
003453  003771  //       : Returns remaining sleep units.
003454  003772        
003455  003773  func iterator("offset"), 0;
003456  003774  // Syntax: t :=  iterator("offset");
003457  003775  // Usage : t :=  iterator(10);
003458  003776  // Notes : set the iterator size for ++/--
003459  003777  //       : The next postinc,postdec,preinc of predec will alter
003460  003778  //       : by the specified value.
003461  003779  //       : The offset will return to 1 after the next operation.
003462  003780        
003463  003781  func sys_DeepSleep("units"), 1;               // put the module into its lowest power consumption mode. New in v0.7
003464  003782  // Syntax: t := sys_DeepSleep("units");    New in v0.7
003465  003783  // Usage : t := sys_DeepSleep(10);
003466  003784  // Notes : sets the display and processor into lowest power mode for a period of time.
003467  003785  //       : When returning from DeepSleep the display should be reinitialised
003468  003786  //       : with disp_Init().
003469  003787  //       : Touching the touch screen will also wake from sleep.
003470  003788  //       : Returns remaining sleep units.
003471  003789        
003472  003790  //------------------------------------------------------------------//
003473  003791  //         Touch Screen Function Prototypes
003474  003792  //------------------------------------------------------------------//
003475  003793        
003476  003794  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
003477  003795  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
003478  003796  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
003479  003797  // Notes : Specifies a new touch detect region on the screen
003480  003798  //       : such that only touch activity in that region will
003481  003799  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
003482  003800        
003483  003801  func touch_Set("mode"), 0;
003484  003802  // Syntax: touch_Set(mode);
003485  003803  // Usage : touch_Set(arg);
003486  003804  // Notes : Sets various Touch Screen related parameters
003487  003805  //       :
003488  003806  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
003489  003807  //       : touch_Set(TOUCH_ENABLE);
003490  003808  //       : Enables and initialises Touch Screen hardware
003491  003809  //       :
003492  003810  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
003493  003811  //       : touch_Set(TOUCH_DISABLE );
003494  003812  //       : Disables the Touch Screen
003495  003813  //       : Note: Touch Screen runs in the background and disabling
003496  003814  //       : it when not in use will free up extra resources
003497  003815  //       : such as 4DVM CPU cycles.
003498  003816  //       :
003499  003817  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
003500  003818  //       : touch_Set(TOUCH_REGIONDEFAULT);
003501  003819  //       : This will reset the current active region to default
003502  003820  //       : to the full screen without the application having to
003503  003821  //       : set a new active region for the full screen.
003504  003822  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
003505  003823  //       : that requre to be interfaced with an external pointing
003506  003824  //       : device, values that are poked into TOUCH_DRIVE will be
003507  003825  //       : read with the touch_Get() function)
003508  003826        
003509  003827        
003510  003828  func touch_Get("mode"), 1;
003511  003829  // Syntax: touch_Get(mode);
003512  003830  // Usage : arg1 := touch_Get(arg);
003513  003831  // Notes : Returns various Touch Screen parameters to caller
003514  003832  //       :
003515  003833  //       : mode = TOUCH_STATUS  (mode 0)
003516  003834  //       : var := touch_Get(TOUCH_STATUS);
003517  003835  //       : Returns the various states of the touch screen
003518  003836  //       : 0 = NOTOUCH
003519  003837  //       : 1 = TOUCH_PRESSED
003520  003838  //       : 2 = TOUCH_RELEASED
003521  003839  //       : 3 = TOUCH_MOVING
003522  003840  //       :
003523  003841  //       : mode = TOUCH_GETX   (mode 1)
003524  003842  //       : var := touch_Get(TOUCH_GETX);
003525  003843  //       : Returns the X coordinates of the touch
003526  003844  //       :
003527  003845  //       : mode = TOUCH_GETY   (mode 2)
003528  003846  //       : var := touch_Get(TOUCH_GETY);
003529  003847  //       : Returns the Y coordinates of the touch
003530  003848        
003531  003849        
003532  003850  //touch_Set() related constants
003533  003851  #CONST
003534  003855  #END
003535  003856        
003536  003857  //touch_Get() related constants
003537  003858  #CONST
003538  003866  #END
003539  003867        
003540  003868  func touch_TestBox("&rect"), 1;
003541  003869  // Syntax   : touch_Test(rect);
003542  003870  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=20; r[3]:=30;
003543  003871  //          : result := touch_Test(r); // check area at 100,200,119,229
003544  003872  // Notes    : rect is an array of 4 vars, x1, y1, width, height (using boxed co-ordinates)
003545  003873  // returns  : Returns true if last touch co-ordinates are within the boxed test area.
003546  003874        
003547  003875  func touch_TestArea("&rect"), 1;
003548  003876  // Syntax   : touch_Test(rect);
003549  003877  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=119; r[3]:=129;
003550  003878  //          : result := touch_Test(r); // check area at 100,200,119,229
003551  003879  // Notes    : rect is an array of 4 vars, x1, y1, x2, y2 (using absolute co-ordinates)
003552  003880  // returns  : Returns true if last touch co-ordinates are within the absolute co-ordinate test area.
003553  003881        
003554  003882        
003555  003883  func __reserved51(), 0; // do not remove
003556  003884  func __reserved52(), 0; // do not remove
003557  003885        
003558  003886  //------------------------------------------------------------------//
003559  003887  //        Memory Allocation Function Prototypes
003560  003888  //------------------------------------------------------------------//
003561  003889        
003562  003890  func mem_Alloc("size"), 1;
003563  003891  // Syntax: mem_Alloc(bytesize);
003564  003892  // Usage : myvar := mem_Alloc(100);
003565  003893  // Notes : Allocate a block of memory to pointer myvar
003566  003894  //       : The allocated memory contains garbage but is a fast allocation.
003567  003895  //       : The block must later be released with mem_Free();
003568  003896  //       : returns 0 if function fails
003569  003897        
003570  003898  func mem_AllocV("size"), 1;
003571  003899  // Syntax: mem_AllocV(bytesize);
003572  003900  // Usage : myvar := mem_AllocV(100);
003573  003901  // Notes : Allocate a block of memory to pointer myvar
003574  003902  //       : The block of memory is filled with signature values
003575  003903  //       : the block starts with A5,5A then fills with incrementing
003576  003904  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
003577  003905  //       : This can be helpful when debugging
003578  003906  //       : The block must later be released with mem_Free();
003579  003907  //       : returns 0 if function fails
003580  003908        
003581  003909  func mem_AllocZ("size"), 1;
003582  003910  // Syntax: mem_AllocZ(bytesize);
003583  003911  // Usage : myvar := mem_AllocC(100);
003584  003912  // Notes : Allocate a zeroed block of memory to pointer myvar
003585  003913  //       : The block of memory is filled with zeroes
003586  003914  //       : The block must later be released with mem_Free();
003587  003915  //       : returns 0 if function fails
003588  003916        
003589  003917  func mem_Realloc("ptr", "size"), 1;
003590  003918  // Syntax: myvar := mem_Realloc("ptr", "size");
003591  003919  // Usage : myvar := mem_Realloc(ptr, size);
003592  003920  // Notes : The function may move the memory block to a new location,
003593  003921  //       : in which case the new location is returned.
003594  003922  //       : The content of the memory block is preserved up to the lesser
003595  003923  //       : of the new and old sizes, even if the block is moved.
003596  003924  //       : If the new size is larger, the value of the newly allocated
003597  003925  //       : portion is indeterminate. In case that ptr is NULL,
003598  003926  //       : the function behaves exactly as mem_Alloc, assigning a new block
003599  003927  //       : of size bytes and returning a pointer to the beginning of it.
003600  003928  //       : In case that the size is 0, the memory previously allocated in
003601  003929  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
003602  003930  //       : pointer is returned.
003603  003931        
003604  003932  func mem_Free("allocation"), 1;
003605  003933  // Syntax: myvar := mem_Free(allocation);
003606  003934  // Usage : myvar := mem_Free(myvar);
003607  003935  // Notes : De-allocate a block of memory previously created with
003608  003936  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
003609  003937  //       : returns 0 if function fails
003610  003938        
003611  003939  func mem_Heap(), 1;
003612  003940  // Syntax: myvar := mem_Heap();
003613  003941  // Usage : myvar := mem_Heap();
003614  003942  // Notes : returns bytecount available in heap
003615  003943  //       :
003616  003944        
003617  003945  func mem_Set("ptr","char","size"), 1;
003618  003946  // Syntax: mem_Set(ptr,char,bytesize);
003619  003947  // Usage : mem_Set(p, 'A', 100);
003620  003948  // Notes : fill a block of memory with a byte value
003621  003949  //       : Note that count is a byte count, this facilitates
003622  003950  //       : clearing word aligned byte arrays when using word
003623  003951  //       : aligned packed strings.
003624  003952  //       : returns ptr
003625  003953        
003626  003954  func mem_Copy("src", "dest", "bytecount"), 1;
003627  003955  // Syntax: myvar := mem_Copy(src, dest, bytesize);
003628  003956  // Usage : myvar := mem_Copy(p1, p2, 100);
003629  003957  // Notes : copy a word aligned block of memory from src to dest
003630  003958  //       : Note that count is a byte count, this facilitates
003631  003959  //       : copying word aligned byte arrays when using word
003632  003960  //       : aligned packed strings.
003633  003961  //       : returns src
003634  003962        
003635  003963  func mem_Compare("ptr1","ptr2","count"), 1;
003636  003964  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
003637  003965  // Usage : myvar := mem_Compare(p1, p2, 100);
003638  003966  // Notes : compare word aligned blocks of memory at src, dest
003639  003967  //       : Note that count is a byte count, this facilitates
003640  003968  //       : comparing word aligned byte arrays when using word
003641  003969  //       : aligned packed strings.
003642  003970  //       : returns 0 if we have a match
003643  003971        
003644  003972  func __reserved53(), 0; // do not remove
003645  003973  func __reserved54(), 0; // do not remove
003646  003974        
003647  003975  //------------------------------------------------------------------//
003648  003976  //        FAT16 Function Prototypes
003649  003977  //------------------------------------------------------------------//
003650  003978        
003651  003979  func file_Error(), 1;
003652  003980  // Syntax: myvar := file_Error();
003653  003981  // Usage : e := file_Error();
003654  003982  // Notes : return the most recent file error.
003655  003983  //       :
003656  003984        
003657  003985  func file_Count("filename"), 1;
003658  003986  // Syntax: count := file_Count("filename");
003659  003987  // Usage : count := file_Count("*.4dg");
003660  003988  // Notes : returns number of files found that match the criteria
003661  003989        
003662  003990  func file_Dir("filename"), 1;
003663  003991  // Syntax: count := file_Dir("filename");
003664  003992  // Usage : count := file_Dir("*.4dg");
003665  003993  // Notes : streams a string of filenames that agree with the search key
003666  003994  //       : returns number of files found that match the criteria
003667  003995        
003668  003996  func file_FindFirst("fname"), 1;
003669  003997  // Syntax: res := file_FindFirst("fname");
003670  003998  // Usage : if (file_FindFirst("*.4xe") ....
003671  003999  // Notes : returns true if at least 1 file exists
003672  004000  //       : that satisfies the file argument.
003673  004001  //       : Wildcards are usually used so if
003674  004002  //       : file_FindFirst returns true, further
003675  004003  //       : tests can be made using file_FindNext();
003676  004004  //       : to find all the files that match the
003677  004005  //       : wildcard class. Note that the stream behaviour
003678  004006  //       : is the same as file_Dir.
003679  004007  //       :
003680  004008        
003681  004009  func file_FindNext(), 1;
003682  004010  // Syntax: res := file_FindNext();
003683  004011  // Usage : while ((file_FindNext()) ....
003684  004012  // Notes : returns true if more file exists
003685  004013  //       : that satisfies the file argument
003686  004014  //       : that was given for  file_FindFirst.
003687  004015  //       : Wildcards must be used for
003688  004016  //       : file_FindFirst, else this function will
003689  004017  //       : always return zero as the only occurence
003690  004018  //       : will have already been found.
003691  004019  //       : Note that the stream behaviour
003692  004020  //       : is the same as file_Dir.
003693  004021  //       :
003694  004022        
003695  004023  func file_Exists("fname"), 1;
003696  004024  // Syntax: res := file_Exists("fname"),
003697  004025  // Usage : if(file_Exists("myfile") ....
003698  004026  // Notes : returns true if file exists
003699  004027  //       :
003700  004028        
003701  004029  func file_Open("fname", "mode"), 1;
003702  004030  // Syntax: handle := file_Open("fname","mode"),
003703  004031  // Usage : handle := file_Open("myfile.txt", 'r');
003704  004032  // Notes : returns handle if file exists
003705  004033  //       :
003706  004034        
003707  004035  func file_Close("handle"), 1;
003708  004036  // Syntax: res := file_Close("handle");
003709  004037  // Usage : res := file_Close(hnd1);
003710  004038  // Notes : returns true if file closed ok
003711  004039  //       :
003712  004040        
003713  004041  func file_Read("*dest", "size", "handle"), 1;
003714  004042  // Syntax: res := file_Read("*dest", "size", "handle"),
003715  004043  // Usage : res := file_Read(memblock,20,hnd1);
003716  004044  // Notes : returns number of characters read
003717  004045  //       : if "dest" is zero, data is read direct to GRAM window
003718  004046  //       :
003719  004047        
003720  004048        
003721  004049  func file_Seek("handle", "HiWord", "LoWord"), 1;
003722  004050  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
003723  004051  // Usage : res := file_Seek(hSource, 0, 0x1234);
003724  004052  // Notes : set file position to 0x00001234 (byte position 4660)
003725  004053  //       : for the file handle so subsequent data may be read
003726  004054  //       : from that position onwards with file_GetC(...),
003727  004055  //       : file_GetW(...) or file_GetS(...), or an image
003728  004056  //       : can be displayed with file_Image(...)
003729  004057  // Notes : returns true if ok, usually ignored
003730  004058        
003731  004059  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
003732  004060  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
003733  004061  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
003734  004062  // Notes : set file seek position to 123000
003735  004063  //       : for the file handle so subsequent data may be read
003736  004064  //       : from that record position onwards with file_GetC(...),
003737  004065  //       : file_GetW(...) or file_GetS(...), or an image
003738  004066  //       : can be displayed with file_Image(...)
003739  004067  // Notes : returns true if ok, usually ignored
003740  004068        
003741  004069  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
003742  004070  // Syntax: file_Tell("handle", &HiWord, &LoWord);
003743  004071  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
003744  004072  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003745  004073  //       : returns true if function succeeded
003746  004074        
003747  004075  func file_Write("*source", "size", "handle"), 1;
003748  004076  // Syntax: res := fwrite("*source", "size", "handle"),
003749  004077  // Usage : res := fwrite(memblock, 20, hnd1);
003750  004078  // Notes : returns number of bytes written
003751  004079  //       :
003752  004080        
003753  004081  func file_Size("handle", "&HiWord", "&LoWord"), 1;
003754  004082  // Syntax: file_Size("handle", &HiWord, &LoWord);
003755  004083  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
003756  004084  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003757  004085  //       : returns true if function succeeded
003758  004086        
003759  004087  func file_Image("x", "y", "handle"), 1;
003760  004088  // Syntax: file_Image(x, y, handle);
003761  004089  // Usage : file_Image(10, 10, hnd1);
003762  004090  // Notes : Display an image from a file at the current file position.
003763  004091  //       : The image is displayed at x,y (with respect to top left corner).
003764  004092  //       : If there is more than 1 image in the file, it can be
003765  004093  //       : accessed with file_Seek(...)
003766  004094        
003767  004095  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
003768  004096  // Syntax: file_ScreenCapture(x, y, w, h, handle);
003769  004097  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
003770  004098  // Notes : Save a image from screen to file at the current file position.
003771  004099  //       : The image can later be displayed with file_Image(...);
003772  004100  //       : The file may be opened in append mode to accumulate multiple
003773  004101  //       : images. Later, the images can be accessed with file_Seek(...);
003774  004102  //       : Note that the image will be sector aligned.
003775  004103  //       : All image headers must start on a sector boundary.
003776  004104  //       : The image is saved from x, y (with respect to top left corner)
003777  004105  //       : and the capture area is determined by "width" and "height".
003778  004106  //       : returns 0 if function succeeded
003779  004107        
003780  004108  func file_PutC("char","handle"), 1;
003781  004109  // Syntax: file_PutC("char", "handle");
003782  004110  // Usage : file_PutC('x', hndl);
003783  004111  // Notes : returns true if function succeeded
003784  004112        
003785  004113  func file_GetC("handle"), 1;
003786  004114  // Syntax: file_GetC("handle");
003787  004115  // Usage : mychar := fgetC("handle");
003788  004116  // Notes : returns next char from file
003789  004117        
003790  004118  func file_PutW("word","handle"), 1;
003791  004119  // Syntax: file_PutW("word","handle");
003792  004120  // Usage : file_PutW(0x1234, hndl);
003793  004121  // Notes : returns true if function succeeded
003794  004122        
003795  004123  func file_GetW("handle"), 1;
003796  004124  // Syntax: file_GetW("handle");
003797  004125  // Usage : myword := fgetW("handle");
003798  004126  // Notes : returns next word in file
003799  004127        
003800  004128  func file_PutS("*source", "handle"), 1;
003801  004129  // Syntax: res := file_Puts("*source", "handle"),
003802  004130  // Usage : res := file_Puts(mystring, hnd1);
003803  004131  // Notes : returns number of characters written
003804  004132  //       :
003805  004133        
003806  004134  func file_GetS("*string", "size", "handle"), 1;
003807  004135  // Syntax: res := file_Gets("*string", "size", "handle");
003808  004136  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
003809  004137  // Notes : get a string from a file
003810  004138  //       : returns pointer to string or null if failed.
003811  004139  //       : file_GetS(...) automatically appends a null-terminator to the data read.
003812  004140  //       : NB:- only reads up to "size-1" characters into "string"
003813  004141  //       : file_GetS(...) will stop reading when any of the following conditions are true:
003814  004142  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003815  004143  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003816  004144  //       : C] It reaches the end of file
003817  004145  //       : D] A read error occurs.
003818  004146        
003819  004147        
003820  004148  func file_Erase("fname"), 1;
003821  004149  // Syntax: res := file_Erase("fname");
003822  004150  // Usage : res := file_Erase("myfile.txt");
003823  004151  // Notes : returns true if successful
003824  004152  //       :
003825  004153        
003826  004154  func file_Rewind("handle"), 1;
003827  004155  // Syntax: res := file_Rewind("handle");
003828  004156  // Usage : res := file_Rewind(hnd1);
003829  004157  // Notes : returns true if file rewound ok (usually ignored)
003830  004158  //       : resets the file pointer the the beginning of the open file.
003831  004159        
003832  004160  func file_LoadFunction("fname.4xe"), 1;
003833  004161  // Syntax: res := file_LoadFunction("fname.4fn");
003834  004162  // Usage : myfunc := file_LoadFunction(myfuncname);
003835  004163  // Notes : Load a function or program from disk and
003836  004164  //       : return a function pointer to the allocation.
003837  004165  //       : The function can then be invoked just like any other
003838  004166  //       : function would be called via a function pointer.
003839  004167  //       : Parameters may be passed to it in a conventional way.
003840  004168  //       : The function may be discarded at any time when no
003841  004169  //       : longer required, thus freeing its memory resources.
003842  004170  //       : The loaded function can be discarded with mem_Free(..)
003843  004171  //       : eg:
003844  004172  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
003845  004173  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003846  004174  //       : then elsewhere in your program:-
003847  004175  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003848  004176  //       : if(res == QUIT_APPLICATION) goto exitApp;
003849  004177  //       : Later in your program, when popupWindow is no longer
003850  004178  //       : required for the application:-
003851  004179  //       : res := mem_Free(popupWindow);
003852  004180  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003853  004181  //       : The callers stack is shared by the loaded function,
003854  004182  //       : however any global variables in the loaded function
003855  004183  //       : are private to that function.
003856  004184  //
003857  004185        
003858  004186  func file_Run("fname.4xe", "arglistptr"), 1;
003859  004187  // Syntax: res := file_Run("fname.4xe","arglistptr");
003860  004188  // Usage : res := file_Run(fname, argptr);
003861  004189  // Notes : current program releases any allocated memory but
003862  004190  //       : retains the stack and global memory.
003863  004191  //       : If arglistptr is 0, no arguments are passed, else
003864  004192  //       : arglist points to an array, the first element being
003865  004193  //       : the number of elements in the array.
003866  004194  //       : func 'main' in the called program accepts
003867  004195  //       : the arguments, if any. The arguments can only
003868  004196  //       : be passed by value, no pointers or references can be
003869  004197  //       : used as all memory is cleared before the file
003870  004198  //       : is loaded. Refer to file_Exec and file_LoadFunction
003871  004199  //       : for functions that can pass by reference.
003872  004200        
003873  004201  func file_Exec("fname.4xe", "arglistptr"), 1;
003874  004202  // Syntax: res := file_Exec("fname.4xe","arglistptr");
003875  004203  // Usage : res := file_Exec("fname.4xe","arglistptr");
003876  004204  // Notes : returns like a function, current program
003877  004205  //       : calling program is kept active and control returns to it.
003878  004206  //       : If arglistptr is 0, no arguments are passed, else
003879  004207  //       : arglist points to an array, the first element being
003880  004208  //       : the number of elements in the array.
003881  004209  //       : func 'main' in the called program accepts the arguments.
003882  004210  //       : This function is similar to file_LoadFunction(...), however,
003883  004211  //       : the function argument list is passed by pointer, and
003884  004212  //       : the memory consumed by the function is released as
003885  004213  //       : soon as the function completes.
003886  004214        
003887  004215  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
003888  004216  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
003889  004217  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
003890  004218  // Notes : Reads a control file to create an image list.
003891  004219  //       : Returns NULL if function fails.
003892  004220  //       : Returns a handle (pointer to the memory allocation) to the
003893  004221  //       : image control list that has been created.
003894  004222  //       : "fname1" is the control list filename "*.dat"
003895  004223  //       : "fname2" is the image filename "*.gci"
003896  004224        
003897  004225  // Notes : This function Calculates the size of a chunk of memory required for
003898  004226  //       : a image list and populates it from the image control file ("*.dat")
003899  004227  //       : therefore, when imagelist is no longer required, you must de-allocate
003900  004228  //       : the image list memory by using eg:- mem_Free(hImagelist);
003901  004229  //       : to restore the heap.
003902  004230  //       :
003903  004231  //       : mode 0:- it is assumed that there is a graphics file with the
003904  004232  //       : file extension "fname2.gci". In this case, the images have been stored
003905  004233  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
003906  004234  //       : "fname1.dat" file are saved in the image control so that the image control
003907  004235  //       : can open the file (*.gci) and us file_Seek to get to the position of the
003908  004236  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
003909  004237  //       : mode 0 builds the image control quickly as it only scans the *.dat file
003910  004238  //       : for the file offsets and save them in the relevant entries in the image control.
003911  004239  //       : The penalty is that images take longer to find when displayed due to file_Seek
003912  004240  //       : overheads.
003913  004241  //
003914  004242  //       : mode 1:- it is assumed that there is a graphics file with the
003915  004243  //       : file extension "fname2.gci". In this case, the images have been stored
003916  004244  //       : in a FAT16 file concurrently, and the offset of the images are saved
003917  004245  //       : in the image control so that image file (*.gci) can be mapped to directly.
003918  004246  //       : The absolute cluster/sector is mapped so file seek does not need to be called
003919  004247  //       : internally. This means that there is no seek time penalty, however, the
003920  004248  //       : image list takes a lot longer to build, as all the seeking is done at control
003921  004249  //       : build time.
003922  004250        
003923  004251  //       : mode 2:- the graphics file with the is placed in a partitioned area
003924  004252  //       : In this case, the images have been stored in a in a known raw area of the FAT16
003925  004253  //       : disk, and the absolute address of the images are saved in the DAT file
003926  004254  //       : This is the fastest operation of the image control as there is no seeking
003927  004255  //       : or other disk activity taking place.
003928  004256        
003929  004257  func file_Mount(), 1;
003930  004258  // Syntax: r := file_Mount();
003931  004259  // Usage : r := file_Mount();
003932  004260  // Notes : Create a control block for FAT16 and mount the File System
003933  004261        
003934  004262  func file_Unmount(), 0;
003935  004263  // Syntax: file_Unmount();
003936  004264  // Usage : file_Unmount();
003937  004265  // Notes : release any control block and buffers for FAT16
003938  004266  //       : and unmount the File System
003939  004267        
003940  004268  func file_PlayWAV("fname1"), 1;
003941  004269  // Syntax: file_PlayWAV("fname1");
003942  004270  // Usage : file_PlayWAV("ding.wav");
003943  004271  // Notes : Play a wave file with filename "fname1"
003944  004272  //       : This function automatically grabs a chunk
003945  004273  //       : of memory for a file buffer, and a wave
003946  004274  //       : buffer. The minimum memory requirement is
003947  004275  //       : about 580 bytes for the disk io service and
003948  004276  //       : a minimum wave buffer size of 1024. The siz
003949  004277  //       : of the wave buffer allocation
003950  004278  //       : can be increased by the snd_BufSize function.
003951  004279  //       : The default size 1024 bytes.
003952  004280  //       : NB the memory is only required during the
003953  004281  //       : duration of play, and is automatically
003954  004282  //       : released while not in use.
003955  004283  //       : See the Sound Class services for other associated controls.
003956  004284  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003957  004285  //       : If errors occured, the folling is returned
003958  004286  //       : -7  : Insufficient memory available for WAV buffer and file
003959  004287  //       : -6  : cant play this rate
003960  004288  //       : -5  : no data chunk found in first rsector
003961  004289  //       : -4  : no format data
003962  004290  //       : -3  : no wave chunk signature
003963  004291  //       : -2  : bad wave file format
003964  004292  //       : -1  : file not found
003965  004293        
003966  004294  func file_Rename("fname1", "fname2"), 1;     // rename a file
003967  004295  // Syntax: file_Rename ("oldname", "newname"),
003968  004296  // Usage : file_Rename ("file.txt", "file.bak");
003969  004297  // Notes : Renames a file on uSD.
003970  004298  //       : Returns FALSE if function fails. (file does not exist, or new filename already exists)
003971  004299  //       : Returns TRUE, if successful.
003972  004300        
003973  004301  func file_SetDate("handle", "year", "month", "day", "hour", "Minute", "Second") , 1; // Sets date and time for an open file
003974  004302  // Syntax: res := file_SetDate("handle", "year", "month", "day", "hour", "Minute", "Second) ;
003975  004303  // Usage : res := file_SetDate(hndl, 2014, 10, 31, 10, 0, 0)
003976  004304  // Notes : year is a 4 digit year
003977  004305  //       : Due to limitations of FAT16 only even seconds are stored
003978  004306  //       : The handle must be closed before the file information is updated
003979  004307  //       : returns TRUE if date + time + handle valid
003980  004308  //       : returns FLAST if handle invalid, or date or time not valid (only simple checking performed).
003981  004309        
003982  004310  func __reserved57(), 0; // do not remove
003983  004311  func __reserved58(), 0; // do not remove
003984  004312        
003985  004313  //------------------------------------------------------------------------------
003986  004314  // FILEIO Error Code Constants
003987  004315  //------------------------------------------------------------------------------
003988  004316  #CONST
003989  004342  #END
003990  004343        
003991  004344  //------------------------------------------------------------------------------
003992  004345  // DISK struct offsets
003993  004346  //------------------------------------------------------------------------------
003994  004347  #CONST
003995  004364  #END
003996  004365        
003997  004366  //------------------------------------------------------------------------------
003998  004367  // FILE struct offsets
003999  004368  //------------------------------------------------------------------------------
004000  004369  #CONST
004001  004388  #END
004002  004389        
004003  004390        
004004  004391  //------------------------------------------------------------------//
004005  004392  //        Sound Class Services
004006  004393  //------------------------------------------------------------------//
004007  004394        
004008  004395  func snd_Volume("var"), 0;
004009  004396  // Syntax: snd_Volume("var");
004010  004397  // Usage : snd_Volume(30);
004011  004398  // Notes : set sound playback volume.  Var must
004012  004399  //       : be in the range from 8 (min volume)
004013  004400  //       : to 127 (max volume). If var is less
004014  004401  //       : than 8 volume is set to 8, and if
004015  004402  //       : var > 127 it is set to 127.
004016  004403        
004017  004404  func snd_Pitch("pitch"), 1;
004018  004405  // func snd_Pitch("freq"), 1;
004019  004406  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
004020  004407  // Notes : sets the samples playback rate to a different frequency
004021  004408  //       : The minimum value is 4khz
004022  004409  //       : Setting the pitch to zero restores the original sample rate
004023  004410  //       : Return value is the samples original sample rate.
004024  004411        
004025  004412  func snd_BufSize("var"), 0;
004026  004413  // Syntax: snd_BufSize("var");
004027  004414  // Usage : snd_BufSize(2);
004028  004415  // Notes : specify the a memory chunk size for the wavefile buffer.
004029  004416  //       : default size 1024 bytes.
004030  004417  //       : 0 = 1024 bytes (default)
004031  004418  //       : 1 = 2048 bytes
004032  004419  //       : 2 = 4096 bytes
004033  004420  //       : 3 = 8192 bytes
004034  004421        
004035  004422  func snd_Stop(), 0;
004036  004423  // Syntax: snd_Stop();
004037  004424  // Usage : snd_Stop();
004038  004425  // Notes : stop any sound that is playing, releasing
004039  004426  //       : buffers and closes any open wav file.
004040  004427        
004041  004428  func snd_Pause(), 0;
004042  004429  // Syntax: snd_Pause();
004043  004430  // Usage : snd_Pause();
004044  004431  // Notes : pauses any sound that is playing, does nothing
004045  004432  //       : until sound is resumed with snd_Continue().
004046  004433  //       : The sample cam be terminated with snd_Stop.
004047  004434  //       : buffers and closes any open wav file.
004048  004435        
004049  004436  func snd_Continue(), 0;
004050  004437  // Syntax: snd_Continue();
004051  004438  // Usage : snd_Continue();
004052  004439  // Notes : resume any sound that is paused by snd_Pause.
004053  004440        
004054  004441  func snd_Playing(), 1;
004055  004442  // Syntax: snd_Playing();
004056  004443  // Usage : r := snd_Playing();
004057  004444  // Notes : returns 0 if sound has finished playing,
004058  004445  //       : else return number of 512 byte blocks to go.
004059  004446        
004060  004447  func snd_Freq("Freq", "Duration"), 1;
004061  004448  // Syntax: snd_Freq("Freq", "Duration");
004062  004449  // Usage : r := snd_Freq(1000, 2000);
004063  004450  // Notes : Returns 0 if note cannot be played because a wav file is playing
004064  004451  //       : else return True.
004065  004452  //       : Minimum Freq is 20
004066  004453  //       : This will produce a pure Square wave and is designed for driving
004067  004454  //       : Piezo transducers which require this sort of drive. It can also be
004068  004455  //       : used to drive the amp on displays with audio.
004069  004456        
004070  004457        
004071  004458  func __reserved60(), 0; // do not remove
004072  004459  func __reserved61(), 0; // do not remove
004073  004460  func __reserved62(), 0; // do not remove
004074  004461        
004075  004462  //=========================================================================================================
004076  004463  // String functions
004077  004464  //=========================================================================================================
004078  004465        
004079  004466  func str_Ptr("&var"), 1;
004080  004467  // Syntax: str_Ptr(&var);
004081  004468  // Usage : p := str_Ptr(&var);
004082  004469  // Notes : return a byte pointer to a word region
004083  004470        
004084  004471  func str_GetD("&ptr", "&var"), 1;
004085  004472  // Syntax: str_GetD(&ptr, &var);
004086  004473  // Usage : ok := str_GetD(&ptr, &var);
004087  004474  // Notes : convert number in a string to DWORD ( myvar[2] )
004088  004475  //       : returns true if function succeeds, advancing ptr
004089  004476        
004090  004477  func str_GetW("&ptr", "&var"), 1;
004091  004478  // Syntax: str_GetW(&ptr, &var);
004092  004479  // Usage : ok := str_GetW(&ptr, &var);
004093  004480  // Notes : convert number in a string to WORD ( myvar )
004094  004481  //       : returns true if function succeeds, advancing ptr
004095  004482        
004096  004483  func str_GetHexW("&ptr", "&var"), 1;
004097  004484  // Syntax: str_GetHexW(&ptr, &var);
004098  004485  // Usage : ok := str_GetHexW(&ptr, &var);
004099  004486  // Notes : convert HEX number in a string to WORD ( myvar )
004100  004487  //       : returns true if function succeeds, advancing ptr
004101  004488        
004102  004489  func str_GetC("&ptr", "&var"), 1;
004103  004490  // Syntax: str_GetC(&ptr, &var);
004104  004491  // Usage : ok := str_GetC(&ptr, &var);
004105  004492  // Notes : get a valid ascii char in a string to WORD ( myvar )
004106  004493  //       : returns true if function succeeds, advancing ptr
004107  004494        
004108  004495  func str_GetByte("ptr"), 1;
004109  004496  // Syntax: str_GetByte(ptr);
004110  004497  // Usage : myvar := str_GetByte(ptr);
004111  004498  // Notes : get a byte to myvar
004112  004499  //       : returns value
004113  004500        
004114  004501  func str_GetWord("ptr"), 1;
004115  004502  // Syntax: GetWord(ptr);
004116  004503  // Usage : GetWord(ptr);
004117  004504  // Notes : get a word to myvar
004118  004505  //       : returns value
004119  004506        
004120  004507  func str_PutByte("ptr","val"), 0;
004121  004508  // Syntax: str_PutByte(ptr);
004122  004509  // Usage : myvar := str_PutByte(ptr);
004123  004510  // Notes : put a byte at ptr
004124  004511  //       : returns value
004125  004512        
004126  004513  func str_PutWord("ptr","val"), 0;
004127  004514  // Syntax: str_PutWord("ptr","val");
004128  004515  // Usage : str_PutWord(p,100);
004129  004516  // Notes : put word 100 at current pointer location
004130  004517  //       : returns value
004131  004518        
004132  004519  func str_Match("&ptr", "*str"), 1;
004133  004520  // Syntax: str_Match(&ptr, *str);
004134  004521  // Usage : r := str_Match(&p, "hello");
004135  004522  // Notes : Case sensitive match
004136  004523  //       : returns true if function succeded, andvancing pointer to position past
004137  004524  //       : the matched item. Note that any whitespace characters are skipped
004138  004525  //       : in the source string prior to the test.
004139  004526        
004140  004527  func str_MatchI("&ptr", "*str"), 1;
004141  004528  // Syntax: str_MatchI(&ptr, *str);
004142  004529  // Usage : r := str_MatchI(&p, "hello");
004143  004530  // Notes : Case insensitive match
004144  004531  //       : returns true if function succeded, andvancing pointer to position past
004145  004532  //       : the matched item. Note that any whitespace characters are skipped
004146  004533  //       : in the source string prior to the test.
004147  004534        
004148  004535  func str_Find("&ptr", "*str"), 1;
004149  004536  // Syntax: str_Find(&ptr, *str);
004150  004537  // Usage : n := str_Find(&p, "hello");
004151  004538  // Notes : given the address of a pointer to a source string as the
004152  004539  //       : first argument, and a pointer to a test string as the second
004153  004540  //       : argument, attempt to find the position of the matching string
004154  004541  //       : in the source string. The test is performed with case sensitivity.
004155  004542  //       : return 0 if not found, else returns the address of the first
004156  004543  //       : character of the match. NB:- The source pointer is not altered.
004157  004544        
004158  004545  func str_FindI("&ptr", "*str"), 1;
004159  004546  // Syntax: str_Find(&ptr, *str);
004160  004547  // Usage : n := str_Find(&p, "hello");
004161  004548  // Notes : given the address of a pointer to a source string as the
004162  004549  //       : first argument, and a pointer to a test string as the second
004163  004550  //       : argument, attempt to find the position of the matching string
004164  004551  //       : in the source string. The test is performed with no case
004165  004552  //       : sensitivity, eg upper and lower case chars are accepted.
004166  004553  //       : return 0 if not found, else returns the address of the first
004167  004554  //       : character of the match. NB:- The source pointer is not altered.
004168  004555        
004169  004556  func str_Length("ptr"), 1;
004170  004557  // Syntax: str_Length(ptr);
004171  004558  // Usage : len := str_Ptr(mystring);
004172  004559  // Notes : return the length of a byte aligned string excluding terminator
004173  004560        
004174  004561  func str_Printf("&ptr", "*format"), 1;
004175  004562  // Syntax: str_Printf("&ptr", "*format");
004176  004563  // Usage : r := str_Printf(&p, "hello");
004177  004564  // Notes : refer to documentation
004178  004565  //       :
004179  004566        
004180  004567  func str_Cat("dest","src"), 1;
004181  004568  // Syntax: str_Append("&dest","&src");
004182  004569  // Usage : str_Append(&buf,"Hello");
004183  004570  // Notes : Appends a copy of the source string to the destination string.
004184  004571  //       : The terminating null character in destination is overwritten by
004185  004572  //       : the first character of source, and a new null-character is appended
004186  004573  //       : at the end of the new string formed by the concatenation of both in destination.
004187  004574  //       : returns destination.
004188  004575        
004189  004576  func str_CatN("dest","src","count"), 1;
004190  004577  // Syntax: str_Append("&dest","&src","count");
004191  004578  // Usage : str_Append(&buf,"Monday",3);
004192  004579  // Notes : Appends a copy of the source string to the destination string.
004193  004580  //       : The number of characters copied is limited by "count".
004194  004581  //       : The terminating null character in destination is overwritten by
004195  004582  //       : the first character of source, and a new null-character is appended
004196  004583  //       : at the end of the new string formed by the concatenation of both in destination.
004197  004584  //       : returns destination.
004198  004585        
004199  004586        
004200  004587  func str_ByteMove("src", "dest", "count"), 1;
004201  004588  // Syntax   : str_ByteMove(src, dest, bytecount);
004202  004589  // Input    : STR *source points to byte aligned source.
004203  004590  //          : STR *dest   points to byte aligned destination.
004204  004591  //          : VAR count   number of bytes to transfer.
004205  004592  // Usage    : nextpos := str_ByteMove(s, d, 100);
004206  004593  // Notes    : copy bytes from "src" to "dest", stopping only
004207  004594  //          : when "count" is exhausted.
004208  004595  //          : No terminator is appended, it is purely a
004209  004596  //          : byte copy, and any zeroes encountered will
004210  004597  //          : also be copied.
004211  004598  // Returns  : returns a pointer to the end of the destination
004212  004599  //          : (which is "dest" + "count")
004213  004600        
004214  004601        
004215  004602  func str_Copy("dest", "src"), 1;
004216  004603  // Syntax   : str_Copy(dest, src);
004217  004604  // Input    : STR *dest   points to byte aligned destination.
004218  004605  //          : STR *source points to byte aligned source.
004219  004606  // Usage    : nextplace := str_Copy(d, s);
004220  004607  // Notes    : copy a string from "src" to "dest", stopping only
004221  004608  //          : when the end of source string "src" is encountered
004222  004609  //          : (0x00 terminator).
004223  004610  //          : The terminator is always appended, even if "src" is
004224  004611  //          : an empty string.
004225  004612  // Returns  : returns a pointer to the 0x00 string terminator at
004226  004613  //          : end of "dest" (which is "dest" + str_Length(src); )
004227  004614        
004228  004615        
004229  004616  func str_CopyN("dest", "src", "count"), 1;
004230  004617  // Syntax   : str_CopyN(dest, src, bytecount);
004231  004618  // Input    : STR *dest   points to byte aligned destination.
004232  004619  //          : STR *source points to byte aligned source.
004233  004620  //          : VAR count   max number of chars to copy.
004234  004621  // Usage    : nextplace := str_CopyN(d, s, 100);
004235  004622  // Notes    : copy a string from "src" to "dest", stopping only
004236  004623  //          : when "count" is exhausted, or end of source
004237  004624  //          : string "str" is encountered (0x00 string terminator).
004238  004625  //          : The terminator is always appended, even if
004239  004626  //          : "count" is zero, or "src" is a null string.
004240  004627  // Returns  : returns a pointer to the 0x00 string terminator
004241  004628  //          : (which is "dest" + whatever was copied)
004242  004629        
004243  004630        
004244  004631  func __reserved63(), 0; // do not remove
004245  004632  func __reserved64(), 0; // do not remove
004246  004633  func __reserved65(), 0; // do not remove
004247  004634  func __reserved66(), 0; // do not remove
004248  004635        
004249  004636  //=========================================================================================================
004250  004637  // FLASH memory functions
004251  004638  //=========================================================================================================
004252  004639  func flash_GetByte("bank", "ptr"), 1;
004253  004640  // Syntax   : flash_GetByte(bank, ptr);
004254  004641  // Usage    : myvar := flash_GetByte(FLASHBANK_2, 0x0017); // read first byte in data statement of bank 2
004255  004642  // Notes    : Reads a single byte from any flash location.
004256  004643  //          : If the bank is read protected, only the first 2 bytes can be read (0x55, 0xAA)
004257  004644  //          : which is the header signature for a valid program.
004258  004645  // Returns  : the byte value from the location
004259  004646        
004260  004647        
004261  004648  func flash_GetWord("bank", "ptr"), 1;
004262  004649  // Syntax   : flash_GetWord(bank, ptr);
004263  004650  // Usage    : myvar := flash_GetWord(FLASHBANK_2, 0x0000); // read first word in flash bank  (0xAA55)
004264  004651  // Notes    : Reads a single word from any flash location.
004265  004652  //          : The pointer is byte aligned.
004266  004653  //          : If the bank is read protected, only the first word can be read
004267  004654  //          : which is the header signature for a valid program (0xAA55).
004268  004655  // Returns  : the byte value from the location
004269  004656        
004270  004657        
004271  004658  func flash_Copy("bank", "ptr", "dest", "count"), 1;
004272  004659  // Syntax   : flash_Copy(bank, ptr);
004273  004660  // Usage    : myvar := flash_Copy(FLASHBANK_2, 0x1234, mybuf, 20); // read 20 bytes from FLASHBANK_2 starting from 0x1234
004274  004661  // Notes    : Copies bytes from any flash locations to a user buffer.
004275  004662  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
004276  004663  //          : If the bank is read protected, 0 bytes will be read
004277  004664  //          : which is the header signature for a valid program (0xAA55).
004278  004665  // Returns  : the count of bytes transferred.
004279  004666        
004280  004667        
004281  004668  func flash_Run("bank"), 1;
004282  004669  // Syntax    : flash_Run(bankx);
004283  004670  // Usage     : res := flash_Run(FLASHBANK_5);
004284  004671  // Notes     : Restarts the processor, running code from the required
004285  004672  //           : flash bank. bank may be a variable, or one of the
004286  004673  //           : pre-defined constants:-
004287  004674  //           :    FLASHBANK_0                 //0x00
004288  004675  //           :    FLASHBANK_1                 //0x01
004289  004676  //           :    FLASHBANK_2                 //0x02
004290  004677  //           :    FLASHBANK_3                 //0x03
004291  004678  //           :    FLASHBANK_4                 //0x04
004292  004679  //           :    FLASHBANK_5                 //0x05
004293  004680  // returns    : This function should net return as it restarts
004294  004681  //        : the processor and jumps to the required bank,
004295  004682  //        : If it does return, -1 indicates incorrect/invalid
004296  004683  //        : bank number, and -2 indicates no valid program
004297  004684  //        : in the selected bank.
004298  004685        
004299  004686  func flash_Bank(), 1;
004300  004687  // Syntax   : flash_Bank();
004301  004688  // Usage    : myvar := flash_Bank();
004302  004689  // Notes    : Identifies which flash bank the code is running from.
004303  004690  // Returns  : The FLASH bank that code is currently running from, 0-5.
004304  004691        
004305  004692        
004306  004693  func flash_EraseBank("bank", "confirmation"), 1;
004307  004694  // Syntax   : flash_EraseBank(bank, confirmation);
004308  004695  // Usage    : result := flash_EraseBank(FLASHBANK_3, 0xDEAD); // erase an entire flash bank, confirm overwrite of protected program
004309  004696  // Notes    : This function should be used with extreme caution.
004310  004697  //          : The selected bank will be completely erased regardless of FLASH_WRITE_PROTECT status
004311  004698  //          : if the confirmation value is set to hex 0xDEAD. If confirmation is any other value,
004312  004699  //          : a protected bank will not be erased, and function will return with 0
004313  004700  //          : If the destination bank is the same as the execution bank, the processor will reset
004314  004701  //          : upon completion of erase. If the "bank" argument is set to ALL (-1) and confirmation is set to 0xDEAD
004315  004702  //          : FLASHBANK_0 thru FLASHBANK_5 are cleared.
004316  004703  //          : Used with caution, this is a good way to 'clean up' the entire flash when starting new projects.
004317  004704  // Returns  : returns true if the function succeeded
004318  004705  //          : NB:- reset processor if program is erasing itself, or the ALL bank option is selected.
004319  004706        
004320  004707  func flash_LoadFile("bank", "filename"), 1;
004321  004708  // Syntax   : flash_LoadFile(bank, ptr);
004322  004709  // Usage    : result := flash_LoadFile(FLASHBANK_2, "TETRIS10.EXE"); // load the file from disk into FLASHBANK_2
004323  004710  // Notes    : Copies a file from uSD to the required flashbank.
004324  004711  //          : The destination bank cannont be the execution bank, or a bank that is write protected
004325  004712  // Returns  : returns true if the function succeeded.
004326  004713        
004327  004714        
004328  004715  func flash_WriteBlock("sourceptr", "bank", "page"), 1;
004329  004716  // Syntax   : flash_WriteBlock(pbuf, bank, page);
004330  004717  // Usage    : result := flash_WriteBlock(buffer, FLASHBANK_5, 8); // store the 2k buffer to FLASHBANK_5, location 16384
004331  004718  // Notes    : Copies a 2kbyte buffer to the required flashbank in block 0-15.
004332  004719  //          : The address of each block is 0, 2048, 4096 etc, determined by the page number 0-15.
004333  004720  //          : The destination bank cannot be an execution bank, or a program bank that is write protected.
004334  004721  // Returns  : returns true if the function succeeded.
004335  004722        
004336  004723        
004337  004724  func flash_putstr("bank", "ptr"), 1;
004338  004725  // Syntax   : flash_putstr(bank, ptr);
004339  004726  // Usage    : flash_Copy(FLASHBANK_2, 350); // print a string from FLASHBANK_2, location 350
004340  004727  // Notes    : Works the same as putstr, however, the source of the asciiz string is in FLASH storage
004341  004728  //          : Output may be redirected with the to(..) function. Bit15 of ptr is assumed 0.
004342  004729  // Returns  : True if function succeeds, usually ignored. 0 if bank is read protected
004343  004730        
004344  004731  func flash_Blit16("bank", "offset", "count"), 1;
004345  004732  // Syntax   : flash_Blit16(bank, offset, pixelcount);
004346  004733  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit16(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (800 bytes)
004347  004734  // Notes    : Blit an image to a GRAM window from FLASH storage.
004348  004735  //          : Image is stored 16bits per pixel (565) in a linear fashion to suit the GRAM mechanism
004349  004736  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004350  004737        
004351  004738  func flash_Blit8("bank", "offset", "count"), 1;
004352  004739  // Syntax   : flash_Blit8(bank, offset, pixelcount);
004353  004740  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit8(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (400 bytes)
004354  004741  // Notes    : Blit an image to a GRAM window from FLASH storage.
004355  004742  //          : Image is stored 8 bits per pixel (332 format) in a linear fashion to suit the GRAM mechanism
004356  004743  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004357  004744        
004358  004745  func flash_Blit4("bank", "offset", "count", "palette16colour"), 1;
004359  004746  // Syntax   : flash_Blit16(bank, offset, pixelcount, pal16);
004360  004747  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit4(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (200 bytes packed 4:4)
004361  004748  // Notes    : Blit an image to a GRAM window from FLASH storage.
004362  004749  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 16 x 16bit colours
004363  004750  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004364  004751        
004365  004752  func flash_Blit2("bank", "offset", "count", "palette4colour"), 1;
004366  004753  // Syntax   : flash_Blit16(bank, offset, pixelcount, pal4);
004367  004754  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit2(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (100 bytes packed 2:2:2:2)
004368  004755  // Notes    : Blit an image to a GRAM window from FLASH storage.
004369  004756  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 4 x 16bit colours
004370  004757  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004371  004758        
004372  004759  func flash_Blit1("bank", "offset", "count", "pallete2colour"), 1;
004373  004760  // Syntax   : flash_Blit1(bank, offset, pixelcount, pal2);
004374  004761  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit1(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (50 bytes packed 1:1:1:1:1:1:1:1)
004375  004762  // Notes    : Blit an image to a GRAM window from FLASH storage.
004376  004763  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 2 x 16bit colours
004377  004764  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004378  004765        
004379  004766  func flash_Exec("bank", "arglistptr"), 1;
004380  004767  // Syntax: res := flash_Exec("bank","arglistptr");
004381  004768  // Usage : res := flash_Exec("bank","arglistptr");
004382  004769  // Notes : returns like a function, current program
004383  004770  //       : calling program is kept active and control returns to it.
004384  004771  //       : If arglistptr is 0, no arguments are passed, else
004385  004772  //       : arglist points to an array, the first element being
004386  004773  //       : the number of elements in the array.
004387  004774  //       : func 'main' in the called bank accepts the arguments.
004388  004775  // WARNING Not currently implemented!
004389  004776        
004390  004777        
004391  004778  func __reserved68(), 0; // do not remove
004392  004779  func __reserved69(), 0; // do not remove
004393  004780  func __reserved70(), 0; // do not remove
004394  004781        
004395  004782  //=========================================================================================================
004396  004783  // I/O and hardware functions
004397  004784  //=========================================================================================================
004398  004785        
004399  004786        
004400  004787        
004401  004788        
004402  004789  func pin_Pulseout("pin", "value"), 1;        // non blocking (program execution continues during pulse)
004403  004790  func pin_PulseoutB("pin", "value"), 1;    // blocking (program execution suspended during pulse)
004404  004791  // Syntax: pin_Pulseout(pin, value);
004405  004792  // Usage : pin_Pulseout(PA3, 100);                 // output 100msec pulse on PA3
004406  004793  // Notes : only available on PA0 to PA9
004407  004794  //       : Invert the state of an output for "value" milliseconds.
004408  004795  //       : pulseout is non blocking, that is, code execution may continue while
004409  004796  //       : a pulse is occuring, and pulses can occur on multiple pins simultaneously.
004410  004797  //       : If not already an output, pin is automatically made a push/pull output,
004411  004798  //       : and the last state of its output latch will determine pulse polarity.
004412  004799  //       : It's its open drain state is not altered if the pin was already an output.
004413  004800  //       : If pulseout is called while pulseout is still active, the pulse timer
004414  004801  //       : will simply be updated with the new "value" and the pulse will continue
004415  004802  //       : with the extended value.
004416  004803  //       : returns true if the pin number is legal (usually ignored)
004417  004804        
004418  004805        
004419  004806  func pin_Counter("pin", "mode", "OVFfunction"), 1;
004420  004807  // Syntax: pin_Counter(pin, mode, userfunc);
004421  004808  // Usage : pin_Counter(PA5, 1, stopfunc);         // count rising edge pulses on pin PA5, call stopfunc on overflow
004422  004809  // Notes : only available on PA4 to PA9
004423  004810  //       : Connect a counter to a pin to count transistions, and optionally call an event function
004424  004811  //       : when the 16bit counter wraps from 0xFFFF to zero. The counter can be read or written
004425  004812  //       : to at any time with peekW and pokeW, therefore, the count may be set to eg 0xFFF0 so that eg:
004426  004813  //       : user function "OVFfuction" will be called after 16 pulses. If "OVFfunction" is set to zero, only the
004427  004814  //       : counter will increment, and simply wrap back to zero from 0xFFFF. If "OVFfunction" points to a user
004428  004815  //       : function, wnen the event fires, pin_Counter will be disabled, and will need to be re-armed (ie '1shot' operation)
004429  004816  //       : The pin may be configured as an input or output, the function behaves the same.
004430  004817  //       : All six pin counters may be active simultaneously, and the maximum frequency of pin transistions
004431  004818  //       : should not exceed a few Khz in mode 1 and 2and are usually used for simple process control counting.
004432  004819  //       : "mode" has the following effect:-
004433  004820  //       : mode COUNT_OFF(0)  = disconnect the counter from the pin, "OVFfunction" therefore ignored, and counting is inhibited.
004434  004821  //       : mode COUNT_RISE(1) = increment on every rising edge
004435  004822  //       : mode COUNT_FALL(2) = increment on every falling edge
004436  004823  //       : mode COUNT_EDGE(3) = increment on every rising and falling edge
004437  004824        
004438  004825  //------------------------------------------------------------------//
004439  004826  // pin counter mode constants                                       //
004440  004827  //------------------------------------------------------------------//
004441  004828  #CONST
004442  004833  #END
004443  004834        
004444  004835  func Qencoder1("PHApin", "PHBpin", "mode"), 1;
004445  004836  // Syntax: Qencoder1(pinA, pinB, mode);
004446  004837  // Usage : Qencoder1(PA4, PA5, stopfunc);         // connect PA4 and PA5 pins to qudrature encoder module #1
004447  004838  // Notes : not available on pins PA14 and PA15
004448  004839  //       : Connect a quadrature encoder to a pair of pins The position counter and delta can be read
004449  004840  //       : or written to at any time with peekW and pokeW using the following constants:-
004450  004841  //       : It is necessary to configure the pins first, depending on your requirements, eg
004451  004842  //       :           pin_Set(PIN_INP_HI, PA4);     // PA4 as input, with pullup to Vcc
004452  004843  //       : or maybe  pin_Set(PIN_INP, PA4);        // PA4 as input, no pullup or pulldown
004453  004844  //       : Returns true if the pin numbers are legal (usually ignored)
004454  004845  //    QEN1_COUNTER_LO
004455  004846  //    QEN1_COUNTER_HI
004456  004847  //    QEN1_DELTA This is reset to 0 when read
004457  004848        
004458  004849  func Qencoder2("PHApin", "PHBpin", "mode"), 1;
004459  004850  // Syntax: Qencoder2(pinA, pinB, mode);
004460  004851  // Usage : Qencoder2(PA4, PA5, stopfunc);         // connect PA4 and PA5 pins to qudrature encoder module #2
004461  004852  // Notes : not available on pins PA14 and PA15
004462  004853  //       : Connect a quadrature encoder to a pair of pins The position counter and delta can be read
004463  004854  //       : or written to at any time with peekW and pokeW using the following constants:-
004464  004855  //       : It is necessary to configure the pins first, depending on your requirements, eg
004465  004856  //       :           pin_Set(PIN_INP_HI, PA4);     // PA4 as input, with pullup to Vcc
004466  004857  //       : or maybe  pin_Set(PIN_INP, PA4);        // PA4 as input, no pullup or pulldown
004467  004858  //       : Returns true if the pin numbers are legal (usually ignored)
004468  004859  //    QEN2_COUNTER_LO
004469  004860  //    QEN2_COUNTER_HI
004470  004861  //    QEN2_DELTA This is reset to 0 when read
004471  004862        
004472  004863        
004473  004864  func Qencoder1Reset(), 0;
004474  004865  // Syntax: Qencoder1Reset();
004475  004866  // Usage : Qencoder1Reset();     // reset the counter and delta value for encoder #1
004476  004867  // Notes :
004477  004868  //    QEN1_COUNTER_LO is reset to zero
004478  004869  //    QEN1_COUNTER_HI is reset to zero
004479  004870  //    QEN1_DELTA is reset to zero
004480  004871        
004481  004872  func Qencoder2Reset(), 0;
004482  004873  // Syntax: Qencoder2Reset();
004483  004874  // Usage : Qencoder2Reset();     // reset the counter and delta value for encoder #2
004484  004875  // Notes :
004485  004876  //    QEN2_COUNTER_LO is reset to zero
004486  004877  //    QEN2_COUNTER_HI is reset to zero
004487  004878  //    QEN2_DELTA is reset to zero
004488  004879        
004489  004880        
004490  004881  func pin_PulseoutCount("pin", "freq", "count", "function"), 1;        // pulse pin at freq count times calling function when complete
004491  004882  // Syntax: pin_PulseoutCount(pin, freq, count, function);
004492  004883  // Usage : pin_PulseoutCount(PA4, 1000, 5000, 0);            // output 5000 1msec pulses on PA3
004493  004884  // Notes : only available on PA4 to PA9, maximum 3 active at any one time
004494  004885  //       : Invert the state of an output at a "freq" freuency "count" times.
004495  004886  //       : PulseoutCount is non blocking, that is, code execution may continue while
004496  004887  //       : pulses are occuring, and pulses can occur on multiple pins simultaneously.
004497  004888  //       : If not already an output, pin is automatically made a push/pull output,
004498  004889  //       : and the last state of its output latch will determine pulse polarity.
004499  004890  //       : It's its open drain state is not altered if the pin was already an output.
004500  004891  //       : If PulseoutCount is called while PulseoutCount is still active, the pulse counter
004501  004892  //       : will simply have the new "value" added to it.
004502  004893  //       : returns false if the pin number is illegal, freq is < 10, or all counters in use
004503  004894  //       : returns true if the pin number is legal (usually ignored)
004504  004895        
004505  004896  func __reserved72(), 0; // do not remove
004506  004897        
004507  004898  func pwm_Init("pin", "mode", "value"), 1;    // set pin PA4-PA9 for the required PWM mode and select its source
004508  004899  // Syntax: pwm_Init(pin, value);
004509  004900  // Usage : pwm_Init(PA4, 1, 500);                 // output 50% duty cycle on PA4
004510  004901  // Notes : only available on PA4 to PA9
004511  004902  //       : Mode PWM_OFF(0)    : Turn off the PWM (pin is left as output)
004512  004903  //       : Mode PWM_PLAIN(1)  : Plain PWM value is 0-1000, corresponding to 0-100% duty cycle.
004513  004904  //       :                    : Raw frequency ~70khz. A value of 1 is not valid
004514  004905  //       : Mode PWM_SERVO(2)  : Servo PWM value is 100-200, corresponding to 1.00 to 2.00 ms
004515  004906  //       :                    : Values of 0 to 600 are valid (0-6ms), but should be used with caution.
004516  004907  //       :                    : Repetition rate ~50hz or 20ms
004517  004908  //       : Mode PWM_BINARY(3) : Binary PWM value is 0-1024, corresponding to 0-100% duty cycle.
004518  004909  //       :                    : Raw frequency ~68khz. A value of 1 is not valid
004519  004910  //       : pwm_Init is non blocking and the pwm continues until turn off
004520  004911  //       : Returns true if the pin number is legal (usually ignored)
004521  004912        
004522  004913  //------------------------------------------------------------------------------
004523  004914  // PWM Constants
004524  004915  //------------------------------------------------------------------------------
004525  004916  #CONST
004526  004932  #END
004527  004933        
004528  004934  func OW_Reset("pin"), 1;                             // issue 1wire reset command
004529  004935  // Syntax   : OW_Reset(PA0);
004530  004936  // Usage    : OW_Reset(PA0);
004531  004937  // Notes    : Only available on PA0 to PA13
004532  004938  //          : Resets  ONEWIRE device
004533  004939  //          : Returns the status, 0 = ACK.
004534  004940  //          :
004535  004941        
004536  004942  func OW_Read("pin"), 1;                              // read data from 1wire bus
004537  004943  // Syntax   : OW_Read(PA0);
004538  004944  // Usage    : arg1 := OW_Read(PA0);
004539  004945  // Notes    : Only available on PA0 to PA13
004540  004946  //          : Reads value of the ONEWIRE pin
004541  004947  //          : that was previously selected for ONEWIRE comms.
004542  004948  //          :
004543  004949  //          : pin = 0 : the next byte from the ONEWIRE bus
004544  004950        
004545  004951  func OW_Read9("pin"), 1;                             // read data from 1wire bus, 9bit mode
004546  004952  // Syntax   : OW_Read9(PA0);
004547  004953  // Usage    : OW_Read9(PA0);
004548  004954  // Notes    : Only available on PA0 to PA13
004549  004955  //          : Reads 9 bit value of the appropriate ONEWIRE pin
004550  004956  //          : that was previously selected for ONEWIRE comms.
004551  004957  //          :
004552  004958  //          : read the 9 bits from the ONEWIRE bus
004553  004959        
004554  004960  func OW_Write("pin", "value"), 0;                      // write value to 1wire device
004555  004961  // Syntax   : OW_Write(PA0, arg);
004556  004962  // Usage    : OW_Write(PA0, arg);
004557  004963  // Notes    : Only available on PA0 to PA13
004558  004964  //          : Sends ONEWIRE data on the appropriate
004559  004965  //          : pin that was previously  selected as ONEWIRE comms.
004560  004966  //          :
004561  004967  //          : write arg to the ONEWIRE bus
004562  004968        
004563  004969  func __reserved77(), 0; // do not remove
004564  004970  func __reserved78(), 0; // do not remove
004565  004971        
004566  004972  func sys_GetDateVar("&year", "&month", "&day"), 0;              // get year, month, day into variables
004567  004973  // Syntax: sys_GetDateVar(&year, &month, &day);
004568  004974  // Usage : sys_GetDateVar(&year, &month, &day);
004569  004975  // Notes : Retrieves the date values into variables
004570  004976        
004571  004977  func sys_GetTimeVar("&hour", "&minute", "&second", "&msecs"), 0;              // get hour, minute, second, millseconds into variables
004572  004978  // Syntax: sys_GetTimeVar(&hour, &minute, &second, &msecs);
004573  004979  // Usage : sys_GetTimeVar(&hour, &minute, &second, &msecs);
004574  004980  // Notes : Retrieves the time values into variables
004575  004981        
004576  004982  func sys_PmmC(), 1;
004577  004983  // Syntax: sys_PmmC();
004578  004984  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer
004579  004985  // Notes : print the system PmmC name and revision eg "Diablo16\n1.0"
004580  004986  //       : Can be captured to a buffer using the to( function
004581  004987  //       : Returns nothing.
004582  004988        
004583  004989  func sys_Driver(), 0;
004584  004990  // Syntax: sys_Driver();
004585  004991  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer
004586  004992  // Notes : print the system PmmC name and revision eg "uLCD-32WDTU-A\n130411"
004587  004993  //       : Can be captured to a buffer using the to( function
004588  004994  //       : Returns nothing.
004589  004995        
004590  004996  func gfx_Scope("left", "width", "yzero", "n", "xstep", "Yamp", "colorbg", "&old_y1", "&new_y1", "color1", "&old_y2", "&new_y2", "color2", "&old_y3", "&new_y3", "color3", "&old_y4", "&new_y4", "color4"), 0;
004591  004997  // Notes : Draws up to 4 waveforms from table(s) of vertices at the specified origin.
004592  004998  //       : "Left" is the left margin, "Width" is the width, "yzero" is the y position
004593  004999  //       : that corresponds to a y value of zero, normally "Top" + "Height" for
004594  005000  //       : a graph, or "Top" + "Height"/2 for a scope. "n" is the number of
004595  005001  //       : elements in each buffer. This will need to be greater than "width" for negative
004596  005002  //       : "xstep" values. "Yamp" is for amplification in the Y direction, 100 is unity.
004597  005003  //       : pass 0 as the address for any unused traces
004598  005004  //       : X position is incremented each point by "xstep" pixels.
004599  005005  //       : Y values are derived from a Y buffer "newy" (signed values).
004600  005006  //       : 2 buffers need to be supplied, "newy" contains new
004601  005007  //       : points to be drawn, "oldy" contains most recent set
004602  005008  //       : of points to be un-drawn. After the waveform is drawn,
004603  005009  //       : "newy" buffer is automatically copied to "oldy" buffer.
004604  005010        
004605  005011        
004606  005012  func ana_HS("rate", "samples", "&IO1", "&IO2", "&IO3", "&IO4", "COMPLETEfunction"), 0;
004607  005013  // Syntax: ana_HS(rate, samples, IO1buf, IO2buf, IO3buf, IO4buf, userFunction);
004608  005014  // Usage : ana_HS(1000, 10, IO1buf, 0, 0, 0, myFunc);
004609  005015  // Notes : Collects "samples" samples at "rate" frequency for 0 to 4 analogue pins
004610  005016  //       : and calls "COMPLETEfunction" when done.
004611  005017  //       : "rate" is samples in 100 of samples per second
004612  005018  //       : Any unused IOx pins should have their buffer addresses set to 0
004613  005019  //       : For performance reasons samples are taken in chunks of 32, thus if you
004614  005020  //       : request 33 samples there will be a delay of 31 samples before
004615  005021  //       : "COMPLETEfunction" is called
004616  005022  //       : If Touch is enabled this function should be called no more than once per
004617  005023  //       : millisecond, otherwise touch behaviour could be eratic.
004618  005024        
004619  005025        
004620  005026  func sys_ErrorMessage("msgnum"), 1;
004621  005027        
004622  005028  //==============================//
004623  005029  // NeoPixel specific functions  //
004624  005030  //==============================//
004625  005031        
004626  005032  func NP_Write("pin", "data", "size", "Options", "RepeatFirst", "Repeat", "RepeatLast"), 1;    // Write a string of colours to a NeoPixel 'display'
004627  005033  // Syntax: NP_Write(pin, data, size, Options, RepeatFirst, Repeat, RepeatLast);
004628  005034  // Usage : NP_Write(PA4, data, 50, NP_565, 10, 0, 0);                 
004629  005035  // Notes : pin         : The I/O pin for the operation PA0 to PA13
004630  005036  //       : data        : Address of data to be sent
004631  005037  //       : size        : number of colour 'sets' to follow
004632  005038  //       : Options     : format of colour data to be sent, NP_565, NP_RGB, or NP_XRGB. i.e. 2, 3 or 4 bytes per colour
004633  005039  //       : RepeatFirst : Number of times to repeat the first colour (0 means first colour is not considered 'special')
004634  005040  //       : Repeat      : Number of times to repeat the colours between first and last
004635  005041  //       : RepeatLast  : Number of times to repeat the last colour (0 means last colour is not considered 'special')
004636  005042  //       : Returns true if the pin number is legal (usually ignored)
004637  005043  //       : Due to the critical timing requirements of the NeoPixel, the system Timer is disabled during this operation.
004638  005044  //       : Comms Interrupts should also be disabled by the user, otherwise errors may occur.
004639  005045        
004640  005046  // NeoPixel related constants
004641  005047  #CONST
004642  005051  #END
004643  005052        
004644  005053  func __reserved85(), 0; // do not remove
004645  005054  func __reserved86(), 0; // do not remove
004646  005055        
004647  005056  //==============================================//
004648  005057  // spi flash device specific functions          //
004649  005058  //==============================================//
004650  005059        
004651  005060  func spiflash_SIG("spi#", "enablepin"), 1;         // read Jedec signature from SPI Flash device
004652  005061  // Syntax   : spiflash_SIG("spi#","enablepin");
004653  005062  // Usage    : var := spiflash_SIG(SPI1, PA0);
004654  005063  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004655  005064  //          : spi_Init(...) function, the Electronic Signature of the device can be read using this function. The only
004656  005065  //          : devices supported so far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004657  005066  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004658  005067  //          : Release from Deep Power-down, and Read Electronic Signature. Only the low order byte is valid, the upper
004659  005068  //          : byte is ignored.
004660  005069        
004661  005070  func spiflash_ID("spi#", "enablepin"), 1;          // read ID code from FLASH device
004662  005071  // Syntax   : spiflash_ID("spi#","enablepin");
004663  005072  // Usage    : var := spiflash_ID(SPI1, PA0);
004664  005073  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004665  005074  //          : spi_Init(...) function, the memory type and capacity from the flash device can be read using this function
004666  005075  //          : The only devices supported so far M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004667  005076  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004668  005077  //          : Reads the memory type and capacity from the serial FLASH device. Hi byte contains type, and low byte
004669  005078  //          : contains capacity. Refer to the device data sheet for further information.
004670  005079        
004671  005080  func spiflash_BulkErase("spi#", "enablepin"), 0;    // erase the entire FLASH device
004672  005081  // Syntax	: spiflash_BulkErase("spi#","enablepin");
004673  005082  // Usage	: spiflash_BulkErase(SPI1, PA0);
004674  005083  // Notes	: A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004675  005084  // 	: spi_Init(...) function, the FLASH device can be completely erased using this function. The only devices
004676  005085  // 	: supported so far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004677  005086  // 	: Other similar devices should also work, provided they do not exceed 128Mbit.
004678  005087  // 	: Erases the entire flash media device. The function returns no value, and the operation can take up to 80
004679  005088  // 	: seconds depending on the size of the flash device. Note that not all devices support this command.
004680  005089  // 	: This uses the 0xC7 command.
004681  005090        
004682  005091  func spiflash_BlockErase("spi#", "enablepin", "block"), 0;            // erase the required 64k flash block
004683  005092  // Syntax	: spiflash_BlockErase("spi#", "enablepin", "block")
004684  005093  // Usage	: var := spiflash_BlockErase(SPI1, PA0, block_num)
004685  005094  // Notes	: A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004686  005095  // 	: spi_Init(...) function, the FLASH block can be erased using this function. The only devices supported so
004687  005096  // 	: far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004688  005097  // 	: Other similar devices should also work, provided they do not exceed 128Mbit.
004689  005098  // 	: E.g. there are 32 x 64K blocks on a 2Mb flash device.
004690  005099  // 	: blockAddress The address of the 64k FLASH block to be erased.
004691  005100  // 	: Erases the required block in a FLASH media device. The function returns no value, and the operation
004692  005101  // 	: can take up to 3 milliseconds.
004693  005102  // 	: This uses the 0xD8 command.
004694  005103        
004695  005104  func spiflash_SetAdd("spi#", "HiWord", "LoWord"), 0;           // set stream byte address
004696  005105  // Syntax: spiflash_SetAdd(AddHiWord, AddLoWord);
004697  005106  // Usage : spiflash_SetAdd(SPI1, arg1, arg2);
004698  005107  // Notes : Set FLASH internal Address pointer for bytewise access on the specified SPI port
004699  005108        
004700  005109  func spiflash_Read("*dest", "size", "spi#", "enablepin"), 1;
004701  005110  // Syntax: res := spiflash_Read("*dest", "size", "spi#", "enablepin"),
004702  005111  // Usage : res := spiflash_Read(memblock, 20, SPI1, PA0);
004703  005112  // Notes : Reads the specified number of bytes from the FLASH memory device on the specified SPI port and enable pin
004704  005113  //       : into the specified destination. The destination is a string pointer (i.e. BYTE aligned). The source
004705  005114  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004706  005115  //       : returns number of characters read
004707  005116  //       : if "dest" is zero, data is read direct to GRAM window
004708  005117  //       :
004709  005118        
004710  005119  func spiflash_Write("*source", "size", "spi#", "enablepin"), 1;
004711  005120  // Syntax: res := fwrite("*source", "size", "spi#", "enablepin"),
004712  005121  // Usage : res := fwrite(memblock, 20, SPI1, PA0);
004713  005122  // Notes : Writes the specified number of bytes to the FLASH memory device on the specified SPI port and enable pin
004714  005123  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004715  005124  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004716  005125  //       : returns number of bytes written
004717  005126  //       :
004718  005127        
004719  005128  func spiflash_Image("x", "y", "spi#", "enablepin"), 1;
004720  005129  // Syntax: spiflash_Image(x, y, "spi#", "enablepin");
004721  005130  // Usage : spiflash_Image(10, 10, SPI1, PA0);
004722  005131  // Notes : Display an image from a file at the current FLASH position set by spiflash_SetAdd()
004723  005132  //       : The image is displayed at x,y (with respect to top left corner).
004724  005133        
004725  005134  func spiflash_PutC("char", "spi#", "enablepin"), 0;
004726  005135  // Syntax: spiflash_PutC("char", "spi#", "enablepin");
004727  005136  // Usage : spiflash_PutC('x', SPI1, PA0);
004728  005137  // Notes : Writes a character (or byte) to the FLASH memory device on the specified SPI port and enable pin
004729  005138  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004730  005139  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004731  005140        
004732  005141  func spiflash_GetC("spi#", "enablepin"), 1;
004733  005142  // Syntax: spiflash_GetC("spi#", "enablepin");
004734  005143  // Usage : mychar := fgetC(SPI1, PA0);
004735  005144  // Notes : Reads a character (or byte) from the FLASH memory device on the specified SPI port and enable pin
004736  005145  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004737  005146  //       : by subsequent reads or writes.
004738  005147  //       : returns next char from file
004739  005148        
004740  005149  func spiflash_PutW("word", "spi#", "enablepin"), 0;
004741  005150  // Syntax: spiflash_PutW("word", "spi#", "enablepin");
004742  005151  // Usage : spiflash_PutW(0x1234, SPI1, PA0);
004743  005152  // Notes : Writes a word to the FLASH memory device on the specified SPI port and enable pin
004744  005153  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004745  005154  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004746  005155        
004747  005156  func spiflash_GetW("spi#", "enablepin"), 1;
004748  005157  // Syntax: spiflash_GetW("spi#", "enablepin");
004749  005158  // Usage : myword := fgetW(SPI1, PA0);
004750  005159  // Notes : Reads a word from the FLASH memory device on the specified SPI port and enable pin
004751  005160  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004752  005161  //       : by subsequent reads or writes.
004753  005162  // Notes : returns next word in file
004754  005163        
004755  005164  func spiflash_PutS("*source", "spi#", "enablepin"), 1;
004756  005165  // Syntax: res := spiflash_Puts("*source", "spi#", "enablepin"),
004757  005166  // Usage : res := spiflash_Puts(mystring, SPI1, PA0);
004758  005167  // Notes : Writes a string to the FLASH memory device on the specified SPI port and enable pin
004759  005168  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004760  005169  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004761  005170  //       : returns number of characters written
004762  005171  //       :
004763  005172        
004764  005173  func spiflash_GetS("*string", "size", "spi#", "enablepin"), 1;
004765  005174  // Syntax: res := spiflash_Gets("*string", "size", "spi#", "enablepin");
004766  005175  // Usage : res := spiflash_Gets(mystr , 81, SPI1, PA0); // read up to 80 chars
004767  005176  // Notes : Reads a string from the FLASH memory device on the specified SPI port and enable pin
004768  005177  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004769  005178  //       : by subsequent reads or writes.
004770  005179  //       : returns pointer to string or null if failed.
004771  005180  //       : spiflash_GetS(...) automatically appends a null-terminator to the data read.
004772  005181  //       : NB:- only reads up to "size-1" characters into "string"
004773  005182  //       : spiflash_GetS(...) will stop reading when any of the following conditions are true:
004774  005183  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
004775  005184  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
004776  005185  //       : C] It reaches the end of file
004777  005186  //       : D] A read error occurs.
004778  005187        
004779  005188  func spiflash_LoadFunction("spi#", "enablepin"), 1;
004780  005189  // Syntax: res := spiflash_LoadFunction("spi#", "enablepin");
004781  005190  // Usage : myfunc := spiflash_LoadFunction(SPI1, PA0);
004782  005191  // Notes : Load a function or program from the FLASH memory device on the specified SPI port and enable pin at
004783  005192  //       : the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes and
004784  005193  //       : return a function pointer to the allocation.
004785  005194  //       : The function can then be invoked just like any other
004786  005195  //       : function would be called via a function pointer.
004787  005196  //       : Parameters may be passed to it in a conventional way.
004788  005197  //       : The function may be discarded at any time when no
004789  005198  //       : longer required, thus freeing its memory resources.
004790  005199  //       : The loaded function can be discarded with mem_Free(..)
004791  005200  //       : eg:
004792  005201  //       : popupWindow := spiflash_LoadFunction("popupWindow1.4fn");
004793  005202  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
004794  005203  //       : then elsewhere in your program:-
004795  005204  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
004796  005205  //       : if(res == QUIT_APPLICATION) goto exitApp;
004797  005206  //       : Later in your program, when popupWindow is no longer
004798  005207  //       : required for the application:-
004799  005208  //       : res := mem_Free(popupWindow);
004800  005209  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
004801  005210  //       : The callers stack is shared by the loaded function,
004802  005211  //       : however any global variables in the loaded function
004803  005212  //       : are private to that function.
004804  005213  //
004805  005214        
004806  005215  func spiflash_Run("spi#", "enablepin", "arglistptr"), 1;
004807  005216  // Syntax: res := spiflash_Run("spi#", "enablepin", "arglistptr");
004808  005217  // Usage : res := spiflash_Run(SPI1, PA0, argptr);
004809  005218  // Notes : current program releases any allocated memory but
004810  005219  //       : retains the stack and global memory.
004811  005220  //       : If arglistptr is 0, no arguments are passed, else
004812  005221  //       : arglist points to an array, the first element being
004813  005222  //       : the number of elements in the array.
004814  005223  //       : func 'main' in the called program accepts
004815  005224  //       : the arguments, if any. The arguments can only
004816  005225  //       : be passed by value, no pointers or references can be
004817  005226  //       : used as all memory is cleared before the file
004818  005227  //       : is loaded. Refer to spiflash_Exec and spiflash_LoadFunction
004819  005228  //       : for functions that can pass by reference.
004820  005229        
004821  005230  func spiflash_Exec("spi#", "enablepin", "arglistptr"), 1;
004822  005231  // Syntax: res := spiflash_Exec("spi#", "enablepin", "arglistptr");
004823  005232  // Usage : res := spiflash_Exec(SPI1, PA0, "arglistptr");
004824  005233  // Notes : returns like a function, current program
004825  005234  //       : calling program is kept active and control returns to it.
004826  005235  //       : If arglistptr is 0, no arguments are passed, else
004827  005236  //       : arglist points to an array, the first element being
004828  005237  //       : the number of elements in the array.
004829  005238  //       : func 'main' in the called program accepts the arguments.
004830  005239  //       : This function is similar to spiflash_LoadFunction(...), however,
004831  005240  //       : the function argument list is passed by pointer, and
004832  005241  //       : the memory consumed by the function is released as
004833  005242  //       : soon as the function completes.
004834  005243        
004835  005244  func spiflash_LoadImageControl("spi#", "enablepin"), 1;
004836  005245  // Syntax: hImagelist := spiflash_LoadImageControl ("spi#", "enablepin"),
004837  005246  // Usage : hImagelist := spiflash_LoadImageControl (SPI1, PA0);
004838  005247  // Notes : Reads a control file to create an image list from the FLASH memory device on the specified SPI port
004839  005248  //       : and enable pin. The source is the address set by spiflash_SetAdd(), or incremented by subsequent reads
004840  005249  //       : or writes. The ".dat" file is first and is immediately followed a ^Z and then by the ".gci' file.
004841  005250  //       : Returns NULL if function fails.
004842  005251  //       : Returns a handle (pointer to the memory allocation) to the
004843  005252  //       : image control list that has been created.
004844  005253        
004845  005254  // Notes : This function Calculates the size of a chunk of memory required for
004846  005255  //       : a image list and populates it from the image control file ("*.dat")
004847  005256  //       : therefore, when imagelist is no longer required, you must de-allocate
004848  005257  //       : the image list memory by using eg:- mem_Free(hImagelist);
004849  005258  //       : to restore the heap.
004850  005259  //       :
004851  005260        
004852  005261  func spiflash_PlayWAV("spi#", "enablepin"), 1;
004853  005262  // Syntax: spiflash_PlayWAV("spi#", "enablepin");
004854  005263  // Usage : spiflash_PlayWAV(SPI1, PA0);
004855  005264  // Notes : Play a wave file from the FLASH memory device on the specified SPI port and enable pin.
004856  005265  //       : The source is the address set by spiflash_SetAdd(), or incremented by subsequent reads
004857  005266  //       : or writes.
004858  005267  //       : This function automatically grabs a chunk
004859  005268  //       : of memory for a file buffer, and a wave
004860  005269  //       : buffer. The minimum memory requirement is
004861  005270  //       : about 580 bytes for the disk io service and
004862  005271  //       : a minimum wave buffer size of 1024. The size
004863  005272  //       : of the wave buffer allocation
004864  005273  //       : can be increased by the snd_BufSize function.
004865  005274  //       : The default size 1024 bytes.
004866  005275  //       : NB the memory is only required during the
004867  005276  //       : duration of play, and is automatically
004868  005277  //       : released while not in use.
004869  005278  //       : See the Sound Class services for other associated controls.
004870  005279  //       : If there are no errors, returns number of blocks to play (1 to 32767)
004871  005280  //       : If errors occured, the folling is returned
004872  005281  //       : -7  : Insufficient memory available for WAV buffer and file
004873  005282  //       : -6  : cant play this rate
004874  005283  //       : -5  : no data chunk found in first rsector
004875  005284  //       : -4  : no format data
004876  005285  //       : -3  : no wave chunk signature
004877  005286  //       : -2  : bad wave file format
004878  005287  //       : -1  : file not found
004879  005288        
004880  005289  //==============================================//
004881  005290  // more com functions                           //
004882  005291  //==============================================//
004883  005292        
004884  005293  func com1_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004885  005294  // Syntax   : com1_TXblock("buf", "bufsize");
004886  005295  // Usage    : com1_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004887  005296  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004888  005297  //          : if a transmit buffer is active and space is available this function will return almost
004889  005298  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004890  005299        
004891  005300  func com1_RXblock("buf", "bufsize"), 0;                       // commence a block reception
004892  005301  // Syntax   : com1_RXblock("buf", "bufsize");
004893  005302  // Usage    : com1_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004894  005303  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004895  005304  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004896  005305  //          : immediately otherwise it will block until until the required bytes are received.
004897  005306        
004898  005307  func com2_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004899  005308  // Syntax   : com_TXblock("buf", "bufsize");
004900  005309  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004901  005310  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004902  005311  //          : if a transmit buffer is active and space is available this function will return almost
004903  005312  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004904  005313        
004905  005314  func com2_RXblock("buf", "bufsize"), 0;                       // commence an block reception
004906  005315  // Syntax   : com_RXblock("buf", "bufsize");
004907  005316  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004908  005317  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004909  005318  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004910  005319  //          : immediately otherwise it will block until until the required bytes are received.
004911  005320        
004912  005321  func com3_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004913  005322  // Syntax   : com_TXblock("buf", "bufsize");
004914  005323  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004915  005324  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004916  005325  //          : if a transmit buffer is active and space is available this function will return almost
004917  005326  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004918  005327        
004919  005328  func com3_RXblock("buf", "bufsize"), 0;                       // commence an block reception
004920  005329  // Syntax   : com_RXblock("buf", "bufsize");
004921  005330  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004922  005331  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004923  005332  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004924  005333  //          : immediately otherwise it will block until until the required bytes are received.
004925  005334        
004926  005335  func disp_BlitPixelsFromCOM1(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004927  005336  // Syntax: disp_BlitPixelsFromCOM1();                  New in v1.1
004928  005337  // Usage : disp_BlitPixelsFromCOM1();
004929  005338  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004930  005339  //       : display from the specified com port.
004931  005340        
004932  005341  func disp_BlitPixelsFromCOM2(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004933  005342  // Syntax: disp_BlitPixelsFromCOM2();                  New in v1.1
004934  005343  // Usage : disp_BlitPixelsFromCOM2();
004935  005344  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004936  005345  //       : display from the specified com port.
004937  005346        
004938  005347  func disp_BlitPixelsFromCOM3(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004939  005348  // Syntax: disp_BlitPixelsFromCOM3();                  New in v1.1
004940  005349  // Usage : disp_BlitPixelsFromCOM3();
004941  005350  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004942  005351  //       : display from the specified com port.
004943  005352        
004944  005353        
004945  005354  //==============================================//
004946  005355  // crc generation functions                     //
004947  005356  //==============================================//
004948  005357        
004949  005358  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
004950  005359  // *Notes   : (if you calculate all of the incoming data
004951  005360  //          : INCLUDING the CRC, the result should be 0x00
004952  005361  //          : This is equivalent to simple addition of all bytes
004953  005362  //          : and returning the negated sum an 8 bit value.
004954  005363  //          : For the standard test string "123456789",
004955  005364  //          : crc_CSUM_8 will return 0x0023.
004956  005365        
004957  005366        
004958  005367  func crc_16("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate CRC16
004959  005368  // *Notes   : The "mode" argument may be READ, WRITE or CHECK
004960  005369  //          : (if you calculate all of the incoming data
004961  005370  //          : INCLUDING the CRC, the result should be 0x0000
004962  005371  //          : For the standard test string "123456789",
004963  005372  //          : crc_16 will return 0xBB3D.
004964  005373        
004965  005374        
004966  005375  func crc_MODBUS("buf","count"), 1;                  // given a pointer to a buffer and a byte count, calculate CRC16 for MODBUS
004967  005376  // *Notes   : (if you calculate all of the incoming data
004968  005377  //          : INCLUDING the CRC, the result should be 0x0000
004969  005378  //          : For the standard test string "123456789",
004970  005379  //          : crc_MODBUS will return 0x4B37.
004971  005380        
004972  005381        
004973  005382  func crc_CCITT("buf","count","seed"), 1;            // given a pointer to a buffer, byte count and seed, calculate the 16bit CRC for seed
004974  005383  // *Notes   : (if you calculate all of the incoming data
004975  005384  //          : INCLUDING the CRC, the result should be 0x0000
004976  005385  //          : For the standard test string "123456789",
004977  005386  //          : crc_CCITT will return the following:-
004978  005387  //          : seed = 0 (XMODEM protocol) result = 0x31C3
004979  005388  //          : seed = 0xFFFF, result = 0x29B1
004980  005389  //          : seed = 0x1D0F, result = 0xE5CC
004981  005390        
004982  005391  func __reserved87(), 0; // do not remove
004983  005392  func __reserved88(), 0; // do not remove
004984  005393  func __reserved89(), 0; // do not remove
004985  005394        
004986  005395  //----------------------------------------------------------------------------//
004987  005396  //  functions to support buffered transmission and reception of break signal  //
004988  005397  //----------------------------------------------------------------------------//
004989  005398        
004990  005399  func com_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
004991  005400  // Usage : com_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
004992  005401  // Usage : com_TXbufferBrk(0, 0, 0);             // revert to non buffered service
004993  005402  // Notes : initialize a serial buffer for the COM0 output.
004994  005403  //       : The program must declare a var array as a circular buffer.
004995  005404  //       : When a TX buffer is declared for comms, the transmission
004996  005405  //       : of characters becomes non blocking. If the buffer has
004997  005406  //       : insufficient space to accept the next character from a
004998  005407  //       : serout_x() function, the excess characters will be ignored,
004999  005408  //       : and the com_Full_x() error will be asserted.   If the
005000  005409  //       : TX buffer is no longer required, just set the buffer pointer
005001  005410  //       : to zero, the size in this case doesnt matter and is ignored.
005002  005411  //       : The function can resize or reallocated to another buffer at
005003  005412  //       : any time. The buffer is flushed before any changes are made.
005004  005413  //       : "pin" designates an IO pin to control a bi-directional
005005  005414  //       : control device for half duplex mode. "pin" will go HI at the
005006  005415  //       : start of a transmission, and will return low after the final
005007  005416  //       : byte is transmitted. If not required, just set "pin" to zero.
005008  005417        
005009  005418  func com1_TXbufferBrk("buf", "bufsize", "pin"), 0;
005010  005419  // Usage : com1_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005011  005420  // Usage : com1_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005012  005421  // Notes : initialize a serial buffer for the COM0 output.
005013  005422  //       : The program must declare a var array as a circular buffer.
005014  005423  //       : When a TX buffer is declared for comms, the transmission
005015  005424  //       : of characters becomes non blocking. If the buffer has
005016  005425  //       : insufficient space to accept the next character from a
005017  005426  //       : serout_x() function, the excess characters will be ignored,
005018  005427  //       : and the com_Full_x() error will be asserted.   If the
005019  005428  //       : TX buffer is no longer required, just set the buffer pointer
005020  005429  //       : to zero, the size in this case doesnt matter and is ignored.
005021  005430  //       : The function can resize or reallocated to another buffer at
005022  005431  //       : any time. The buffer is flushed before any changes are made.
005023  005432  //       : "pin" designates an IO pin to control a bi-directional
005024  005433  //       : control device for half duplex mode. "pin" will go HI at the
005025  005434  //       : start of a transmission, and will return low after the final
005026  005435  //       : byte is transmitted. If not required, just set "pin" to zero.
005027  005436        
005028  005437  func com2_TXbufferBrk("buf", "bufsize", "pin"), 0;
005029  005438  // Usage : com2_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005030  005439  // Usage : com2_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005031  005440  // Notes : initialize a serial buffer for the COM0 output.
005032  005441  //       : The program must declare a var array as a circular buffer.
005033  005442  //       : When a TX buffer is declared for comms, the transmission
005034  005443  //       : of characters becomes non blocking. If the buffer has
005035  005444  //       : insufficient space to accept the next character from a
005036  005445  //       : serout_x() function, the excess characters will be ignored,
005037  005446  //       : and the com_Full_x() error will be asserted.   If the
005038  005447  //       : TX buffer is no longer required, just set the buffer pointer
005039  005448  //       : to zero, the size in this case doesnt matter and is ignored.
005040  005449  //       : The function can resize or reallocated to another buffer at
005041  005450  //       : any time. The buffer is flushed before any changes are made.
005042  005451  //       : "pin" designates an IO pin to control a bi-directional
005043  005452  //       : control device for half duplex mode. "pin" will go HI at the
005044  005453  //       : start of a transmission, and will return low after the final
005045  005454  //       : byte is transmitted. If not required, just set "pin" to zero.
005046  005455        
005047  005456  func com3_TXbufferBrk("buf", "bufsize", "pin"), 0;
005048  005457  // Usage : com3_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005049  005458  // Usage : com3_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005050  005459  // Notes : initialize a serial buffer for the COM0 output.
005051  005460  //       : The program must declare a var array as a circular buffer.
005052  005461  //       : When a TX buffer is declared for comms, the transmission
005053  005462  //       : of characters becomes non blocking. If the buffer has
005054  005463  //       : insufficient space to accept the next character from a
005055  005464  //       : serout_x() function, the excess characters will be ignored,
005056  005465  //       : and the com_Full_x() error will be asserted.   If the
005057  005466  //       : TX buffer is no longer required, just set the buffer pointer
005058  005467  //       : to zero, the size in this case doesnt matter and is ignored.
005059  005468  //       : The function can resize or reallocated to another buffer at
005060  005469  //       : any time. The buffer is flushed before any changes are made.
005061  005470  //       : "pin" designates an IO pin to control a bi-directional
005062  005471  //       : control device for half duplex mode. "pin" will go HI at the
005063  005472  //       : start of a transmission, and will return low after the final
005064  005473  //       : byte is transmitted. If not required, just set "pin" to zero.
005065  005474        
005066  005475  func com_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
005067  005476  // Syntax: com_InitBrk(buffer, bufsize, qualifier);
005068  005477  // Usage1: com_InitBrk(mybuf, 20, 0);
005069  005478  // Usage2: com_InitBrk(mybuf, 20, ':');
005070  005479  // Notes : initialize a serial capture buffer for the comms input
005071  005480  //       : The program must declare a var array as a circular buffer.
005072  005481  //       : Usage1 declares a circular buffer which will continually
005073  005482  //       : buffer characters.
005074  005483  //       : Usage2 must receive ':' before any characters will
005075  005484  //       : accumulate in the buffer.
005076  005485        
005077  005486  func com1_InitBrk("buf","bufsize","qualifier"), 0;
005078  005487  // Syntax: com1_InitBrk(buffer, bufsize, qualifier);
005079  005488  // Usage1: com1_InitBrk(mybuf, 20, 0);
005080  005489  // Usage2: com1_InitBrk(mybuf, 20, ':');
005081  005490  // Notes : initialize a serial capture buffer for the comms input
005082  005491  //       : The program must declare a var array as a circular buffer.
005083  005492  //       : Usage1 declares a circular buffer which will continually
005084  005493  //       : buffer characters.
005085  005494  //       : Usage2 must receive ':' before any characters will
005086  005495  //       : accumulate in the buffer.
005087  005496        
005088  005497  func com2_InitBrk("buf","bufsize","qualifier"), 0;
005089  005498  // Syntax: com2_InitBrk(buffer, bufsize, qualifier);
005090  005499  // Usage1: com2_InitBrk(mybuf, 20, 0);
005091  005500  // Usage2: com2_InitBrk(mybuf, 20, ':');
005092  005501  // Notes : initialize a serial capture buffer for the comms input
005093  005502  //       : The program must declare a var array as a circular buffer.
005094  005503  //       : Usage1 declares a circular buffer which will continually
005095  005504  //       : buffer characters.
005096  005505  //       : Usage2 must receive ':' before any characters will
005097  005506  //       : accumulate in the buffer.
005098  005507        
005099  005508  func com3_InitBrk("buf","bufsize","qualifier"), 0;
005100  005509  // Syntax: com3_InitBrk(buffer, bufsize, qualifier);
005101  005510  // Usage1: com3_InitBrk(mybuf, 20, 0);
005102  005511  // Usage2: com3_Init(mybuf, 20, ':');
005103  005512  // Notes : initialize a serial capture buffer for the comms input
005104  005513  //       : The program must declare a var array as a circular buffer.
005105  005514  //       : Usage1 declares a circular buffer which will continually
005106  005515  //       : buffer characters.
005107  005516  //       : Usage2 must receive ':' before any characters will
005108  005517  //       : accumulate in the buffer.
005109  005518        
005110  005519  func gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour"), 0;         // display an Annular ring segment
005111  005520  // Syntax 	: gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour") ;
005112  005521  // Usage 	: gfx_RingSegment(x, y, starta, enda, rx, w, colour) ;
005113  005522  // Notes 	: Draw a Segment of a ring at x, y from rad1 to rad2 starting at starta to enda
005114  005523  // 	: in colour.
005115  005524  //
005116  005525        
005117  005526  func gfx_AngularMeter("value", "&MeterRam", "&MeterDef"), 0;                           // draw an angular meter scale and value
005118  005527  // Syntax 	: gfx_AngularMeter("value", "&MeterRam", "&MeterDef") ;
005119  005528  // Usage 	: gfx_AngularMeter(value, MeterRam, MeterDef) ;
005120  005529  // Notes 	: Draw an Angular Meter as defined by MeterDef (if required), using MeterRam positioning at
005121  005530  // 	: position value. See the reference for the MeterDef values
005122  005531  //
005123  005532        
005124  005533  // AngularMeter constants
005125  005534  #CONST
005126  005585  #END
005127  005586        
005128  005587  #constant PANEL2_FILLED 0x8000
005129  005587  #constant PANEL2_FILLED 0x8000
005130  005588        
005131  005589  func gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf"), 0;                           // draw a windows style 3D panel
005132  005590  // Syntax 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
005133  005591  // Usage 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
005134  005592  // Notes	: Draws a panel2 (groupbox) at screen location defined by
005135  005593  // 	: x, y, width and height with left colour "cl", right colour "cr" and option fill colour "cf".
005136  005594  // 	:  w1 and w2 define the width of the outer and inner borders.
005137  005595  // 	:         state = 0 : recessed
005138  005596  // 	:         state = 1 : raised
005139  005597  // 	: 	  or state with PANEL2_FILLED to draw the fill
005140  005598        
005141  005599  func gfx_Needle("value", "&NeedleRam", "&NeedleDef"), 0;                           // draw a needle on a meter base
005142  005600  // Syntax 	: gfx_Needle("value", "&NeedleRam", "&NeedleDef") ;
005143  005601  // Usage 	: gfx_Needle(value, NeedleRam, NeedleDef) ;
005144  005602  // Notes 	: Draw a Needle as defined by NeedleDef (if required), using NeedleRam positioning at
005145  005603  // 	: position value. See the reference for the NeedleDef values
005146  005604  //
005147  005605        
005148  005606  #CONST
005149  005628  #END
005150  005629        
005151  005630  #CONST
005152  005637  #END
005153  005638        
005154  005639  func gfx_Dial("value", "&DialRam", "&DialDef"), 0;                           // draw a Dial / knob
005155  005640  // Syntax 	: gfx_Dial("value", "&DialRam", "&DialDef") ;
005156  005641  // Usage 	: gfx_Dial(value, DialRam, DialDef) ;
005157  005642  // Notes 	: Draw a Dial as defined by DialDef (if required), using DialRam positioning at
005158  005643  // 	: position value. See the reference for the DialDef values
005159  005644  //
005160  005645        
005161  005646  #CONST
005162  005704  #END
005163  005705        
005164  005706  func gfx_Gauge("value", "&GaugeRam", "&GaugeDef"), 0;                           // draw a gauge
005165  005707  // Syntax 	: gfx_Gauge("value", "&GaugeRam", "&GaugeDef") ;
005166  005708  // Usage 	: gfx_Gauge(value, GaugeRam, GaugeDef) ;
005167  005709  // Notes 	: Draw a Gauge as defined by GaugeDef (if required), using GaugeRam positioning at
005168  005710  // 	: position value. See the reference for the GaugeDef values
005169  005711  //
005170  005712        
005171  005713  #CONST
005172  005738  #END
005173  005739        
005174  005740  // widget_* functions
005175  005741  //
005176  005742  #CONST
005177  005775  #END
005178  005776        
005179  005777  #CONST
005180  005780  #END
005181  005781        
005182  005782  #CONST
005183  005814  #END
005184  005815        
005185  005816  func gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef"), 0;                           // draw a value to a series of 7 segment led Digits
005186  005817  // Syntax 	: gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef");
005187  005818  // Usage 	: gfx_LedDigits(value, LedDigitRam, LedDigitDef);
005188  005819  // Notes 	: Draw a series of 7 segment Led Digits as defined by LedDigitDef, using LedDigitRam positioning at
005189  005820  // 	: position value. See the reference for LedDigitDef values.
005190  005821  //
005191  005822        
005192  005823  func gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value"), 0;                           // draw a single 7 segment led digit
005193  005824  // Syntax 	: gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value");
005194  005825  // Usage 	: gfx_LedDigit(x, y, digitsize, oncolour, offcolour, value);
005195  005826  // Notes 	: Draws a single 7 segment led Digit at x, y of size digitsize using oncolour and offcolour.
005196  005827  // 	: The value can be 0-9 (0-9), A-F (0x0a-0x0f), blank(0x10) and - (0x11).
005197  005828  //      : Or value with LEDDIGIT_F_SHOW_DP to show a decimal point, LEDDIGIT_F_DP_COMMA to make the Decimal
005198  005829  // 	: point a comma and LEDDIGIT_F_DP_ON to turn the decimal point on
005199  005830  // 	:
005200  005831  // 	: LEDDIGIT_F_SET_SEGMENTS can be used to turn value into a series of bits to turn on individual segments
005201  005832  //      : eg LEDDIGIT_F_SET_SEGMENTS + 9 will turn on the top and bottom segments. Again LEDDIGIT_F_SHOW_DP and
005202  005833  // 	: LEDDIGIT_F_DP_COMMA can be used, but in this case the DP is the 8th segment. 
005203  005834  // Returns : nothing.
005204  005835        
005205  005836  func widget_Create("count"), 1;
005206  005837  // Syntax 	: widget_Create("count"),
005207  005838  // Usage  	: widget_Create(count);
005208  005839  // Notes  	: Creates a widget Control capable of hoolding count elements and returns
005209  005840  //        	: a handle for the control.
005210  005841  // Returns	: Widget control handle.
005211  005842        
005212  005843  func widget_Add("hndl", "index", "widget"), 1;
005213  005844  // Syntax 	: widget_Add("hndl", "index", "widget"),
005214  005845  // Usage  	: widget_Add(hndl, index, widget);
005215  005846  // Notes  	: Add a widget ram entry "widget" into index "index" of the widget control referenced
005216  005847  //        	: by "hndl".
005217  005848  // Returns	: ssnothing.
005218  005849        
005219  005850  func widget_Delete("hndl", "index"), 1;
005220  005851  // Syntax 	: widget_Delete("hndl", "index"),
005221  005852  // Usage  	: widget_Delete(hndl, index);
005222  005853  // Notes  	: Delete widget ram entry "index" from the widget control referenced by "hndl".
005223  005854  // Returns	: sssnothing.
005224  005855        
005225  005856  func widget_Realloc("handle", "n"), 1;
005226  005857  // Syntax	: widget_Realloc(handle, n);
005227  005858  // Usage 	: Resizes a widget control to contain n entries, allowing it to be expanded or
005228  005859  //      	: condensed. Doing this unnecessarily can lead to RAM fragmentation. It is
005229  005860  //             	: much better to allocate widget controls once with the desired number of entries.
005230  005861  // Returns	: new handle to widget control.
005231  005862        
005232  005863  func widget_GetWord("hndl", "index", "offset"), 1;
005233  005864  // Syntax	: myvar := widget_GetWord("handle", "index", "offset");
005234  005865  // Usage 	: myvar := widget_GetWord(hndl, 5, WIDGET_YPOS);
005235  005866  // Notes 	: returns specified word (0-14) from a widget entry
005236  005867  //       	: refer to widget control entry offsets.
005237  005868        
005238  005869  func widget_Setposition("hndl", "index", "xpos", "ypos"), 1;
005239  005870  // Syntax	: widget_SetPosition(handle, index, xpos, ypos);
005240  005871  // Usage 	: r := widget_SetPosition(hImageList, imagenum, x, y);
005241  005872  // Notes 	: set the position of the widget control
005242  005873  //       	: returns true if index was ok and function was successful.
005243  005874        
005244  005875  func widget_Enable("hndl", "index"), 1;
005245  005876  // Syntax	: widget_Enable(handle, index);
005246  005877  // Usage 	: r := widget_Enable(hImageList, imagenum);
005247  005878  // Notes 	: enable an item in a widget control.
005248  005879  // Returns     	: true if index was ok and function was successful.
005249  005880        
005250  005881  func widget_Disable("hndl", "index"), 1;
005251  005882  // Syntax	: widget_Disable(handle, index);
005252  005883  // Usage 	: r := widget_Disable(hImageList, imagenum);
005253  005884  // Notes 	: disable an inetm in a widget control.
005254  005885  // Returns      : true if index was ok and function was successful.
005255  005886        
005256  005887  func widget_SetWord("hndl", "index", "offset", "value"), 1;
005257  005888  // Syntax: widget_SetWord(handle, index, offset, word);
005258  005889  // Usage : widget_SetWord(hndl, 5, IMAGE_XPOS, 10);
005259  005890  // Notes : set specified word (0-7) in a image entry
005260  005891  //       : returns TRUE if successful, return value usually ignored.
005261  005892        
005262  005893  func widget_SetAttributes("hndl", "index", "value"), 1;
005263  005894  // Syntax: widget_SetAttributes("handle", "index","offset");
005264  005895  // Usage : widget_SetAttributes(hndl, 5, I_TOPMOST);
005265  005896  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
005266  005897  //       : of an image control entry. "value" refers to various bits in
005267  005898  //       : the image control entry (see image attribute flags).
005268  005899  //       : A '1' bit in the "value" field SETS the respective bit
005269  005900  //       : in the IMAGE_FLAGS field of the image control entry.
005270  005901  //       : returns TRUE if successful, return value usually ignored.
005271  005902        
005272  005903  func widget_ClearAttributes("hndl", "index", "value"), 1;
005273  005904  // Syntax: widget_ClearAttributes("handle", "index","offset");
005274  005905  // Usage : widget_ClearAttributes(hndl, 5, I_TOPMOST);
005275  005906  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
005276  005907  //       : of an image control entry. "value" refers to various bits in
005277  005908  //       : the image control entry (see image attribute flags)
005278  005909  //       : a '1' bit in the "value" field CLEARS the respective bit
005279  005910  //       : in the IMAGE_FLAGS field of the image control entry.
005280  005911  //       : returns TRUE if successful, return value usually ignored.
005281  005912        
005282  005913  func widget_Touched("hndl", "index"), 1;
005283  005914  // Syntax: r := widget_Touched(handle, index);
005284  005915  // Usage : widget_Touched(hndl, 17);
005285  005916  //       : returns -1 if image not touched, or returns index
005286  005917  // Notes : if index is passed as -1, function tests all images,
005287  005918  //       : and returns -1 if image not touched, or returns index.
005288  005919        
005289  005920  #CONST
005290  005958  #END
005291  005959        
005292  005960  func gfx_Slider5("value", "&SliderRam", "&SliderDef"), 0;                           // draw a slider
005293  005961  // Syntax 	: gfx_Slider5("value", "&SliderRam", "&SliderDef") ;
005294  005962  // Usage 	: gfx_Slider5(value, SliderRam, SliderDef) ;
005295  005963  // Notes 	: Draw a Slider as defined by SliderDef (if required), using SliderRam positioning at
005296  005964  // 	: position value. See the reference for the SliderDef values
005297  005965  //
005298  005966        
005299  005967  #CONST
005300  005986  #END
005301  005987        
005302  005988  func gfx_Switch("state", "&SwitchRam", "&SwitchDef"), 0;                           // draw a switch
005303  005989  // Syntax 	: gfx_Switch("state", "&SwitchRam", "&SwitchDef") ;
005304  005990  // Usage 	: gfx_Switch(state, SwitchRam, SwitchDef) ;
005305  005991  // Notes 	: Draw a Switch as defined by SwitchDef (if required), using SwitchRam positioning at
005306  005992  // 	: position value. See the reference for the SwitchDef values
005307  005993  //
005308  005994        
005309  005995  #CONST
005310  006024  #END
005311  006025        
005312  006026  func gfx_Button4("state", "&gfx_ButtonRam", "&gfx_ButtonDef"), 0;                           // draw a button
005313  006027  // Syntax 	: gfx_Button4("state", "&ButtonRam", "&ButtonDef") ;
005314  006028  // Usage 	: gfx_Button4(state, ButtonRam, ButtonDef) ;
005315  006029  // Notes 	: Draw a Button as defined by ButtonDef (if required), using ButtonRam positioning at
005316  006030  // 	: position value. See the reference for the ButtonDef values
005317  006031  //
005318  006032        
005319  006033  #CONST
005320  006048  #END
005321  006049        
005322  006050  func gfx_Led("state", "&LedRam", "&LedDef"), 0;                           // draw an LED
005323  006051  // Syntax 	: gfx_Led("state", "&LedRam", "&LedDef") ;
005324  006052  // Usage 	: gfx_Led(state, LedRam, LedDef) ;
005325  006053  // Notes 	: Draw a Led as defined by LedDef (if required), using LedRam positioning in
005326  006054  // 	: state state. See the reference for the LedDef values
005327  006055  //
005328  006056        
005329  006057  #CONST
005330  006075  #END
005331  006076  #CONST
005332  006094  #END
005333  006095        
005334  006096  func gfx_Scale("&ScaleRam", "&ScaleDef"), 0;                           // draw a Scale
005335  006097  // Syntax 	: gfx_Scale("&ScaleRam", "&ScaleDef") ;
005336  006098  // Usage 	: gfx_Scale(ScaleRam, ScaleDef) ;
005337  006099  // Notes 	: Draw a Scale as defined by ScaleDef, setting LedRam for use in touch processing.
005338  006100  // 	: See the reference for the ScaleDef values. If touch processing is not required 0 may be used as the SclaleRam parameter.
005339  006101  //
005340  006102        
005341  006103  #CONST
005342  006107  #END
005343  006108        
005344  006109  #CONST
005345  006129  #END
005346  006130        
005347  006131  func gfx_RulerGauge("state", "&RulerGaugeRam", "&RulerGaugeDef"), 0;                           // draw a Ruler Gauge
005348  006132  // Syntax 	: gfx_Led("position", "&RulerGaugeRam", "&RulerGaugeDef") ;
005349  006133  // Usage 	: gfx_Led(position, RulerGaugeRam, RulerGaugeDef) ;
005350  006134  // Notes 	: Draw a RulerGauge as defined by RulerGaugeDef (if required), using RulerGaugeRam positioning at
005351  006135  // 	: position value. See the reference for the RulerGaugeDef values
005352  006136  //
005353  006137        
005354  006138  #CONST
005355  006148  #END
005356  006149        
005357  006150  func file_CheckUpdate("Filename", "Options"), 1;                           // check and/or update the program running in Flash
005358  006151  // Syntax 	: file_CheckUpdate("Filename", "Options") ;
005359  006152  // Usage 	: file_CheckUpdate("thisfile.4xe", CheckUpdate_Check) ;
005360  006153  // Notes 	: Check and/or update the program running in flash using the specified file on uSD.
005361  006154  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
005362  006155  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
005363  006156  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
005364  006157  //
005365  006158  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
005366  006159  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
005367  006160  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
005368  006161  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
005369  006162  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
005370  006163  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
005371  006164        
005372  006165  func img_FileRead("*dest", "size", "handle", "index"), 1;
005373  006166  // Syntax: res := img_FileRead("*dest", "size", "handle", "index"),
005374  006167  // Usage : res := img_FileRead(memblock,20,hnd1);
005375  006168  // Notes : returns number of characters read
005376  006169  //       : if "dest" is zero, data is read direct to GRAM window
005377  006170  //       :
005378  006171        
005379  006172  func img_FileSeek("handle", "index", "HiWord", "LoWord"), 1;
005380  006173  // Syntax: res := img_FileSeek("handle", "index", "HiWord", "LoWord")
005381  006174  // Usage : res := img_FileSeek(hSource, 0, 0x1234);
005382  006175  // Notes : set file position to 0x00001234 (byte position 4660)
005383  006176  //       : for the file handle so subsequent data may be read
005384  006177  //       : from that position onwards with img_FileGetC(...),
005385  006178  //       : img_FileGetW(...) or img_FileGetS(...)
005386  006179  // Notes : returns true if ok, usually ignored
005387  006180        
005388  006181  func img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
005389  006182  // Syntax: img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
005390  006183  // Usage : res := img_FileIndex(hsource, 0, 1000, 123), 1;
005391  006184  // Notes : set file seek position to 123000
005392  006185  //       : for the file handle so subsequent data may be read
005393  006186  //       : from that record position onwards with img_FileGetC(...),
005394  006187  //       : img_FileGetW(...) or img_FileGetS(...)
005395  006188  // Notes : returns true if ok, usually ignored
005396  006189        
005397  006190  func img_FileTell("handle", "index", "&HiWord", "&LoWord"), 1;
005398  006191  // Syntax: img_FileTell("handle", "index", &HiWord, &LoWord);
005399  006192  // Usage : img_FileTell(fhndl, &SizeHi, &SizeLo);
005400  006193  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
005401  006194  //       : returns true if function succeeded
005402  006195        
005403  006196  func img_FileSize("handle", "index", "&HiWord", "&LoWord"), 1;
005404  006197  // Syntax: img_FileSize("handle", "index", &HiWord, &LoWord);
005405  006198  // Usage : img_FileSize(fhndl, &SizeHi, &SizeLo);
005406  006199  // Notes : Reads the 32 bit file size and stores it into 2 variables.
005407  006200  //       : returns true if function succeeded
005408  006201        
005409  006202  func img_FileGetC("handle", "index"), 1;
005410  006203  // Syntax: img_FileGetC("handle", "index");
005411  006204  // Usage : mychar := fgetC("handle", "index");
005412  006205  // Notes : returns next char from file
005413  006206        
005414  006207  func img_FileGetW("handle", "index"), 1;
005415  006208  // Syntax: img_FileGetW("handle", "index");
005416  006209  // Usage : myword := fgetW("handle", "index");
005417  006210  // Notes : returns next word in file
005418  006211        
005419  006212  func img_FileGetS("*string", "size", "handle", "index"), 1;
005420  006213  // Syntax: res := img_FileGets("*string", "size", "handle", "index");
005421  006214  // Usage : res := img_FileGets(mystr , 81, hnd1); // read up to 80 chars
005422  006215  // Notes : get a string from a file
005423  006216  //       : returns pointer to string or null if failed.
005424  006217  //       : img_FileGetS(...) automatically appends a null-terminator to the data read.
005425  006218  //       : NB:- only reads up to "size-1" characters into "string"
005426  006219  //       : img_FileGetS(...) will stop reading when any of the following conditions are true:
005427  006220  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
005428  006221  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
005429  006222  //       : C] It reaches the end of file
005430  006223  //       : D] A read error occurs.
005431  006224        
005432  006225  func img_FileRewind("handle", "index"), 1;
005433  006226  // Syntax: res := img_FileRewind("handle", "index");
005434  006227  // Usage : res := img_FileRewind(hnd1);
005435  006228  // Notes : returns true if file rewound ok (usually ignored)
005436  006229  //       : resets the file pointer the the beginning of the open file.
005437  006230        
005438  006231  func img_FileLoadFunction("handle", "index"), 1;
005439  006232  // Syntax: res := img_FileLoadFunction("handle", "index");
005440  006233  // Usage : myfunc := img_FileLoadFunction("handle", "index");
005441  006234  // Notes : Load a function or program from disk and
005442  006235  //       : return a function pointer to the allocation.
005443  006236  //       : The function can then be invoked just like any other
005444  006237  //       : function would be called via a function pointer.
005445  006238  //       : Parameters may be passed to it in a conventional way.
005446  006239  //       : The function may be discarded at any time when no
005447  006240  //       : longer required, thus freeing its memory resources.
005448  006241  //       : The loaded function can be discarded with mem_Free(..)
005449  006242  //       : eg:
005450  006243  //       : popupWindow := img_FileLoadFunction("handle", "index");
005451  006244  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
005452  006245  //       : then elsewhere in your program:-
005453  006246  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
005454  006247  //       : if(res == QUIT_APPLICATION) goto exitApp;
005455  006248  //       : Later in your program, when popupWindow is no longer
005456  006249  //       : required for the application:-
005457  006250  //       : res := mem_Free(popupWindow);
005458  006251  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
005459  006252  //       : The callers stack is shared by the loaded function,
005460  006253  //       : however any global variables in the loaded function
005461  006254  //       : are private to that function.
005462  006255  //
005463  006256        
005464  006257  func img_FileRun("handle", "index", "arglistptr"), 1;
005465  006258  // Syntax: res := img_FileRun("handle", "index","arglistptr");
005466  006259  // Usage : res := img_FileRun("handle", "index", argptr);
005467  006260  // Notes : current program releases any allocated memory but
005468  006261  //       : retains the stack and global memory.
005469  006262  //       : If arglistptr is 0, no arguments are passed, else
005470  006263  //       : arglist points to an array, the first element being
005471  006264  //       : the number of elements in the array.
005472  006265  //       : func 'main' in the called program accepts
005473  006266  //       : the arguments, if any. THe arguments can only
005474  006267  //       : be passed by value, no pointers or references can be
005475  006268  //       : used as all memory is cleared before the file
005476  006269  //       : is loaded. Refer to img_FileExec and img_FileLoadFunction
005477  006270  //       : for functions that can pass by reference.
005478  006271        
005479  006272  func img_FileExec("handle", "index", "arglistptr"), 1;
005480  006273  // Syntax: res := img_FileExec("handle", "index","arglistptr");
005481  006274  // Usage : res := img_FileExec("handle", "index","arglistptr");
005482  006275  // Notes : returns like a function, current program
005483  006276  //       : calling program is kept active and control returns to it.
005484  006277  //       : If arglistptr is 0, no arguments are passed, else
005485  006278  //       : arglist points to an array, the first element being
005486  006279  //       : the number of elements in the array.
005487  006280  //       : func 'main' in the called program accepts the arguments.
005488  006281  //       : This function is similar to img_FileLoadFunction(...), however,
005489  006282  //       : the function argument list is passed by pointer, and
005490  006283  //       : the memory consumed by the function is released as
005491  006284  //       : soon as the function completes.
005492  006285        
005493  006286  func img_FilePlayWAV("handle", "index"), 1;
005494  006287  // Syntax: img_FilePlayWAV("handle", "index");
005495  006288  // Usage : img_FilePlayWAV("handle", "index");
005496  006289  // Notes : Play a wave file at index "index" in the filesystem "handle"
005497  006290  //       : This function automatically grabs a chunk
005498  006291  //       : of memory for a file buffer, and a wave
005499  006292  //       : buffer. The minimum memory requirement is
005500  006293  //       : about 580 bytes for the disk io service and
005501  006294  //       : a minimum wave buffer size of 1024. The siz
005502  006295  //       : of the wave buffer allocation
005503  006296  //       : can be increased by the snd_BufSize function.
005504  006297  //       : The default size 1024 bytes.
005505  006298  //       : NB the memory is only required during the
005506  006299  //       : duration of play, and is automatically
005507  006300  //       : released while not in use.
005508  006301  //       : See the Sound Class services for other associated controls.
005509  006302  //       : If there are no errors, returns number of blocks to play (1 to 32767)
005510  006303  //       : If errors occured, the folling is returned
005511  006304  //       : -7  : Insufficient memory available for WAV buffer and file
005512  006305  //       : -6  : cant play this rate
005513  006306  //       : -5  : no data chunk found in first rsector
005514  006307  //       : -4  : no format data
005515  006308  //       : -3  : no wave chunk signature
005516  006309  //       : -2  : bad wave file format
005517  006310  //       : -1  : file not found
005518  006311        
005519  006312  func img_TxtFontID("handle", "index"), 1;                   // 2  text font ID (0 = system font)
005520  006313  // Syntax: img_TxtFontID("handle", "index");
005521  006314  // Usage : img_TxtFontID("handle", "index");
005522  006315  // Notes : Set the font to a font held in the image file system
005523  006316        
005524  006317  func spiflash_Block32Erase("spi#", "enablepin"), 1;            // erase the required 32k flash block
005525  006318  // Syntax	: flash_Block32Erase("spi#", "enablepin");
005526  006319  // Usage	: flash_Block32Erase(SPI1, PA0);
005527  006320  // Notes	: Erase the 32KB flash block including the currently set address
005528  006321  // 	: This uses the 0x52 command.
005529  006322        
005530  006323  func spiflash_Sector4Erase("spi#", "enablepin"), 1;            // erase the required 4k flash sector
005531  006324  // Syntax: flash_Sector4Erase("spi#", "enablepin");
005532  006325  // Usage : flash_Sector4Erase(SPI1, PA0);
005533  006326  // Notes	: Erase the 4KB flash sector including the currently set address
005534  006327  // 	: This uses the 0x20 command.
005535  006328        
005536  006329  func flash_FunctionCall("bank", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in a Flash GCI
005537  006330  // Syntax: img_FunctionCall(bank, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
005538  006331  // Usage : img_FunctionCall(bank, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
005539  006332  // Notes	: Calls the Flashbank passing index "index" as the first parameter. 
005540  006333  // 	: Other parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The second two parameters are passed
005541  006334  // 	: "as is", since the third parameter is normally in flash and one banks flash is not accessible from another
005542  006335  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
005543  006336  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
005544  006337  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
005545  006338  // 	: Returns 0 if successful.
005546  006339        
005547  006340  func flash_LoadSPIflash("bank", "hndl", "idx"), 1;
005548  006341  // Syntax   : flash_LoadFile(bank, ptr);
005549  006342  // Usage    : result := flash_LoadFile(FLASHBANK_2, "TETRIS10.EXE"); // load the file from disk into FLASHBANK_2
005550  006343  // Notes    : Copies a file from uSD to the required flashbank.
005551  006344  //          : The destination bank cannont be the execution bank, or a bank that is write protected
005552  006345  // Returns  : returns true if the function succeeded.
005553  006346        
005554  006347  func gfx_GradientShape("GradientRAM", "HorzVert", "OuterWidth", "X", "Y", "W", "H", "TLrad", "TRrad", "BLrad", "BRrad", "Darken", "OuterColor", "OuterType", "OuterLevel", "InnerColor", "InnerType", "InnerLevel", "Split"), 0 ;
005555  006348  // Syntax 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
005556  006349  // Usage 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
005557  006350  // Notes 	: Produce a shaped color gradient using the supplied parameters.0
005558  006351  // 	: GradientRAM	This Function requires a quantity or RAM to work. It also needs to be initialised and it's size varies accoring to the largest corner radius. Multiple gradient shape calls can
005559  006352  // 	: 	share the same GradientRAM. eg gradientRAM[29+91*2] := [-1,-1,-9999,0,0,91] ;  Would support a maximum radius of 90 degrees, note the 91 in two places.
005560  006353  // 	: HorzVert	Horizontal or Vertical -- 0 or 1
005561  006354  // 	: OuterWidth	Outer gradient width 0 to ...
005562  006355  // 	: X	x co-ordinate
005563  006356  // 	: Y	y co-ordinate
005564  006357  // 	: W	width
005565  006358  // 	: H	height
005566  006359  // 	: LTrad	Top left corner radius
005567  006360  // 	: TRrad	Top right corner radius
005568  006361  // 	: BLrad	Bottom left radius
005569  006362  // 	: BRrad	Bottom right radius
005570  006363  // 	: Darken	Darken both colours by a value. Can be a -ve value to lighten
005571  006364  // 	: OuterCol	Outer Gradient colour
005572  006365  // 	: OuterType	Outer Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
005573  006366  // 	: OuterLevel	Outer Gradient level 0 - 63
005574  006367  // 	: InnerCol	Inner Gradient colour
005575  006368  // 	: InnerType	Inner Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
005576  006369  // 	: InnerLevel	Inner Gradient level 0 - 63
005577  006370  // 	: Split	Split gradient, 0 - no split, 1 - top, 2 - bottom 
005578  006371  // 
005579  006372  // Returns	: nothing
005580  006373        
005581  006374        
005582  006375  func gfx_GradientColor("Type", "Darken", "Level", "H", "Pos", "Color"), 1 ;
005583  006376  // Syntax 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
005584  006377  // Usage 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
005585  006378  // Notes 	: Given the parameters, adjust the input color to produce the output color.
005586  006379  // 	: Type	Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
005587  006380  // 	: Darken	Darken colour by a value. Can be a -ve value to lighten
005588  006381  // 	: Level	Gradient level 0 - 63
005589  006382  // 	: H	Height of the object that gradient is applied
005590  006383  // 	: Pos	Position in the height that gradient is calculated
005591  006384  // 	: Color	Source colour that gradient is applied to
005592  006385  // 
005593  006386  // Returns	: Color after Adjustment.
005594  006387        
005595  006388  func gfx_GradTriangleFilled("X0", "Y0", "X1", "Y1", "X2", "Y2", "SolidCol", "GradientCol", "GradientHeight", "GradientY", "GradientLevel", "Type"), 0;
005596  006389  // Syntax 	: gfx_GradTriangleFilled(X0, Y0, X1, Y1, X2, Y2, SolidCol, GradientCol, GradientHeight, GradientY, GradientLevel, Type);
005597  006390  // Usage 	: gfx_GradTriangleFilled(10, 10, 10, 100, 100, 100 ,YELLOW, DARKKHAKI, 100, 10, 30, 1);
005598  006391  // Notes 	: Produce a triangle with or without a gradient.
005599  006392  // 	: X0	First triangle point x coordinate
005600  006393  // 	: Y0	First triangle point y coordinate
005601  006394  // 	: X1	Second triangle point x coordinate
005602  006395  // 	: Y1	Second triangle point y coordinate
005603  006396  // 	: X2	Third triangle point x coordinate
005604  006397  // 	: Y2	Third triangle point y coordinate
005605  006398  // 	: SolidCol	Colour that will be used if the Solid or Gradient parameter is set to 0
005606  006399  // 	: GradientCol	Colour that will be used if the Solid or Gradient parameter is set to 1
005607  006400  // 	: GradientHeight	Height of the area that the gradient will be calculated. Can be larger than the triangle
005608  006401  // 	: GradientY	Position on the Y axis that the gradient will be calculated from with respect to triangle position
005609  006402  // 	: GradientLevel	Level of gradient applied
005610  006403  // 	: Type	Select wether solid triangle or gardient triangle is drawn. 
005611  006404        
005612  006405  func spiflash_ReadByte("flags", "spi#", "enablepin"), 1;
005613  006406  // Syntax	: res := spiflash_Read(flag, "spi#", "enablepin");
005614  006407  // Usage	: res := spiflash_Read(0, SPI1, PA0);
005615  006408  // Notes	: Reads a byte from the FLASH memory device on the specified SPI port and enable pin
005616  006409  // 	: and returns it. The enable pin is lowered at the start of the operation and raised at the 
005617  006410  // 	: end unless the flag is set to SPIFLASH_HOLDCS is set, in which case the pin is left low.
005618  006411  // 	:
005619  006412        
005620  006413  func spiflash_WriteByte("reg/value", "spi#", "enablepin"), 0;
005621  006414  // Syntax	: res := fwrite(reg, spi, enablepin);
005622  006415  // Usage	: res := fwrite(0x80, SPI1, PA0);
005623  006416  // Notes	: Writes the specified byte to the FLASH memory device on the specified SPI port and enable pin.
005624  006417  // 	: The value may be a command or value depending upon where it is written to relative to the lowering of CS.
005625  006418  // 	: The enable pin is lowered at the start of the operation and raised at the end unless the reg/value has 
005626  006419  // 	: SPIFLASH_HOLDCS orred onto it, in which case the pin is left low.
005627  006420  // 	:
005628  006421        
005629  006422  func spiflash_SetMode("spi#", "mode"), 0;
005630  006423  // Syntax	: res := fwrite("spi#", "mode");
005631  006424  // Usage	: res := fwrite(SPI1, SPIMODE_ADDRESS3);
005632  006425  // Notes	: Sets the address size to be used to access the FLASH memory device on the specified SPI port and enable pin.
005633  006426  // 	: The size should be set using the correct command for the SPI FLASH memory device you are using.
005634  006427  // 	: Then this function should be called to enable that addresing mode to be used.
005635  006428  // 	: valid options are 
005636  006429  // 	: SPIFLASH_ADDRESS3	Address operand is 3 bytes long
005637  006430  // 	: SPIFLASH_ADDRESS4	Address operand is 4 bytes long
005638  006431        
005639  006432  func spiflash_LoadGCFImageControl("spi#", "enablepin"), 1;    // load a GCF image control into memory
005640  006433  // Syntax	: hImagelist := spiflash_LoadGCFImageControl("spi#", "enablepin")
005641  006434  // Usage	: hImagelist := spiflash_LoadGCFImageControl(SPI0, USD_ENABLE)
005642  006435  // Notes	: Reads a GCF file on Flash memory to create an image list.
005643  006436  // 	: Returns NULL if function fails.
005644  006437  // 	: Returns a handle (pointer to the memory allocation) to the
005645  006438  // 	: image control list that has been created.
005646  006439  // 	: spiflash_SetAdd() should have previously been called to set the GCIF start location.
005647  006440  // 	: spi# is the SPI interface to which the Flash memory chip is located SPI0 for the uSD port, or SPI1, SPI2 or SPI3.
005648  006441  // 	: enablepin is the enable, or CS pin for the Flash meory chip PA0-PA15, or USD_ENABLE for the uSD's enable pin.
005649  006442        
005650  006443  func gfx_XYrotToVal("x","y","base","mina","maxa","minv","maxv"), 1;         // convert a rotational x/y postion to a value
005651  006444  // Usage	: gfx_XYrotToVal(x,y,XYROT_EAST,starta,enda,minv,maxv)
005652  006445  // Notes	: Convert a rotational angle into a value
005653  006446  // 	: Calculates a position for a rotary input starting at mina and continuing to maxa. both angles must be greater than 0.
005654  006447  // 	: Base can be XYROT_EAST, used for internal widgets, or XYROT_SOUTH, used for GCI widgets.
005655  006448  // 	: Returns a value from minv to maxv
005656  006449        
005657  006450  func gfx_XYlinToVal("x","y","base","minpos","maxpos","minv","maxv"), 1;         // convert a linear x/y postion to a value
005658  006451  // Usage	: gfx_XYrotToVal(x,y,XYLIN_X,startp,endp,minv,maxv)
005659  006452  // Notes	: Convert a linear position into a value
005660  006453  // 	: Calculates a position for a linear input starting at minpos and continuing to maxpos. 
005661  006454  // 	: Base can be XYLIN_X, to use the x value for calculations, or XYLIN_Y, to use the y value.
005662  006455  // 	: Returns a value from minv to maxv
005663  006456        
005664  006457  func I2CS_Open("Addr", "RdBuf", "RdBufSize", "WrBuf", "WrBufSize", "WaitOption"), 1;  // Open I2C Slave
005665  006458  // Usage	: I2CS_Open(Addr, RdBuf, RdBufS, WrBuf, WrBufs, 0xaa);
005666  006459  // Notes	: Initialize and open the I2C Slave 
005667  006460  // 	: The slave ACKs any transmissions from the master until the read buffer fills
005668  006461  // 	: The slave NAKs any receives by the master until the write buffer is released, or is empty
005669  006462  // 	: Addr	The I2C Address for this Slave
005670  006463  // 	: RdBuf	The buffer for receiving 'commands' from the master
005671  006464  // 	: RdBufSize	The size of the receive buffer 
005672  006465  // 	: WrBuf	The buffer for sending 'responses' to the master
005673  006466  // 	: WrBufSize	The size of the write buffer
005674  006467  // 	: WaitOption	The character to send when no data is available, or all sent, or with I2C_CLOCK_STRETCHING to use clock stretching 
005675  006468  // 	: Response: None
005676  006469        
005677  006470  func I2CS_Close(), 0;          // Close I2C Slave
005678  006471  // Usage	: I2CS_Close();
005679  006472  // Notes	: Closes the I2C Slave 
005680  006473  // 	: Response: None
005681  006474        
005682  006475  func I2CS_Write("Byte"), 0;      // Write byte to output buffer
005683  006476  // Usage	: I2CS_Write("Byte");
005684  006477  // Notes	: Writes a byte to the I2C Slave Write Buffer
005685  006478  // 	: When everything to be written to the Master is in the write buffer, the buffer should be released
005686  006479  // 	: with I2CS_Release()
005687  006480  // 	: Response: None
005688  006481        
005689  006482  func I2CS_Count(), 1;          // Count of bytes in input buffer
005690  006483  // Usage	: I2CS_Count();
005691  006484  // Notes	: Retrieve the number of bytes available in the I2C Slave's read buffer
005692  006485  // 	: Response: Number of bytes in the buffer
005693  006486        
005694  006487  func I2CS_Read(), 1;           // Read byte from Read Buffer
005695  006488  // Usage	: I2CS_Read();
005696  006489  // Notes	: Read a byte from the I2C Slave's read buffer
005697  006490  // 	: Response: byte read from buffer
005698  006491        
005699  006492  func I2CS_Release(), 0;        // Release output buffer to enable Master to read
005700  006493  // Usage	: I2CS_Release();
005701  006494  // Notes	: Release an accumulated I2C Slave write buffer for sending to the master
005702  006495  // 	: Response: None
005703  006496        
005704  006497  func I2CS_Overflow(), 1;        // Check for any overflow in the read or write processes
005705  006498  // Usage	: I2CS_Overflow();
005706  006499  // Notes	: Check for any overflow in the read or write processes, the error is automatically
005707  006500  // 	: Reset at the start of the next I2CS_Write() or the last I2CS_Read() for the current buffer.
005708  006501  // 	: Response: Overflow flags
005709  006502  // 	: 0x01 : The host has sent more data than the I2CS_Read() buffer can hold
005710  006503  // 	: 0x02 : The host has read all the data the I2CS_Write() buffer contained
005711  006504  // 	: 0x04 : The host has read more data than the I2CS_Write() buffer contained
005712  006505        
005713  006506  //------------------------------------------------------------------//
005714  006507  //     SPIFLASH constants                                           //
005715  006508  //------------------------------------------------------------------//
005716  006509  #constant SPIFLASH_HOLDCS	0x8000	// CS is not lowered after this operation
005717  006509  #constant SPIFLASH_HOLDCS	0x8000	// CS is not lowered after this operation
005718  006510        
005719  006511  //------------------------------------------------------------------//
005720  006512  //     break control constant                                       //
005721  006513  //------------------------------------------------------------------//
005722  006514  #constant BREAK      0xFFFD    // interpretation of the break signal
005723  006514  #constant BREAK      0xFFFD    // interpretation of the break signal
005724  006515        
005725  006516  //------------------------------------------------------------------//
005726  006517  // CONSTANTS
005727  006518  //------------------------------------------------------------------//
005728  006519        
005729  006520  #CONST
005730  006622  #END
005731  006623        
005732  006624  #CONST
005733  006629  #END
005734  006630        
005735  006631  // timebase constants for timebase_init
005736  006632  // NB only TB2 and TB4 can be used for synchronous A2D sampling.
005737  006633  #CONST
005738  006644  #END
005739  006645        
005740  006646        
005741  006647  // generic constants
005742  006648  #CONST
005743  006656  #END
005744  006657        
005745  006658        
005746  006659        
005747  006660  //gfx_Get() related constants
005748  006661  #CONST
005749  006670  #END
005750  006671        
005751  006672        
005752  006673        
005753  006674        
005754  006675  #CONST
005755  006688  #END
005756  006689        
005757  006690        
005758  006691  #CONST
005759  006716  #END
005760  006717        
005761  006718        
005762  006719        
005763  006720        
005764  006721  // timer control  related constants
005765  006722  #CONST
005766  006731  #END
005767  006732        
005768  006733        
005769  006734        
005770  006735  //------------------------------------------------------------------------------
005771  006736  // system WORD variables accesible with peekW and pokeW or pointer access
005772  006737  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
005773  006738  // can also be accessed with peekW and pokeW
005774  006739  //------------------------------------------------------------------------------
005775  006740        
005776  006741  #CONST
005777  006836  #END
005778  006837        
005779  006838  #CONST
005780  007003  #END
005781  007004        
005782  007005        
005783  007006        
005784  007007  //==================================================================================================
005785  007008        
005786  007009        
005787  007010        
005788  000013      #ENDIF
005789  000014        
005790  000015      #CONST
005791  000102      #END
005792  000103        
005793  000104  //===========================================================================================
005794  000105        
005795  000106        
005796  000002        
005797  000003  //#constant OLDCOMPILE
005798  000004        
005799  000005        
005800  000006  // generated 3/28/2023 11:39:46 AM
005801  000007  // uSDRequired:- 1   InternalRequired:- 1
005802  000008        
005803  000009  #MODE FLASHBANK_1
005804  000010        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

005805  000011  #inherit "4DGL_16bitColours.fnc"
005806  000011  #inherit "4DGL_16bitColours.fnc"
005807  000004  */
005808  000005        
005809  000006        
005810  000007        
005811  000008  #CONST
005812  000149  #END
005813  000150        
005814  000012        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

005815  000013  #inherit "VisualConst.inc"
005816  000013  #inherit "VisualConst.inc"
005817  000001  // Line Patterns
005818  000002  #constant  LPCOARSE    0xF0F0
005819  000002  #constant  LPCOARSE    0xF0F0
005820  000003  #constant  LPMEDIUM    0x3333
005821  000003  #constant  LPMEDIUM    0x3333
005822  000004  #constant  LPFINE      0xAAAA
005823  000004  #constant  LPFINE      0xAAAA
005824  000005  #constant  LPDASHDOT   0x03CF
005825  000005  #constant  LPDASHDOT   0x03CF
005826  000006  #constant  LPDASHDOTDOT 0x0333
005827  000006  #constant  LPDASHDOTDOT 0x0333
005828  000007  #constant  LPSOLID     0x0000
005829  000007  #constant  LPSOLID     0x0000
005830  000014        
005831  000015        
file C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-ControlConst.inc

005832  000016  #inherit "HMI-ControlConst.inc"
005833  000016  #inherit "HMI-ControlConst.inc"
005834  000001  // File generated 3/28/2023 11:39:40 AM
005835  000002  // Warning! This is a generated file, any manual changes will be
005836  000003  // lost during the next generation.
005837  000004        
005838  000007  #END
5839  0012
5840  0013
5841  0014
5842  0015
5843  0016
5844  0017
5845  0018
5846  0019
5847  001A
5848  001B
5849  001C
5850  001D
005851  000008        
005852  000009        
005853  000010  #constant  IFONT_OFFSET     0
005854  000010  #constant  IFONT_OFFSET     0
005855  000011  // object indexes into WIDGET pointer
005856  000012  #CONST
005857  000014  #END
005858  000015        
005859  000016  // object indexes into ImageControl
005860  000017  #CONST
005861  000058  #END
005862  000059        
005863  000060        
005864  000061        
005865  000062  #IFNOT EXISTS NOGLOBALS
005866  000063  var hndl ;
005867  000064  var oKeyboard0[12] := [-1, 0, 0, 0, 0, 255, 255, 255, 255, 255, 12, 0] ;
5868  002A
5869  002B
5870  002C
5871  002D
5872  002E
5873  002F
5874  0030
5875  0031
5876  0032
5877  0033
5878  0034
5879  0035
5880  0036
5881  0037
5882  0038
5883  0039
5884  003A
5885  003B
5886  003C
5887  003D
5888  003E
5889  003F
5890  0040
5891  0041
005892  000065  #ENDIF
005893  000017        
005894  000018        
005895  000019        
005896  000020  #constant IPDatasize 22
005897  000020  #constant IPDatasize 22
005898  000021        
005899  000022  #CONST
005900  000026  #END
005901  000027        
005902  000028        
005903  000029        
005904  000030  #CONST
005905  000174  #END
005906  000175        
005907  000176  #CONST
005908  000189  #END
005909  000190        
005910  000191  #constant KbShiftBit        01
005911  000191  #constant KbShiftBit        01
005912  000192  #constant KbCapsBit         02
005913  000192  #constant KbCapsBit         02
005914  000193  #constant KbShiftCapsBits   03
005915  000193  #constant KbShiftCapsBits   03
005916  000194  #constant KbCtrlBit         04
005917  000194  #constant KbCtrlBit         04
005918  000195        
005919  000196  func refreshstate(var iKB, var oKB)
005920  000197      var shifted ;
005921  000198      shifted := oKB[Ofs_kb_State] & KbShiftCapsBits ;
005922  000199      if (!shifted || (shifted == KbShiftCapsBits))
005923  000200          shifted := 0 ;
005924  000201          oKB[Ofs_kb_Caps] := 0 ;
005925  000202      else
005926  000203          shifted := 1 ;
005927  000204          oKB[Ofs_kb_Caps] := 2 ;
005928  000205      endif
005929  000206      setkeystate(iKB,shifted) ;
005930  000207      if (oKB[Ofs_kb_State] & KbCapsBit)
005931  000208          setkeystate(iKB + oKB[Ofs_kb_Lock],1) ;
005932  000209      endif
005933  000210      if ((oKB[Ofs_kb_State] & KbShiftBit) && (shifted))
005934  000211          setkeystate(iKB + oKB[Ofs_kb_Shift1],1) ;
005935  000212          setkeystate(iKB + oKB[Ofs_kb_Shift2],1) ;
005936  000213      endif
005937  000214      if (oKB[Ofs_kb_State] & KbCtrlBit)
005938  000215          setkeystate(iKB + oKB[Ofs_kb_Ctrl1],1) ;
005939  000216          setkeystate(iKB + oKB[Ofs_kb_Ctrl2],1) ;
005940  000217      endif
005941  000218  endfunc
005942  000219        
005943  000220  func kbDown(var iKB, var oKB, var KBKeys, var key)
005944  000221      var keyval, rtn ;
005945  000222      oKB[Ofs_kb_Mvt] := 1 ;
005946  000223      oKB[Ofs_kb_Ign]  := 0 ;
005947  000224      if ((key == oKB[Ofs_kb_Shift1]) || (key == oKB[Ofs_kb_Shift2]))
005948  000225          if (oKB[Ofs_kb_State] & KbShiftBit)
005949  000226              oKB[Ofs_kb_State] &= ~KbShiftBit ;
005950  000227              oKB[Ofs_kb_Mvt] := 0 ;
005951  000228          else
005952  000229              oKB[Ofs_kb_State] |= KbShiftBit ;
005953  000230          endif
005954  000231          refreshstate(iKB, oKB) ;
005955  000232          oKB[Ofs_kb_Ign] := 1 ;
005956  000233      else if ((key == oKB[Ofs_kb_Ctrl1]) || (key == oKB[Ofs_kb_Ctrl2]))
005957  000234          if (oKB[Ofs_kb_State] & KbCtrlBit)
005958  000235              oKB[Ofs_kb_State] &= ~KbCtrlBit ;
005959  000236              oKB[Ofs_kb_Mvt] := 0 ;
005960  000237          else
005961  000238              oKB[Ofs_kb_State] |= KbCtrlBit ;
005962  000239          endif
005963  000240          setkeystate(iKB+oKB[Ofs_kb_Ctrl1],oKB[Ofs_kb_Mvt]) ;
005964  000241          key := oKB[Ofs_kb_Ctrl2] ;
005965  000242          oKB[Ofs_kb_Ign] := 1 ;
005966  000243      else if (key == oKB[Ofs_kb_Lock])
005967  000244          if (oKB[Ofs_kb_State] & KbCapsBit)
005968  000245              oKB[Ofs_kb_State] &= ~KbCapsBit ;
005969  000246              oKB[Ofs_kb_Mvt] := 0 ;
005970  000247          else
005971  000248              oKB[Ofs_kb_State] |= KbCapsBit ;
005972  000249          endif
005973  000250          refreshstate(iKB, oKB) ;
005974  000251          oKB[Ofs_kb_Ign] := 1 ;
005975  000252      endif
005976  000253        
005977  000254      if (!oKB[Ofs_kb_Ign])
005978  000255          if (oKB[Ofs_kb_ShiftCaps])
005979  000256              keyval := (oKB[Ofs_kb_State] & KbShiftCapsBits) * oKB[Ofs_kb_Buttons] - 1 ;
005980  000257          else if (((oKB[Ofs_kb_State] & KbShiftCapsBits) == 0) || ((oKB[Ofs_kb_State] & KbShiftCapsBits) == KbShiftCapsBits))
005981  000258                  keyval := - 1 ;
005982  000259              else
005983  000260                  keyval := oKB[Ofs_kb_Buttons] - 1 ;
005984  000261          endif
005985  000262          keyval := KBKeys[key+keyval] ;
005986  000263          if (oKB[Ofs_kb_State] & KbCtrlBit) keyval &= 0x9F ;
005987  000264  	rtn := rKeyboardRoutines[ActiveKeyboard] ;
005988  000265          rtn(REPORT_EVENT, tKeyboard, ActiveKeyboard, keyval & 0xff) ;
005989  000266          setkeystate(iKB+key,oKB[Ofs_kb_Mvt]+oKB[Ofs_kb_Caps]) ;
005990  000267      endif
005991  000268      oKB[Ofs_kb_Down] := key ;
005992  000269  endfunc
005993  000270        
005994  000271  func setkeystate(var key, var idx)
005995  000272      img_SetWord(hndl, key,IMAGE_INDEX, idx);
005996  000273      img_Show(hndl,key) ;
005997  000274  endfunc
005998  000275        
005999  000276  func kbUp(var iKB, var oKB)
006000  000277      if (!oKB[Ofs_kb_Ign])
006001  000278          setkeystate(iKB + oKB[Ofs_kb_Down],oKB[Ofs_kb_Caps]) ;
006002  000279          if (oKB[Ofs_kb_State] & KbShiftBit)
006003  000280              oKB[Ofs_kb_State] &= ~KbShiftBit ;
006004  000281              refreshstate(iKB, oKB) ;
006005  000282          endif
006006  000283          if (oKB[Ofs_kb_State] & KbCtrlBit)
006007  000284              oKB[Ofs_kb_State] &= ~KbCtrlBit ;
006008  000285              setkeystate(iKB + oKB[Ofs_kb_Ctrl1],0) ;
006009  000286              setkeystate(iKB + oKB[Ofs_kb_Ctrl2],0) ;
006010  000287          endif
006011  000288          oKB[Ofs_kb_Down] := -1 ;
006012  000289      endif
006013  000290  endfunc
006014  000291        
006015  000336  #END
6016  0321
6017  0322
6018  0323
6019  0324
6020  0325
6021  0326
6022  0327
6023  0328
6024  0329
6025  032A
6026  032B
6027  032C
6028  032D
6029  032E
6030  032F
6031  0330
6032  0331
6033  0332
6034  0333
6035  0334
6036  0335
6037  0336
6038  0337
6039  0338
6040  0339
6041  033A
6042  033B
6043  033C
6044  033D
6045  033E
6046  033F
6047  0340
6048  0341
6049  0342
6050  0343
6051  0344
6052  0345
6053  0346
6054  0347
6055  0348
6056  0349
6057  034A
6058  034B
6059  034C
6060  034D
6061  034E
6062  034F
6063  0350
6064  0351
6065  0352
6066  0353
6067  0354
6068  0355
6069  0356
6070  0357
6071  0358
6072  0359
6073  035A
6074  035B
6075  035C
6076  035D
6077  035E
6078  035F
6079  0360
6080  0361
6081  0362
6082  0363
6083  0364
6084  0365
6085  0366
6086  0367
6087  0368
6088  0369
6089  036A
6090  036B
6091  036C
6092  036D
6093  036E
6094  036F
6095  0370
6096  0371
6097  0372
6098  0373
6099  0374
6100  0375
6101  0376
6102  0377
6103  0378
6104  0379
6105  037A
6106  037B
6107  037C
6108  037D
6109  037E
6110  037F
6111  0380
6112  0381
6113  0382
6114  0383
6115  0384
6116  0385
6117  0386
6118  0387
6119  0388
6120  0389
6121  038A
6122  038B
6123  038C
6124  038D
6125  038E
6126  038F
6127  0390
6128  0391
6129  0392
6130  0393
6131  0394
6132  0395
6133  0396
6134  0397
6135  0398
6136  0399
6137  039A
6138  039B
6139  039C
6140  039D
6141  039E
6142  039F
6143  03A0
6144  03A1
6145  03A2
6146  03A3
6147  03A4
6148  03A5
6149  03A6
6150  03A7
6151  03A8
6152  03A9
6153  03AA
6154  03AB
6155  03AC
6156  03AD
6157  03AE
6158  03AF
6159  03B0
6160  03B1
6161  03B2
6162  03B3
6163  03B4
6164  03B5
6165  03B6
6166  03B7
6167  03B8
6168  03B9
6169  03BA
6170  03BB
6171  03BC
6172  03BD
6173  03BE
6174  03BF
6175  03C0
6176  03C1
6177  03C2
6178  03C3
6179  03C4
6180  03C5
6181  03C6
6182  03C7
6183  03C8
6184  03C9
6185  03CA
6186  03CB
6187  03CC
6188  03CD
6189  03CE
6190  03CF
6191  03D0
6192  03D1
6193  03D2
6194  03D3
6195  03D4
6196  03D5
6197  03D6
6198  03D7
6199  03D8
6200  03D9
6201  03DA
6202  03DB
6203  03DC
6204  03DD
6205  03DE
6206  03DF
6207  03E0
6208  03E1
6209  03E2
6210  03E3
6211  03E4
6212  03E5
6213  03E6
6214  03E7
6215  03E8
6216  03E9
6217  03EA
6218  03EB
6219  03EC
6220  03ED
6221  03EE
6222  03EF
6223  03F0
6224  03F1
6225  03F2
6226  03F3
6227  03F4
6228  03F5
6229  03F6
6230  03F7
6231  03F8
6232  03F9
6233  03FA
6234  03FB
6235  03FC
6236  03FD
6237  03FE
6238  03FF
6239  0400
6240  0401
6241  0402
6242  0403
6243  0404
6244  0405
6245  0406
6246  0407
6247  0408
6248  0409
6249  040A
6250  040B
6251  040C
6252  040D
6253  040E
6254  040F
6255  0410
6256  0411
6257  0412
6258  0413
6259  0414
6260  0415
6261  0416
6262  0417
6263  0418
6264  0419
6265  041A
6266  041B
6267  041C
6268  041D
6269  041E
6270  041F
6271  0420
6272  0421
6273  0422
6274  0423
6275  0424
6276  0425
6277  0426
6278  0427
6279  0428
6280  0429
6281  042A
6282  042B
6283  042C
6284  042D
6285  042E
6286  042F
6287  0430
6288  0431
6289  0432
6290  0433
6291  0434
6292  0435
6293  0436
6294  0437
6295  0438
6296  0439
6297  043A
6298  043B
6299  043C
6300  043D
6301  043E
6302  043F
6303  0440
6304  0441
6305  0442
6306  0443
6307  0444
6308  0445
6309  0446
6310  0447
6311  0448
6312  0449
6313  044A
6314  044B
6315  044C
6316  044D
6317  044E
6318  044F
6319  0450
6320  0451
6321  0452
6322  0453
6323  0454
6324  0455
6325  0456
6326  0457
6327  0458
6328  0459
6329  045A
6330  045B
6331  045C
6332  045D
6333  045E
6334  045F
6335  0460
6336  0461
6337  0462
6338  0463
6339  0464
6340  0465
6341  0466
6342  0467
6343  0468
6344  0469
6345  046A
6346  046B
6347  046C
6348  046D
6349  046E
6350  046F
6351  0470
6352  0471
6353  0472
6354  0473
6355  0474
6356  0475
6357  0476
6358  0477
6359  0478
6360  0479
6361  047A
6362  047B
6363  047C
6364  047D
6365  047E
6366  047F
6367  0480
6368  0481
6369  0482
6370  0483
6371  0484
6372  0485
6373  0486
6374  0487
6375  0488
6376  0489
6377  048A
6378  048B
6379  048C
6380  048D
6381  048E
6382  048F
6383  0490
6384  0491
6385  0492
6386  0493
6387  0494
6388  0495
6389  0496
6390  0497
6391  0498
6392  0499
6393  049A
6394  049B
6395  049C
6396  049D
6397  049E
6398  049F
6399  04A0
6400  04A1
6401  04A2
6402  04A3
6403  04A4
6404  04A5
6405  04A6
6406  04A7
6407  04A8
6408  04A9
6409  04AA
6410  04AB
6411  04AC
6412  04AD
6413  04AE
6414  04AF
6415  04B0
6416  04B1
6417  04B2
6418  04B3
6419  04B4
6420  04B5
6421  04B6
6422  04B7
6423  04B8
6424  04B9
6425  04BA
6426  04BB
6427  04BC
6428  04BD
6429  04BE
6430  04BF
6431  04C0
6432  04C1
6433  04C2
6434  04C3
6435  04C4
6436  04C5
6437  04C6
6438  04C7
6439  04C8
6440  04C9
6441  04CA
6442  04CB
6443  04CC
6444  04CD
6445  04CE
6446  04CF
6447  04D0
6448  04D1
6449  04D2
6450  04D3
6451  04D4
6452  04D5
6453  04D6
6454  04D7
6455  04D8
6456  04D9
6457  04DA
6458  04DB
6459  04DC
6460  04DD
6461  04DE
6462  04DF
6463  04E0
6464  04E1
6465  04E2
6466  04E3
6467  04E4
6468  04E5
6469  04E6
6470  04E7
6471  04E8
6472  04E9
6473  04EA
6474  04EB
6475  04EC
6476  04ED
6477  04EE
6478  04EF
6479  04F0
6480  04F1
6481  04F2
6482  04F3
6483  04F4
6484  04F5
6485  04F6
6486  04F7
6487  04F8
6488  04F9
6489  04FA
6490  04FB
6491  04FC
6492  04FD
6493  04FE
6494  04FF
6495  0500
6496  0501
6497  0502
6498  0503
6499  0504
6500  0505
6501  0506
6502  0507
6503  0508
6504  0509
6505  050A
6506  050B
6507  050C
6508  050D
6509  050E
6510  050F
6511  0510
6512  0511
6513  0512
6514  0513
6515  0514
6516  0515
6517  0516
6518  0517
6519  0518
6520  0519
6521  051A
6522  051B
6523  051C
6524  051D
6525  051E
6526  051F
6527  0520
6528  0521
6529  0522
6530  0523
6531  0524
6532  0525
6533  0526
6534  0527
6535  0528
6536  0529
6537  052A
6538  052B
6539  052C
6540  052D
6541  052E
6542  052F
6543  0530
6544  0531
6545  0532
6546  0533
6547  0534
6548  0535
6549  0536
6550  0537
6551  0538
6552  0539
6553  053A
6554  053B
6555  053C
6556  053D
6557  053E
6558  053F
6559  0540
6560  0541
6561  0542
6562  0543
6563  0544
6564  0545
6565  0546
6566  0547
6567  0548
6568  0549
6569  054A
6570  054B
6571  054C
6572  054D
6573  054E
6574  054F
6575  0550
6576  0551
6577  0552
6578  0553
6579  0554
6580  0555
6581  0556
6582  0557
6583  0558
6584  0559
6585  055A
6586  055B
6587  055C
6588  055D
6589  055E
6590  055F
6591  0560
6592  0561
6593  0562
6594  0563
6595  0564
6596  0565
6597  0566
6598  0567
6599  0568
6600  0569
6601  056A
6602  056B
6603  056C
6604  056D
6605  056E
6606  056F
6607  0570
6608  0571
6609  0572
6610  0573
6611  0574
6612  0575
6613  0576
6614  0577
6615  0578
6616  0579
6617  057A
6618  057B
6619  057C
6620  057D
6621  057E
6622  057F
6623  0580
6624  0581
6625  0582
6626  0583
6627  0584
6628  0585
6629  0586
6630  0587
6631  0588
6632  0589
6633  058A
6634  058B
6635  058C
6636  058D
6637  058E
6638  058F
6639  0590
6640  0591
6641  0592
6642  0593
6643  0594
6644  0595
6645  0596
6646  0597
6647  0598
6648  0599
6649  059A
6650  059B
6651  059C
6652  059D
6653  059E
6654  059F
6655  05A0
6656  05A1
6657  05A2
6658  05A3
6659  05A4
6660  05A5
6661  05A6
6662  05A7
6663  05A8
6664  05A9
6665  05AA
6666  05AB
6667  05AC
6668  05AD
6669  05AE
6670  05AF
6671  05B0
6672  05B1
6673  05B2
6674  05B3
6675  05B4
6676  05B5
6677  05B6
6678  05B7
6679  05B8
6680  05B9
6681  05BA
6682  05BB
6683  05BC
6684  05BD
6685  05BE
6686  05BF
6687  05C0
6688  05C1
6689  05C2
6690  05C3
6691  05C4
6692  05C5
6693  05C6
6694  05C7
6695  05C8
6696  05C9
6697  05CA
6698  05CB
6699  05CC
6700  05CD
6701  05CE
6702  05CF
6703  05D0
6704  05D1
6705  05D2
6706  05D3
6707  05D4
6708  05D5
6709  05D6
6710  05D7
6711  05D8
6712  05D9
6713  05DA
6714  05DB
6715  05DC
6716  05DD
6717  05DE
6718  05DF
6719  05E0
6720  05E1
6721  05E2
6722  05E3
6723  05E4
6724  05E5
6725  05E6
6726  05E7
6727  05E8
6728  05E9
6729  05EA
6730  05EB
6731  05EC
6732  05ED
6733  05EE
6734  05EF
6735  05F0
6736  05F1
6737  05F2
6738  05F3
6739  05F4
6740  05F5
6741  05F6
6742  05F7
6743  05F8
6744  05F9
6745  05FA
6746  05FB
6747  05FC
6748  05FD
6749  05FE
6750  05FF
6751  0600
6752  0601
6753  0602
6754  0603
6755  0604
6756  0605
6757  0606
6758  0607
6759  0608
6760  0609
6761  060A
6762  060B
6763  060C
6764  060D
6765  060E
6766  060F
6767  0610
6768  0611
6769  0612
6770  0613
6771  0614
6772  0615
6773  0616
6774  0617
006775  000337        
006776  000338      var vISwitch0[WIDGET_RAM_SPACE] ;
006777  000339  var dKeyboard[1], ActiveKeyboard ;
006778  000340  // Start P2.inc
006779  000341  var vObjects[MaxIntObjects+1] ;              // address of RAM objects
006780  000342  var GObjectIdx, GObjectFunc, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings ;
006781  000343  var oObjects[MaxTotObjects+1] ;                 // address of objects
006782  000344  var CurrentForm, oldn, ImageTouched ;
006783  000345  var TouchXpos, TouchYpos ;
006784  000346  var GObjectType, TouchState, CurInputData, pInputIndex ;
006785  000347  var comRX[40], cmd[CMDLenMAX] ;
006786  000348        
006787  000349  var InputCS, OutputCS ;
006788  000350        
006789  000351  // > ? Constant/Global/Data ? <
006790  000352        
006791  000353        
006792  000354  func addressInternalWidget(var idx var iponly)
006793  000355      var i, j ;
006794  000356  //to(COM0) ; print("Address Int ", idx, " ") ;
006795  000357      if (iponly) 
006796  000358          GObjectIdx := xobj2iiobj[idx] ;
006797  000359      else
006798  000360          GObjectIdx := xobj2iobj[idx] ;
006799  000361      endif
006800  000362      GObjectType := (GObjectIdx>>8) ;                          // extract object type
006801  000363      i := oObjects[GObjectType] ;                              // i is address of list of all objects of this type
006802  000364      GObjectIdx &= 0xff ;
006803  000365      //GObjectIdx *= 2 ;
006804  000366      j := GObjectIdx * 2 ;
006805  000367      GObjectDATA := i[j + 2] ;                                 // address of this object
006806  000368      i := vObjects[GObjectType-tiAngularMeter] ;               // i is address of list of all ram objects of his type
006807  000369      GObjectRAM := i[j] ;                                      // address of this objects' ram
006808  000370      i := GObjectType-tiAngularMeter ;
006809  000371      GObjectFunc := gfxInternals[i] ; // address function
006810  000372      GObjectParms := gfxIntParms[i] ;
006811  000373      GObjectStrings := gfxIntStrings[i] ;
006812  000374  //to(COM0) ; print([HEX4] GObjectFunc, " ", [HEX4] GObjectRAM, " ", [HEX4] GObjectDATA, " ", GObjectType, " ", GObjectIdx, "\r\n") ;
006813  000375  //    GObjectFunc(0, GObjectRAM, GObjectDATA) ;
006814  000376  endfunc
006815  000377        
006816  000378  func seroutCS(var op)
006817  000379      serout(op) ;
006818  000380      OutputCS ^= op ;
006819  000381  endfunc
006820  000382        
006821  000383  func nak0()
006822  000384      serout(NAK) ;
006823  000385      InputCS := 0 ;
006824  000386  endfunc
006825  000387        
006826  000388  func seroutOcs()
006827  000389      serout(OutputCS) ;
006828  000390      OutputCS := 0 ;
006829  000391  endfunc
006830  000392        
006831  000393  func SendReport(var id, var objt, var objn, var val)
006832  000394      seroutCS(id) ;
006833  000395      seroutCS(objt) ;
006834  000396      seroutCS(objn) ;
006835  000397      seroutCS(val >> 8) ; // first 8 bits
006836  000398      seroutCS(val) ;
006837  000399      seroutOcs() ;
006838  000400  endfunc
006839  000401        
006840  000402        
006841  000403        
006842  000404  func ReadObject(var ObjectType, var ObjectIdx)
006843  000405      var j, k, Objects ;
006844  000406      if ((ObjectType >= tiLedDigitsH) && (ObjectType <= tiLinearInput))
006845  000407          j := ObjectIdx *2 ;
006846  000408          k := vObjects[ObjectType-tiAngularMeter] ;               // k is address of list of all ram objects of his type
006847  000409          k := k[j] ;                                              // k is address of this objects' ram
006848  000410          if (ObjectType == tiLedDigit)
006849  000411              k := k[0] ;
006850  000412          else 
006851  000413              k := k[WIDGET_VAL1] ;
006852  000414          endif
006853  000415  //gfx_MoveTo(0,0); txt_Opacity(OPAQUE) ; print(ObjectType, " ", ObjectIdx, " ", k," ") ;
006854  000416      else
006855  000417      Objects := *(oObjects+ObjectType) ;
006856  000418        
006857  000419      j := 2 + ObjectIdx * 2 + Objects ;
006858  000420       if (ObjectType == tForm)
006859  000421          k := CurrentForm ;
006860  000422      else if ((ObjectType == tCustomdigits) || (ObjectType == tLeddigits))
006861  000423          k := img_GetWord(hndl, *j, IMAGE_TAG2);
006862  000424          else
006863  000425          k := img_GetWord(hndl, *j, IMAGE_INDEX);
006864  000426          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
006865  000427                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
006866  000428      endif
006867  000429      endif
006868  000430      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
006869  000431  endfunc
006870  000432        
006871  000433  var wp ;
006872  000434        
006873  000435        
006874  000436  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
006875  000437      var i, j, k, Objects ;
006876  000438  //    ObjectType &= 0x3f ; Why was his there? Anibuttons? Complex cascades?
006877  000439  //to(COM0) ; print("WriteObject ", ObjectType, " ", ObjectIdx, " ", NewVal, "\r\n") ;
006878  000440      if (ObjectType == tForm)
006879  000441          ActivateForm(ObjectIdx) ;
006880  000442          return ;
006881  000443      endif
006882  000444          Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
006883  000445          i := *(Objects) ;
006884  000446  	if ((ObjectType >= tiAngularMeter) && (ObjectType <= tiLinearInput))
006885  000447              i := oObjects[ObjectType] ;                              // f is address of list of all objects of this type
006886  000448              j := ObjectIdx *2 ;
006887  000449              i := i[j + 2] ;                         // f is address of this object
006888  000450              k := vObjects[ObjectType-tiAngularMeter] ;               // a is address of list of all ram objects of his type
006889  000451              k := k[j] ;                             // a is address of this objects' ram
006890  000452                  j := ObjectType-tiAngularMeter ;
006891  000453                  Objects := gfxInternals[j] ;           // locate function address   
006892  000454              Objects(NewVal, k, i) ; 
006893  000455          return ;
006894  000456      endif
006895  000457          switch (ObjectType)
006896  000458              case tWinButton :
006897  000459                  j := InputControls[oWinButtons[ObjectIdx+1]] ;
006898  000460                  break ;
006899  000461              default : j := -1 ;
006900  000462          endswitch
006901  000463          if (j != -1)
006902  000464              k := img_GetWord(hndl, i , IMAGE_INDEX) ;
006903  000465              NewVal := NewVal << 1 ;
006904  000466              if (OVF())      // button group index change
006905  000467                  if (*(j+InputData+Ofs_IPD_P1))
006906  000468                      k &= 1 ;    // mask off old group index for momentary
006907  000469                  else
006908  000470                      k &= 3 ;    // mask off old group index for toggle
006909  000471                  endif
006910  000472              else            // normal set
006911  000473                  if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
006912  000474                  k &= 0xfffc ;    // retain only group index for state set
006913  000475              endif
006914  000476              NewVal |= k ;
006915  000477  //        endif
006916  000478          endif
006917  000479          if (ObjectType == tLeddigits)
006918  000480              img_SetWord(hndl, i , IMAGE_TAG2, NewVal); // where state is 0 to 2
006919  000481              ledDigitsDisplay(i, oLeddigitss, oLedDigitsn) ;
006920  000482              return ;
006921  000483          endif 
006922  000484              img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
006923  000485              img_Show(hndl, i) ; // will only display if form is current
006924  000486      return ; // compiler bug circumvention!
006925  000487  endfunc
006926  000488        
006927  000489  func TurnOffButtons(var group)
006928  000490      var j, k, l, m, n, o, p;
006929  000491      m := GObjectIdx ;     // save as will be clobbered
006930  000492      n := GObjectType ;     // save as will be clobbered
006931  000493      for (j := 0; j < nInputs; j++)
006932  000494          k := j*IPDatasize ;
006933  000495          if (*(InputData+k+Ofs_IPD_P2) == group)
006934  000496              l := -1 ;
006935  000497               if (*(InputData+k) == tWinButton)
006936  000498                  l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
006937  000499                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
006938  000500                  img_Show(hndl, l);      // only shows on current form
006939  000501        
006940  000502              endif
006941  000503          endif
006942  000504      next
006943  000505      GObjectIdx := m ;     // Restore
006944  000506      GObjectType := n ;    // Restore
006945  000507  endfunc
006946  000508        
006947  000509        
006948  000510  // WARNING, this code will crash if newval exceeds maximum displayable number
006949  000511  func ledDigitsDisplay(var imgidx, var typeptr, var setptr)
006950  000512      var i, j, k, l, lb, newval, num[4] ;
006951  000513      if (!((img_GetWord(hndl, imgidx, IMAGE_FLAGS) & I_ENABLED))) return ;  // ;img_GetWord(hndl, imgidx, IMAGE_TAG2) ;if diabled then exit
006952  000514      newval := img_GetWord(hndl, imgidx, IMAGE_TAG2) ;
006953  000515      i := -1 ;
006954  000516      j := *(typeptr) ;
006955  000517      repeat
006956  000518          typeptr += 2 ;
006957  000519          i++ ;
006958  000520          until (*(typeptr) == imgidx);
006959  000521      j := setptr + i*10 ;
006960  000522        
006961  000523      l := 0x500a | (*(j+Ofs_Digits_Digits) << 8) ;       // UDECxZ
006962  000524      to(num) ;
006963  000525      putnum(l, newval) ;
006964  000526      imgidx++ ;
006965  000527      lb := *(j+Ofs_Digits_LeadingBlanks) ;
006966  000528      l := str_Ptr(num) ;
006967  000529      for (i := 0; i < *(j+Ofs_Digits_Digits); i++)
006968  000530          k := str_GetByte(l++) & 0x0f ;
006969  000531          if ( lb && (i < *(j+Ofs_Digits_Digits) - *(j+Ofs_Digits_MinDigits)) )
006970  000532              if (k == 0)
006971  000533                  k := 10 ;
006972  000534              else
006973  000535                  lb := 0 ;
006974  000536              endif
006975  000537          endif
006976  000538          img_SetWord(hndl, imgidx, IMAGE_INDEX, k);
006977  000539          img_SetWord(hndl, imgidx, IMAGE_XPOS, *(j+Ofs_Digits_Left)+i* *(j+Ofs_Digits_Widthdigit)) ;
006978  000540          img_Show(hndl, imgidx);
006979  000541      next
006980  000542  endfunc
006981  000543        
006982  000544        
006983  000545  func ActivateForm(var newform)
006984  000546      var i, j, *p ;
006985  000547        
006986  000548          widget_Disable(wp, ALL) ;
006987  000549      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
006988  000550          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
006989  000551              if (img_GetWord(hndl, i, IMAGE_TAG))
006990  000552                  img_Disable(hndl,i) ;
006991  000553              endif
006992  000554          next
006993  000555      endif
006994  000556      CurrentForm := newform ;
006995  000557      // display newform image or clear to image color
006996  000558      if (FormBGcolors[CurrentForm] != ColorBGimage)
006997  000559          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
006998  000560          gfx_Cls() ;
006999  000561          DoGFXObjects() ;                                    // display GFX 'widgets'
007000  000562      endif
007001  000563        
007002  000564      // enable inputs
007003  000565      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
007004  000566          j := img_GetWord(hndl, i, IMAGE_TAG) ;
007005  000567          if (j)
007006  000568              j-- ;
007007  000569              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
007008  000570              //if (j != tKeyboard)
007009  000571              if (((j <= tWinButton) || (j >= t4Dbutton)) && (j != tSmartGauge) )               // enable inputs
007010  000572                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
007011  000573              endif
007012  000574              img_Show(hndl,i) ; // show initialy, if required
007013  000575              if (j == tForm)
007014  000576                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
007015  000577              else if (j == tLeddigits)
007016  000578                  ledDigitsDisplay(i, oLeddigitss, oLedDigitsn) ;
007017  000579              endif
007018  000580          endif
007019  000581      next
007020  000582        
007021  000583      // enable inputs
007022  000584         var a, f ; 
007023  000595  */
007024  000596      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007025  000597          addressInternalWidget(i, 0) ;
007026  000598          widget_Enable(wp,i) ;
007027  000599          if (GObjectType != tiLabelB) widget_ClearAttributes(wp,i,WIDGET_F_INITIALISED) ; // don't clear initialised for tiLabelB
007028  000600                  j := GObjectRAM[WIDGET_VAL1] ;
007029  000601                  GObjectFunc(j, GObjectRAM, GObjectDATA) ; 
007030  000602      next
007031  000603      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007032  000604          if (InternalInputControls[i] != -1)
007033  000605              widget_SetAttributes(wp,i,WIDGET_F_TOUCH_ENABLE) ;
007034  000606          endif
007035  000607      next
007036  000608        
007037  000609        
007038  000610  endfunc
007039  000611        
007040  000612  func UpdateObjects(var newval)
007041  000613      var IPidx, otherOBJ, oldvalue ;
007042  000614      if (GObjectType < tiLedDigitsH)
007043  000615          oldvalue := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ;
007044  000616      else
007045  000617          oldvalue := GObjectRAM[WIDGET_VAL1] ;
007046  000618      endif
007047  000619      if ( ( oldvalue != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
007048  000620      if (GObjectType < tiLedDigitsH)
007049  000621          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
007050  000622              img_Show(hndl, *(pInputIndex));      // only shows on current form
007051  000623      else
007052  000624          WriteObject(GObjectType, GObjectIdx, newval) ;
007053  000625      endif
007054  000626          if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
007055  000627              if (*(CurInputData+Ofs_IPD_P1))
007056  000628                  newval &= 1;
007057  000629              else
007058  000630                  newval &= 3;
007059  000631              endif
007060  000632              if (newval > 1) newval := 1;
007061  000633          endif
007062  000634          IPidx := *(CurInputData+TouchState) ;
007063  000635          while(IPidx != 0)
007064  000636              otherOBJ := IPidx + InputData;
007065  000637              if (*(otherOBJ) == OT_REPORT)
007066  000638          SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
007067  000639              else if (*(otherOBJ) == OT_MAGIC)
007068  000640                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
007069  000641                  IPidx(newval) ;
007070  000642  //            else if (TouchState == *(otherOBJ+Ofs_IPD_P4))  // test prior to Workshop 6.5.0.0
007071  000643              else if ((TouchState == *(otherOBJ+Ofs_IPD_P4)) || (*(CurInputData+Ofs_IPD_P1) && ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))))
007072  000644                  if (*(otherOBJ) == OT_ACTIVATE)
007073  000645                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
007074  000646                      GObjectType := tForm ;
007075  000647                  else if (*(otherOBJ) == OT_SETCONST)
007076  000648                      newval := *(otherOBJ+Ofs_IPD_P3) ;
007077  000649                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007078  000650                  else if (*(otherOBJ) == OT_SETANOTHER)
007079  000651                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007080  000652                  else if (*(otherOBJ) == OT_PREVFRAME)
007081  000653                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
007082  000654                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
007083  000655                      endif
007084  000656                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007085  000657                  else if (*(otherOBJ) == OT_NEXTFRAME)
007086  000658                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
007087  000659                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
007088  000660                      endif
007089  000661                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007090  000662                  endif
007091  000663              endif
007092  000664              IPidx := *(otherOBJ+TouchState) ;
007093  000665          wend
007094  000666      endif
007095  000667  endfunc
007096  000668        
007097  000669  // End P2.inc
007098  000670  func DoGFXObjects()
007099  000671  endfunc
007100  000672        
007101  000673  // Start P3.inc
007102  000674  func main()
007103  000675      var comTX[50], cmdi, i, j, TouchStatus ;
007104  000676        
007105  000677      ActiveKeyboard := -1 ;
007106  000678        
007107  000679      gfx_ScreenMode(LANDSCAPE) ;
007108  000680        
007109  000681      putstr("Mounting...\n");
007110  000682      if (!(file_Mount()))
007111  000683          while(!(file_Mount()))
007112  000684              putstr("Drive not mounted...");
007113  000685              pause(200);
007114  000686              gfx_Cls();
007115  000687              pause(200);
007116  000688          wend
007117  000689      endif
007118  000690        
007119  000691  //    if (file_CheckUpdate("HMI-CO~1.4xe", CHECKUPDATE_QUERY) == CHECKUPDATE_NEWFILE)
007120  000692  //        putstr("Program will now update") ;
007121  000693  //        file_CheckUpdate("HMI-CO~1.4xe", CHECKUPDATE_UPDATENEWER) ;
007122  000694  //    endif
007123  000695  //    gfx_MoveTo(0, 0);
007124  000696  //    print(mem_Heap()," ") ;
007125  000697  //    gfx_TransparentColour(0x0020);
007126  000698  //    gfx_Transparency(ON);
007127  000699        
007128  000700        
007129  000701      // open image control
007130  000702      hndl := file_LoadImageControl("HMI-CO~1.dat", "HMI-CO~1.gci", 1);
007131  000703        
007132  000704        
007133  000705      // init 'constants'
007134  000706  // End P3.inc
007135  000707        
007136  000708      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
007137  000709      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
007138  000710      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
007139  000711      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
007140  000712      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
007141  000713      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
007142  000714      oObjects[tWinButton] := oWinButtons ;
007143  000715      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
007144  000716      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
007145  000717      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
007146  000718      oObjects[tForm] := oForms ;
007147  000719      oObjects[tGauge] := oDipSwitchs ; // dummy as no object there
007148  000720      oObjects[tImage] := oImages ;
007149  000721      oObjects[tKeyboard] := oKeyboards ;
007150  000722      oObjects[tLed] := oDipSwitchs ; // dummy as no object there
007151  000723      oObjects[tLeddigits] := oLeddigitss ;
007152  000724      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
007153  000725      oObjects[tStrings] := oDipSwitchs ; // dummy as no object there
007154  000726      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
007155  000727      oObjects[tUserled] := oUserleds ;
007156  000728      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
007157  000729      oObjects[tStaticText] := oStaticTexts ;
007158  000730      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
007159  000731      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
007160  000732      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
007161  000733      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
007162  000734      oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
007163  000735      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
007164  000736      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
007165  000737      oObjects[t4Dbutton] := oDipSwitchs ; // dummy as no object there
007166  000738      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
007167  000739      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
007168  000740      oObjects[tUserButton] := oDipSwitchs ; // dummy as no object there
007169  000741      oObjects[tMagicObject] := oDipSwitchs ; // dummy as no object there
007170  000742      oObjects[tSmartGauge] := oDipSwitchs ; // dummy as no object there
007171  000743      oObjects[tSmartSlider] := oDipSwitchs ; // dummy as no object there
007172  000744      oObjects[tSmartKnob] := oDipSwitchs ; // dummy as no object there
007173  000745      oObjects[tiLedDigitsH] := oDipSwitchs ; // dummy as no object there
007174  000746      oObjects[tiAngularMeter] := oDipSwitchs ; // dummy as no object there
007175  000747      oObjects[tiGauge] := oDipSwitchs ; // dummy as no object there
007176  000748      oObjects[tiLabelB] := oDipSwitchs ; // dummy as no object there
007177  000749      oObjects[tiUserGauge] := oDipSwitchs ; // dummy as no object there
007178  000750      oObjects[tiMediaGauge] := oDipSwitchs ; // dummy as no object there
007179  000751      oObjects[tiMediaThermometer] := oDipSwitchs ; // dummy as no object there
007180  000752      oObjects[tiLed] := oDipSwitchs ; // dummy as no object there
007181  000753      oObjects[tiMediaLed] := oDipSwitchs ; // dummy as no object there
007182  000754      oObjects[tiLedDigits] := oDipSwitchs ; // dummy as no object there
007183  000755      oObjects[tiNeedle] := oDipSwitchs ; // dummy as no object there
007184  000756      oObjects[tiRuler] := oDipSwitchs ; // dummy as no object there
007185  000757      oObjects[tiLedDigit] := oDipSwitchs ; // dummy as no object there
007186  000758      oObjects[tiButtonD] := oDipSwitchs ; // dummy as no object there
007187  000759      oObjects[tiButtonE] := oDipSwitchs ; // dummy as no object there
007188  000760      oObjects[tiMediaButton] := oDipSwitchs ; // dummy as no object there
007189  000761      oObjects[tiToggleInput] := oDipSwitchs ; // dummy as no object there
007190  000762      oObjects[tiDial] := oDipSwitchs ; // dummy as no object there
007191  000763      oObjects[tiMediaRotary] := oDipSwitchs ; // dummy as no object there
007192  000764      oObjects[tiRotaryInput] := oDipSwitchs ; // dummy as no object there
007193  000765      oObjects[tiSwitch] := oiSwitchs ;
007194  000766      oObjects[tiSwitchB] := oDipSwitchs ; // dummy as no object there
007195  000767      oObjects[tiSliderE] := oDipSwitchs ; // dummy as no object there
007196  000768      oObjects[tiMediaSlider] := oDipSwitchs ; // dummy as no object there
007197  000769      oObjects[tiSliderH] := oDipSwitchs ; // dummy as no object there
007198  000770      oObjects[tiSliderG] := oDipSwitchs ; // dummy as no object there
007199  000771      oObjects[tiSliderF] := oDipSwitchs ; // dummy as no object there
007200  000772      oObjects[tiSliderD] := oDipSwitchs ; // dummy as no object there
007201  000773      oObjects[tiSliderC] := oDipSwitchs ; // dummy as no object there
007202  000774      oObjects[tiLinearInput] := oDipSwitchs ; // dummy as no object there
007203  000775      vObjects[19] := oiviSwitch ;
007204  000776      dKeyboard[0] := oKeyboard0 ;
007205  000777  // Start P4.inc
007206  000778      wp := widget_Create(1) ;
007207  000779      for (i := 0; i < 1; i++)
007208  000780  	addressInternalWidget(i, 0) ;
007209  000781          if (GObjectType != tiLedDigit) widget_Add(wp, i, GObjectRAM) ;    // don't add tiLedDigit objects as they are only 1 word long
007210  000782  //        if (GObjectType == tiLabelB)			// code to cause 'early' allocation of 'buffer' storage in LabelB widgets
007211  000783  //            widget_Disable(wp, i) ;
007212  000784  //            img_FunctionCall(hndl, GObjectFunc, j, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings) ;
007213  000785  //        endif
007214  000786      next
007215  000787        
007216  000788      // init comms
007217  000789      com_Init(comRX,CMDLenMAX,0);
007218  000790      com_SetBaud(COM0,960);
007219  000791      com_TXbuffer(comTX, 100, 0);
007220  000792      // tag 'real' objects
007221  000793      for (i := 0; i <= MaxTotObjects; i++)
007222  000794          if (   (i != tSounds)
007223  000795              && (i != tTimer)
007224  000796              && (i != tPinOutput)
007225  000797              && (i != tMagicObject)
007226  000798              && (i != tPinInput) )
007227  000799              TouchXpos := oObjects[i] ;
007228  000800              TouchYpos := *(TouchXpos) ;
007229  000801              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
007230  000802                  oldn := *(TouchXpos+ImageTouched*2) ;
007231  000803                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
007232  000804                  if (oldn != -1)
007233  000805                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
007234  000806                      img_Disable(hndl, oldn) ;
007235  000807                  endif
007236  000808              next
007237  000809          endif
007238  000810      next
007239  000811        
007240  000812        
007241  000813      for (i := 0; i < nKeyboards; i++) // for each kb key, set tag to -1
007242  000814          if (oKeyboards[i+1] != -1)               // if keyboard exists
007243  000815              for(ImageTouched := oKeyboards[i+1]+1; ImageTouched <= oKeyboards[i+1]+*(dKeyboard[i] + Ofs_kb_Buttons); ImageTouched++)
007244  000816                  img_SetWord(hndl, ImageTouched, IMAGE_TAG, -1);
007245  000817              next
007246  000818          endif
007247  000819      next
007248  000820      // display initial form
007249  000821      CurrentForm := -1 ;
007250  000822  // End P4.inc
007251  000823  // Start P5.inc
007252  000824      ActivateForm(0) ; // need to change this according to first actual form
007253  000825        
007254  000826  // End P5.inc
007255  000827  // Start P6.inc Diablo
007256  000828      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
007257  000829      oldn := -1 ;
007258  000830      repeat
007259  000831        
007260  000832          // check comms for command, how to NAK invalid command
007261  000833          if (com_Count() != 0)
007262  000834              i := serin() ;
007263  000835              InputCS ^= i ;               // update checksum
007264  000836                  cmd[cmdi++] := i ;
007265  000837                   if (   (cmd[0] == READ_OBJ)
007266  000838                           && (cmdi == 4)         )
007267  000839                      if (InputCS)
007268  000840                          nak0() ;
007269  000841                      else
007270  000842                          ReadObject(cmd[1], cmd[2]) ;
007271  000843                      endif
007272  000844                      cmdi := 0 ;
007273  000845                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
007274  000846                           && (cmdi == 6)          )
007275  000847                      if (InputCS)
007276  000848                          nak0() ;
007277  000849                      else
007278  000850                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
007279  000851                          serout(ACK) ;
007280  000852                      endif
007281  000853                      cmdi := 0 ;
007282  000854                  else if (   (cmd[0] == WRITE_CONTRAST)
007283  000855                           && (cmdi == 3)         )
007284  000856                      if (InputCS)
007285  000857                          nak0() ;
007286  000858                      else
007287  000859                          gfx_Contrast(cmd[1]) ;
007288  000860                          serout(ACK) ;
007289  000861                      endif
007290  000862                      cmdi := 0 ;
007291  000863                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
007292  000864                      nak0() ;
007293  000865                      cmdi := 0 ;
007294  000866                  endif
007295  000867          endif   // a character is available
007296  000868        
007297  000869        
007298  000870      // touch code processing
007299  000871        
007300  000872          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
007301  000873          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
007302  000874              ImageTouched := img_Touched(hndl,-1) ;
007303  000875              if (ImageTouched == -1)
007304  000876                  ImageTouched := widget_Touched(wp, ALL) ;
007305  000877                  if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
007306  000878              endif
007307  000879              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
007308  000880                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
007309  000881              endif
007310  000882              if (TouchStatus != TOUCH_RELEASED)        // if not released
007311  000883                  if (oldn != -1)
007312  000884                      ImageTouched := oldn ;
007313  000885                  else
007314  000886                      if (oldn != ImageTouched)
007315  000887                  oldn := ImageTouched ;
007316  000888                          TouchStatus := TOUCH_PRESSED ;
007317  000889                      endif
007318  000890                  endif
007319  000891                  TouchXpos  := touch_Get(TOUCH_GETX);
007320  000892                  TouchYpos  := touch_Get(TOUCH_GETY);
007321  000893                  TouchState := Ofs_IPD_DOWN ;
007322  000894              else
007323  000895                  ImageTouched := oldn ;                     // simulate release of what we touched
007324  000896                  oldn := -1 ;                    // prevent double release
007325  000897                  TouchState := Ofs_IPD_RELEASE ;
007326  000898              endif
007327  000899              if (ImageTouched >= 0)
007328  000900                  // if touch released then find a keyboard down, if one then release it
007329  000901                  if ((TouchStatus == TOUCH_RELEASED) && (ActiveKeyboard != -1))
007330  000902                      kbUp(oKeyboards[ActiveKeyboard+1], dKeyboard[ActiveKeyboard]) ;
007331  000903                      ActiveKeyboard := -1 ;
007332  000904                  else
007333  000905                      i := 0 ;
007334  000906                      while ((i < nKeyboards) && ((-1 == oKeyboards[i+1]) || (ImageTouched <= oKeyboards[i+1]) || (ImageTouched > oKeyboards[i+1] + *(dKeyboard[i]+Ofs_kb_Buttons))))
007335  000907                          i++ ;
007336  000908                      wend
007337  000909                      if (i < nKeyboards)
007338  000910                          if (TouchStatus == TOUCH_PRESSED)
007339  000911                              ActiveKeyboard := i ;
007340  000912                              kbDown(oKeyboards[ActiveKeyboard+1], dKeyboard[ActiveKeyboard], kKeyboardKeystrokes[ActiveKeyboard], ImageTouched-oKeyboards[ActiveKeyboard+1]) ;
007341  000913                          endif
007342  000914                      else
007343  000915                          CurInputData := InputControls[ImageTouched] + InputData;
007344  000916                          GObjectType := *(CurInputData) ;
007345  000917                          if (GObjectType == tSmartSlider)
007346  000918                              i := tTrackbar ; // GSlider ;
007347  000919                          else if (GObjectType == tSmartKnob)
007348  000920                              i := tKnob ;
007349  000921                          else if (GObjectType >= t4Dbutton) 
007350  000922                              i := GObjectType - 23 ; // adjust to ensure next in gosub
007351  000923                          else 
007352  000924                              i := GObjectType ;
007353  000925                          endif
007354  000926                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007355  000927                          ImageTouched := -1 ; // show processed here
007356  000928                      endif
007357  000929                  endif
007358  000930              endif
007359  000931              if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
007360  000932              if (ImageTouched >= 0)
007361  000933  //print(ImageTouched," ") ;
007362  000934  //                        CurInputData := InternalInputControls[ImageTouched] + InternalInputData;
007363  000935                          CurInputData := InternalInputControls[ImageTouched] + InputData;
007364  000936  //                        GObjectType := *(CurInputData) ;
007365  000937  //                        i := GObjectType ;
007366  000938  //                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
007367  000939  //                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007368  000940                          addressInternalWidget(ImageTouched, 0) ;
007369  000941  //                        i := xobj2iiobj[ImageTouched] ;                            // address object type and hash from ram index
007370  000942  //                        GObjectIdx := i & 0xff ;
007371  000943  //                        GObjectType := (i>>8) ;                                   // extract object type
007372  000944                          if (GObjectType <= tiToggleInput) 
007373  000945                              i := 0 ;
007374  000946                          else if (GObjectType <= tiRotaryInput) 
007375  000947                              i := 1 ;
007376  000948                          else if (GObjectType <= tiSwitchB) 
007377  000949                              i := 2 ;
007378  000950                          else 
007379  000951                              i := 3 ;
007380  000952                          endif
007381  000953  //to(COM0) ; print(i, "\r\n") ;  
007382  000954        
007383  000955                          gosub (i), (ciButton, ciDial, ciSwitch, ciSlider) ;
007384  000956        
007385  000957        
007386  000958  //            ImageTouched := widget_Touched(wp, ALL) ;
007387  000959              endif
007388  000960          endif
007389  000961   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
007390  000962        
007391  000963          sys_EventsResume() ;
007392  000964      forever
007393  000965        
007394  000966  ciSwitch:
007395  000967  cDipswitch:
007396  000968      pInputIndex := oObjects[GObjectType]  + *(CurInputData+Ofs_IPD_OBJVIDX) ;
007397  000969  #IF EXISTS OLDCOMPILE
007398  000970      if (*(CurInputData+Ofs_IPD_P1))
007399  000971          i := (TouchXpos - *(CurInputData+Ofs_IPD_P2)) / *(CurInputData+Ofs_IPD_P3) ;
007400  000972      else
007401  000973          i := (TouchYpos - *(CurInputData+Ofs_IPD_P2)) / *(CurInputData+Ofs_IPD_P3) ;
007402  000974      endif
007403  000975      if (i > *(CurInputData+Ofs_IPD_P4)) i := *(CurInputData+Ofs_IPD_P4) ;
007404  000976  #ELSE
007405  000977      i := gfx_XYlinToVal(TouchXpos, TouchYpos, *(CurInputData+Ofs_IPD_P1),
007406  000978                   *(CurInputData+Ofs_IPD_P2), *(CurInputData+Ofs_IPD_P3), 0, *(CurInputData+Ofs_IPD_P4) ) ;
007407  000979  #ENDIF
007408  000984  */
007409  000985      UpdateObjects(i) ;
007410  000986  endsub ;
007411  000987        
007412  000988  cKnob:
007413  000989  ciDial:
007414  000990        
007415  000991  cRockerswitch:
007416  000992        
007417  000993  cRotaryswitch:
007418  000994        
007419  000995  cSlider:
007420  000996  cTrackbar:
007421  000997  ciSlider:
007422  000998        
007423  000999  ciButton:
007424  001000        
007425  001001  c4DButton:
007426  001002  cUserButton:
007427  001003  cWinbutton:
007428  001004      pInputIndex := oObjects[GObjectType]  + *(CurInputData+Ofs_IPD_OBJVIDX) ;
007429  001005      i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
007430  001006  CommonButtons:
007431  001007      if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
007432  001008          if (TouchStatus == TOUCH_RELEASED)
007433  001009              i &= 0xfffe ;
007434  001010              TouchState == Ofs_IPD_DOWN ;
007435  001011          else
007436  001012              i |= 1 ;
007437  001013              TouchState == Ofs_IPD_RELEASE ;
007438  001014          endif
007439  001015      else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
007440  001016          if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
007441  001017              if ((i & 3) == 3)
007442  001018                  i &= 0xfffc ;
007443  001019              else
007444  001020                  i++ ;
007445  001021              endif
007446  001022          else
007447  001023              i |= 1 ;                                      // make down regardless of current state
007448  001024          endif
007449  001025      else                        // group action, up all other buttons on touch press, reports 0 for button down
007450  001026          if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
007451  001027              TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
007452  001028          endif
007453  001029          if (GObjectType < tiLedDigits)
007454  001030              i := (i & 0xfffc) | 2 ;         // uSD button, four, grouping and blocking states
007455  001031          else
007456  001032              i := 1 ;                        // Internal button two states
007457  001033          endif
007458  001034      endif
007459  001035        
007460  001036      UpdateObjects(i) ;
007461  001037  endsub ;
007462  001038        
007463  001039  cAniButton:
007464  001040        
007465  001041  cColorPicker:
007466  001042        
007467  001043  endfunc
007468  001044  // End P6.inc
Notice: local var 'j' in func 'main' is never used (line 675 file:HMI-Control.4DGenieS)
Notice: variable 'GObjectRAM' is being indexed (line 617 file:HMI-Control.4DGenieS)
Notice: Check that the function called via pointer  'IPidx' requires 1 argument (line 641 file:HMI-Control.4DGenieS)
Notice: variable 'GObjectRAM' is being indexed (line 600 file:HMI-Control.4DGenieS)
Notice: Check that the function called via pointer  'GObjectFunc' requires 3 arguments (line 601 file:HMI-Control.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 546 file:HMI-Control.4DGenieS)
Notice: local var 'a' in func 'ActivateForm' is never used (line 584 file:HMI-Control.4DGenieS)
Notice: local var 'f' in func 'ActivateForm' is never used (line 584 file:HMI-Control.4DGenieS)
Notice: local var 'o' in func 'TurnOffButtons' is never used (line 490 file:HMI-Control.4DGenieS)
Notice: local var 'p' in func 'TurnOffButtons' is never used (line 490 file:HMI-Control.4DGenieS)
Notice: variable 'i' is being indexed (line 449 file:HMI-Control.4DGenieS)
Notice: variable 'k' is being indexed (line 451 file:HMI-Control.4DGenieS)
Notice: Check that the function called via pointer  'Objects' requires 3 arguments (line 454 file:HMI-Control.4DGenieS)
Notice: variable 'k' is being indexed (line 409 file:HMI-Control.4DGenieS)
Notice: variable 'k' is being indexed (line 411 file:HMI-Control.4DGenieS)
Notice: variable 'k' is being indexed (line 413 file:HMI-Control.4DGenieS)
Notice: variable 'i' is being indexed (line 367 file:HMI-Control.4DGenieS)
Notice: variable 'i' is being indexed (line 369 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 277 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 278 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 278 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 279 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 280 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 283 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 284 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 285 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 286 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 288 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 222 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 223 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 224 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 224 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 225 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 226 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 227 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 229 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 232 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 233 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 233 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 234 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 235 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 236 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 238 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 240 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 240 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 241 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 242 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 243 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 244 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 245 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 246 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 248 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 251 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 254 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 255 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 256 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 256 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 257 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 257 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 260 file:HMI-Control.4DGenieS)
Notice: variable 'KBKeys' is being indexed (line 262 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 263 file:HMI-Control.4DGenieS)
Notice: Check that the function called via pointer  'rtn' requires 4 arguments (line 265 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 266 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 266 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 268 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 198 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 201 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 204 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 207 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 208 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 210 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 211 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 212 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 214 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 215 file:HMI-Control.4DGenieS)
Notice: variable 'oKB' is being indexed (line 216 file:HMI-Control.4DGenieS)


Symbol Table:
name                             decimal         hex
__MAXBANKS                             6  0x00000006 (const dword)  (not used)
__MAXMEM                           32768  0x00008000 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             3  0x00000003 (const dword)  (not used)
__reserved10                        -111  0xffffff91 (PmmC func) args[0] r=0  (not used)
__reserved13                        -123  0xffffff85 (PmmC func) args[0] r=0  (not used)
__reserved14                        -124  0xffffff84 (PmmC func) args[0] r=0  (not used)
__reserved17                        -201  0xffffff37 (PmmC func) args[0] r=0  (not used)
__reserved18                        -202  0xffffff36 (PmmC func) args[0] r=0  (not used)
__reserved19                        -203  0xffffff35 (PmmC func) args[0] r=0  (not used)
__reserved20                        -204  0xffffff34 (PmmC func) args[0] r=0  (not used)
__reserved21                        -205  0xffffff33 (PmmC func) args[0] r=0  (not used)
__reserved22                        -206  0xffffff32 (PmmC func) args[0] r=0  (not used)
__reserved23                        -220  0xffffff24 (PmmC func) args[0] r=0  (not used)
__reserved24                        -221  0xffffff23 (PmmC func) args[0] r=0  (not used)
__reserved25                        -222  0xffffff22 (PmmC func) args[0] r=0  (not used)
__reserved26                        -223  0xffffff21 (PmmC func) args[0] r=0  (not used)
__reserved3                          -69  0xffffffbb (PmmC func) args[0] r=0  (not used)
__reserved30                        -283  0xfffffee5 (PmmC func) args[0] r=0  (not used)
__reserved4                          -70  0xffffffba (PmmC func) args[0] r=0  (not used)
__reserved42                        -373  0xfffffe8b (PmmC func) args[0] r=0  (not used)
__reserved43                        -387  0xfffffe7d (PmmC func) args[0] r=0  (not used)
__reserved44                        -388  0xfffffe7c (PmmC func) args[0] r=0  (not used)
__reserved45                        -389  0xfffffe7b (PmmC func) args[0] r=0  (not used)
__reserved46                        -390  0xfffffe7a (PmmC func) args[0] r=0  (not used)
__reserved5                          -76  0xffffffb4 (PmmC func) args[0] r=0  (not used)
__reserved51                        -411  0xfffffe65 (PmmC func) args[0] r=0  (not used)
__reserved52                        -412  0xfffffe64 (PmmC func) args[0] r=0  (not used)
__reserved53                        -422  0xfffffe5a (PmmC func) args[0] r=0  (not used)
__reserved54                        -423  0xfffffe59 (PmmC func) args[0] r=0  (not used)
__reserved57                        -457  0xfffffe37 (PmmC func) args[0] r=0  (not used)
__reserved58                        -458  0xfffffe36 (PmmC func) args[0] r=0  (not used)
__reserved6                          -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
__reserved60                        -467  0xfffffe2d (PmmC func) args[0] r=0  (not used)
__reserved61                        -468  0xfffffe2c (PmmC func) args[0] r=0  (not used)
__reserved62                        -469  0xfffffe2b (PmmC func) args[0] r=0  (not used)
__reserved63                        -490  0xfffffe16 (PmmC func) args[0] r=0  (not used)
__reserved64                        -491  0xfffffe15 (PmmC func) args[0] r=0  (not used)
__reserved65                        -492  0xfffffe14 (PmmC func) args[0] r=0  (not used)
__reserved66                        -493  0xfffffe13 (PmmC func) args[0] r=0  (not used)
__reserved68                        -509  0xfffffe03 (PmmC func) args[0] r=0  (not used)
__reserved69                        -510  0xfffffe02 (PmmC func) args[0] r=0  (not used)
__reserved70                        -511  0xfffffe01 (PmmC func) args[0] r=0  (not used)
__reserved72                        -520  0xfffffdf8 (PmmC func) args[0] r=0  (not used)
__reserved77                        -526  0xfffffdf2 (PmmC func) args[0] r=0  (not used)
__reserved78                        -527  0xfffffdf1 (PmmC func) args[0] r=0  (not used)
__reserved85                        -536  0xfffffde8 (PmmC func) args[0] r=0  (not used)
__reserved86                        -537  0xfffffde7 (PmmC func) args[0] r=0  (not used)
__reserved87                        -570  0xfffffdc6 (PmmC func) args[0] r=0  (not used)
__reserved88                        -571  0xfffffdc5 (PmmC func) args[0] r=0  (not used)
__reserved89                        -572  0xfffffdc4 (PmmC func) args[0] r=0  (not used)
__reserved9                         -110  0xffffff92 (PmmC func) args[0] r=0  (not used)
__translate                           -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
ABS                                  -53  0xffffffcb (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 6)
ActivateForm                        3775  0x00000ebf (User func) args[1] r=0  (usage 9)
ActiveKeyboard                        48  0x00000030 (mem) word (global)  (usage 36)
addressInternalWidget               5461  0x00001555 (User func) args[2] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (usage 6)
ana_HS                              -533  0xfffffdeb (PmmC func) args[7] r=0  (not used)
ANGULAR_bgcol                         66  0x00000042 (const dword)  (not used)
ANGULAR_c1                            24  0x00000018 (const dword)  (not used)
ANGULAR_c2                            26  0x0000001a (const dword)  (not used)
ANGULAR_c3                            28  0x0000001c (const dword)  (not used)
ANGULAR_capcol                        46  0x0000002e (const dword)  (not used)
ANGULAR_capfnt                        44  0x0000002c (const dword)  (not used)
ANGULAR_capofsx                       48  0x00000030 (const dword)  (not used)
ANGULAR_capofsy                       50  0x00000032 (const dword)  (not used)
ANGULAR_Caption                       52  0x00000034 (const dword)  (not used)
ANGULAR_cxx                           62  0x0000003e (const dword)  (not used)
ANGULAR_cyx                           64  0x00000040 (const dword)  (not used)
ANGULAR_F_BG_TRANSPARENT             N/A         N/A (macro)   0x0002   (not used)
ANGULAR_F_LABEL_STRINGS              N/A         N/A (macro)   0x0001   (not used)
ANGULAR_F_TEXT_PCT_COLOUR            N/A         N/A (macro)   0x0008   (not used)
ANGULAR_F_TICK_PCT_COLOUR            N/A         N/A (macro)   0x0004   (not used)
ANGULAR_flags                         42  0x0000002a (const dword)  (not used)
ANGULAR_h                             60  0x0000003c (const dword)  (not used)
ANGULAR_incro                         30  0x0000001e (const dword)  (not used)
ANGULAR_labcol                        36  0x00000024 (const dword)  (not used)
ANGULAR_labfnt                        34  0x00000022 (const dword)  (not used)
ANGULAR_labofs                        38  0x00000026 (const dword)  (not used)
ANGULAR_labs                          32  0x00000020 (const dword)  (not used)
ANGULAR_labstr                        40  0x00000028 (const dword)  (not used)
ANGULAR_maxa                          70  0x00000046 (const dword)  (not used)
ANGULAR_maxv                          74  0x0000004a (const dword)  (not used)
ANGULAR_mina                          68  0x00000044 (const dword)  (not used)
ANGULAR_minv                          72  0x00000048 (const dword)  (not used)
ANGULAR_p1                            20  0x00000014 (const dword)  (not used)
ANGULAR_p2                            22  0x00000016 (const dword)  (not used)
ANGULAR_ri                             2  0x00000002 (const dword)  (not used)
ANGULAR_ro                             0  0x00000000 (const dword)  (not used)
ANGULAR_tc                            18  0x00000012 (const dword)  (not used)
ANGULAR_tcks                           4  0x00000004 (const dword)  (not used)
ANGULAR_tiszl                         12  0x0000000c (const dword)  (not used)
ANGULAR_tiszs                         14  0x0000000e (const dword)  (not used)
ANGULAR_tkl                            6  0x00000006 (const dword)  (not used)
ANGULAR_toszl                          8  0x00000008 (const dword)  (not used)
ANGULAR_toszs                         10  0x0000000a (const dword)  (not used)
ANGULAR_tw                            16  0x00000010 (const dword)  (not used)
ANGULAR_w                             58  0x0000003a (const dword)  (not used)
ANGULAR_x                             54  0x00000036 (const dword)  (not used)
ANGULAR_y                             56  0x00000038 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                          17  0x00000011 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_RADIUS                          27  0x0000001b (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 3)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BREAK                              65533  0x0000fffd (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
bus_ClearPins                       -119  0xffffff89 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                            -117  0xffffff8b (PmmC func) args[0] r=1  (not used)
bus_Read8                           -122  0xffffff86 (PmmC func) args[0] r=1  (not used)
bus_SetChangeInterrupt              -120  0xffffff88 (PmmC func) args[2] r=1  (not used)
bus_SetPins                         -118  0xffffff8a (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             3  0x00000003 (const dword)  (not used)
bus_Write8                          -121  0xffffff87 (PmmC func) args[1] r=0  (not used)
BUTTON4_BC0                           12  0x0000000c (const dword)  (not used)
BUTTON4_BC1                           14  0x0000000e (const dword)  (not used)
BUTTON4_BR1                           28  0x0000001c (const dword)  (not used)
BUTTON4_BR2                           30  0x0000001e (const dword)  (not used)
BUTTON4_BRG                           32  0x00000020 (const dword)  (not used)
BUTTON4_CAP                           26  0x0000001a (const dword)  (not used)
BUTTON4_FC0                           28  0x0000001c (const dword)  (not used)
BUTTON4_FC1                           30  0x0000001e (const dword)  (not used)
BUTTON4_FST                           32  0x00000020 (const dword)  (not used)
BUTTON4_FSZ                           34  0x00000022 (const dword)  (not used)
BUTTON4_IB1                           16  0x00000010 (const dword)  (not used)
BUTTON4_IB2                           18  0x00000012 (const dword)  (not used)
BUTTON4_IG0                           20  0x00000014 (const dword)  (not used)
BUTTON4_IG1                           22  0x00000016 (const dword)  (not used)
BUTTON4_OB1                            6  0x00000006 (const dword)  (not used)
BUTTON4_OB2                            8  0x00000008 (const dword)  (not used)
BUTTON4_OBG                           10  0x0000000a (const dword)  (not used)
BUTTON4_rad                            4  0x00000004 (const dword)  (not used)
BUTTON4_TPC                           24  0x00000018 (const dword)  (not used)
BUTTON4_XP                             0  0x00000000 (const dword)  (not used)
BUTTON4_YP                             2  0x00000002 (const dword)  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                             -49  0xffffffcf (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
CfISwitch0                           264  0x00000108CfISwitch0                           264  0x00000108 (mem) byte[12] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 1)
CfISwitch0                        UNRESOLVED  (usage 2)
charheight                           -12  0xfffffff4 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                            -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
CHECKED                                0  0x00000000 (const dword)  (not used)
CHECKUPDATE_INVALIDFILE                5  0x00000005 (const dword)  (not used)
CHECKUPDATE_NEWFILE                    1  0x00000001 (const dword)  (not used)
CHECKUPDATE_NOFILE                     4  0x00000004 (const dword)  (not used)
CHECKUPDATE_OLDFILE                    2  0x00000002 (const dword)  (not used)
CHECKUPDATE_QUERY                      1  0x00000001 (const dword)  (not used)
CHECKUPDATE_UPDATEALWAYS               3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATEDONE                 3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATENEWER                2  0x00000002 (const dword)  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
ciButton                          UNRESOLVED  (not used)
ciDial                            UNRESOLVED  (not used)
ciSlider                          UNRESOLVED  (not used)
ciSwitch                          UNRESOLVED  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  352  0x00000160 (mem) word[80] (global)  (usage 33)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 6)
CnISwitch0                           257  0x00000101CnISwitch0                           257  0x00000101 (mem) byte[7] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 1)
CnISwitch0                        UNRESOLVED  (usage 2)
ColorBGimage                          32  0x00000020 (const dword)  (usage 3)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63493  0x0000f805 (const dword)  (not used)
com1_Count                          -249  0xffffff07 (PmmC func) args[0] r=1  (not used)
com1_Error                          -257  0xfffffeff (PmmC func) args[0] r=1  (not used)
com1_Full                           -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
com1_Init                           -233  0xffffff17 (PmmC func) args[3] r=0  (not used)
com1_InitBrk                        -578  0xfffffdbe (PmmC func) args[3] r=0  (not used)
com1_Reset                          -245  0xffffff0b (PmmC func) args[0] r=0  (not used)
COM1_RX_pin                         -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
com1_RXblock                        -558  0xfffffdd2 (PmmC func) args[2] r=0  (not used)
com1_Sync                           -261  0xfffffefb (PmmC func) args[0] r=1  (not used)
COM1_TX_pin                         -229  0xffffff1b (PmmC func) args[1] r=1  (not used)
com1_TXblock                        -557  0xfffffdd3 (PmmC func) args[2] r=0  (not used)
com1_TXbuffer                       -265  0xfffffef7 (PmmC func) args[3] r=0  (not used)
com1_TXbufferBrk                    -574  0xfffffdc2 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -277  0xfffffeeb (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -269  0xfffffef3 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -273  0xfffffeef (PmmC func) args[1] r=1  (not used)
COM2                               63494  0x0000f806 (const dword)  (not used)
com2_Count                          -250  0xffffff06 (PmmC func) args[0] r=1  (not used)
com2_Error                          -258  0xfffffefe (PmmC func) args[0] r=1  (not used)
com2_Full                           -254  0xffffff02 (PmmC func) args[0] r=1  (not used)
com2_Init                           -234  0xffffff16 (PmmC func) args[3] r=0  (not used)
com2_InitBrk                        -579  0xfffffdbd (PmmC func) args[3] r=0  (not used)
com2_Reset                          -246  0xffffff0a (PmmC func) args[0] r=0  (not used)
COM2_RX_pin                         -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
com2_RXblock                        -560  0xfffffdd0 (PmmC func) args[2] r=0  (not used)
com2_Sync                           -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
COM2_TX_pin                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
com2_TXblock                        -559  0xfffffdd1 (PmmC func) args[2] r=0  (not used)
com2_TXbuffer                       -266  0xfffffef6 (PmmC func) args[3] r=0  (not used)
com2_TXbufferBrk                    -575  0xfffffdc1 (PmmC func) args[3] r=0  (not used)
com2_TXbufferHold                   -278  0xfffffeea (PmmC func) args[1] r=1  (not used)
com2_TXcount                        -270  0xfffffef2 (PmmC func) args[0] r=1  (not used)
com2_TXemptyEvent                   -274  0xfffffeee (PmmC func) args[1] r=1  (not used)
COM3                               63495  0x0000f807 (const dword)  (not used)
com3_Count                          -251  0xffffff05 (PmmC func) args[0] r=1  (not used)
com3_Error                          -259  0xfffffefd (PmmC func) args[0] r=1  (not used)
com3_Full                           -255  0xffffff01 (PmmC func) args[0] r=1  (not used)
com3_Init                           -235  0xffffff15 (PmmC func) args[3] r=0  (not used)
com3_InitBrk                        -580  0xfffffdbc (PmmC func) args[3] r=0  (not used)
com3_Reset                          -247  0xffffff09 (PmmC func) args[0] r=0  (not used)
COM3_RX_pin                         -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
com3_RXblock                        -562  0xfffffdce (PmmC func) args[2] r=0  (not used)
com3_Sync                           -263  0xfffffef9 (PmmC func) args[0] r=1  (not used)
COM3_TX_pin                         -231  0xffffff19 (PmmC func) args[1] r=1  (not used)
com3_TXblock                        -561  0xfffffdcf (PmmC func) args[2] r=0  (not used)
com3_TXbuffer                       -267  0xfffffef5 (PmmC func) args[3] r=0  (not used)
com3_TXbufferBrk                    -576  0xfffffdc0 (PmmC func) args[3] r=0  (not used)
com3_TXbufferHold                   -279  0xfffffee9 (PmmC func) args[1] r=1  (not used)
com3_TXcount                        -271  0xfffffef1 (PmmC func) args[0] r=1  (not used)
com3_TXemptyEvent                   -275  0xfffffeed (PmmC func) args[1] r=1  (not used)
com_Count                           -248  0xffffff08 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -256  0xffffff00 (PmmC func) args[0] r=1  (not used)
com_Full                            -252  0xffffff04 (PmmC func) args[0] r=1  (not used)
com_Init                            -232  0xffffff18 (PmmC func) args[3] r=0  (usage 3)
com_InitBrk                         -577  0xfffffdbf (PmmC func) args[3] r=0  (not used)
com_Mode                            -280  0xfffffee8 (PmmC func) args[4] r=1  (not used)
com_Reset                           -244  0xffffff0c (PmmC func) args[0] r=0  (not used)
com_RXblock                         -282  0xfffffee6 (PmmC func) args[2] r=0  (not used)
com_SetBaud                         -225  0xffffff1f (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -260  0xfffffefc (PmmC func) args[0] r=1  (not used)
com_TXblock                         -281  0xfffffee7 (PmmC func) args[2] r=0  (not used)
com_TXbuffer                        -264  0xfffffef8 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferBrk                     -573  0xfffffdc3 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
com_TXcount                         -268  0xfffffef4 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -272  0xfffffef0 (PmmC func) args[1] r=1  (not used)
comRX                                272  0x00000110 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -58  0xffffffc6 (PmmC func) args[1] r=1  (not used)
COUNT_EDGE                             3  0x00000003 (const dword)  (not used)
COUNT_FALL                             2  0x00000002 (const dword)  (not used)
COUNT_OFF                              0  0x00000000 (const dword)  (not used)
COUNT_RISE                             1  0x00000001 (const dword)  (not used)
crc_16                              -567  0xfffffdc9 (PmmC func) args[2] r=1  (not used)
crc_CCITT                           -569  0xfffffdc7 (PmmC func) args[3] r=1  (not used)
crc_CSUM_8                          -566  0xfffffdca (PmmC func) args[2] r=1  (not used)
crc_MODBUS                          -568  0xfffffdc8 (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         268  0x0000010c (mem) word (global)  (usage 45)
CurrentForm                          254  0x000000fe (mem) word (global)  (usage 42)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                   -64  0xffffffc0 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (usage 3)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEBUG_MODE                            64  0x00000040 (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIABLO                                 3  0x00000003 (const dword)  (usage 3)
DIAL_bevColour                        28  0x0000001c (const dword)  (not used)
DIAL_bevColour2                       30  0x0000001e (const dword)  (not used)
DIAL_bevSize                          26  0x0000001a (const dword)  (not used)
DIAL_bgcolour                         22  0x00000016 (const dword)  (not used)
DIAL_capcol                           72  0x00000048 (const dword)  (not used)
DIAL_capfnt                           70  0x00000046 (const dword)  (not used)
DIAL_capofsx                          74  0x0000004a (const dword)  (not used)
DIAL_capofsy                          76  0x0000004c (const dword)  (not used)
DIAL_caption                          78  0x0000004e (const dword)  (not used)
DIAL_colour                           24  0x00000018 (const dword)  (not used)
DIAL_cx                                8  0x00000008 (const dword)  (not used)
DIAL_cy                               10  0x0000000a (const dword)  (not used)
DIAL_F_BG_TRANSPARENT                N/A         N/A (macro)   0x0002   (not used)
DIAL_F_HANDLE_CIRCLE                 N/A         N/A (macro)   0x0000   (not used)
DIAL_F_HANDLE_LINE                   N/A         N/A (macro)   0x0030   (not used)
DIAL_F_HANDLE_RECTANGLE              N/A         N/A (macro)   0x0020   (not used)
DIAL_F_HANDLE_STYLE                  N/A         N/A (macro)   0x00f0   (not used)
DIAL_F_HANDLE_TRIANGLE               N/A         N/A (macro)   0x0010   (not used)
DIAL_F_INDICATOR_CIRCLE              N/A         N/A (macro)   0x0000   (not used)
DIAL_F_INDICATOR_LINE                N/A         N/A (macro)   0x0300   (not used)
DIAL_F_INDICATOR_RECTANGLE           N/A         N/A (macro)   0x0200   (not used)
DIAL_F_INDICATOR_STYLE               N/A         N/A (macro)   0x0f00   (not used)
DIAL_F_INDICATOR_TRIANGLE            N/A         N/A (macro)   0x0100   (not used)
DIAL_F_LABEL_STRINGS                 N/A         N/A (macro)   0x0001   (not used)
DIAL_flags                            80  0x00000050 (const dword)  (not used)
DIAL_h                                 6  0x00000006 (const dword)  (not used)
DIAL_handlecolour                     54  0x00000036 (const dword)  (not used)
DIAL_handlelength                     58  0x0000003a (const dword)  (not used)
DIAL_handlesize                       56  0x00000038 (const dword)  (not used)
DIAL_indc1h                           42  0x0000002a (const dword)  (not used)
DIAL_indc1l                           36  0x00000024 (const dword)  (not used)
DIAL_indc2h                           44  0x0000002c (const dword)  (not used)
DIAL_indc2l                           38  0x00000026 (const dword)  (not used)
DIAL_indc3h                           46  0x0000002e (const dword)  (not used)
DIAL_indc3l                           40  0x00000028 (const dword)  (not used)
DIAL_indlength                        52  0x00000034 (const dword)  (not used)
DIAL_indOffset                        48  0x00000030 (const dword)  (not used)
DIAL_indp1                            32  0x00000020 (const dword)  (not used)
DIAL_indp2                            34  0x00000022 (const dword)  (not used)
DIAL_indsize                          50  0x00000032 (const dword)  (not used)
DIAL_labcolour                        60  0x0000003c (const dword)  (not used)
DIAL_labcount                         66  0x00000042 (const dword)  (not used)
DIAL_labfont                          62  0x0000003e (const dword)  (not used)
DIAL_labofs                           64  0x00000040 (const dword)  (not used)
DIAL_labstr                           68  0x00000044 (const dword)  (not used)
DIAL_maxa                             16  0x00000010 (const dword)  (not used)
DIAL_maxv                             20  0x00000014 (const dword)  (not used)
DIAL_mina                             14  0x0000000e (const dword)  (not used)
DIAL_minv                             18  0x00000012 (const dword)  (not used)
DIAL_rad                              12  0x0000000c (const dword)  (not used)
DIAL_w                                 4  0x00000004 (const dword)  (not used)
DIAL_x                                 0  0x00000000 (const dword)  (not used)
DIAL_y                                 2  0x00000002 (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_BlitPixelsFromCOM0             -372  0xfffffe8c (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM1             -563  0xfffffdcd (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM2             -564  0xfffffdcc (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM3             -565  0xfffffdcb (PmmC func) args[0] r=0  (not used)
disp_Disconnect                     -371  0xfffffe8d (PmmC func) args[0] r=0  (not used)
disp_Init                           -370  0xfffffe8e (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -367  0xfffffe91 (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -363  0xfffffe95 (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -362  0xfffffe96 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -369  0xfffffe8f (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -364  0xfffffe94 (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -365  0xfffffe93 (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -366  0xfffffe92 (PmmC func) args[1] r=0  (not used)
DISPLAY_PAGE                          33  0x00000021 (const dword)  (not used)
dKeyboard                             46  0x0000002e (mem) word[1] (global)  (usage 15)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        3160  0x00000c58 (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                               -65  0xffffffbf (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                            -66  0xffffffbe (PmmC func) args[0] r=1  (not used)
EXTERN                               N/A         N/A (macro)  /**/   (not used)
FALSE_REASON                         141  0x0000008d (const dword)  (not used)
FCY_1                                 20  0x00000014 (const dword)  (not used)
FCY_256                               23  0x00000017 (const dword)  (not used)
FCY_64                                22  0x00000016 (const dword)  (not used)
FCY_8                                 21  0x00000015 (const dword)  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_CheckUpdate                    -607  0xfffffda1 (PmmC func) args[2] r=1  (not used)
file_Close                          -431  0xfffffe51 (PmmC func) args[1] r=1  (not used)
file_Count                          -425  0xfffffe57 (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -426  0xfffffe56 (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -446  0xfffffe42 (PmmC func) args[1] r=1  (not used)
file_Error                          -424  0xfffffe58 (PmmC func) args[0] r=1  (not used)
file_Exec                           -450  0xfffffe3e (PmmC func) args[2] r=1  (not used)
file_Exists                         -429  0xfffffe53 (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -427  0xfffffe55 (PmmC func) args[1] r=1  (not used)
file_FindNext                       -428  0xfffffe54 (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -441  0xfffffe47 (PmmC func) args[1] r=1  (not used)
file_GetS                           -445  0xfffffe43 (PmmC func) args[3] r=1  (not used)
file_GetW                           -443  0xfffffe45 (PmmC func) args[1] r=1  (not used)
file_Image                          -438  0xfffffe4a (PmmC func) args[3] r=1  (not used)
file_Index                          -434  0xfffffe4e (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -448  0xfffffe40 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -451  0xfffffe3d (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -452  0xfffffe3c (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -430  0xfffffe52 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -454  0xfffffe3a (PmmC func) args[1] r=1  (not used)
file_PutC                           -440  0xfffffe48 (PmmC func) args[2] r=1  (not used)
file_PutS                           -444  0xfffffe44 (PmmC func) args[2] r=1  (not used)
file_PutW                           -442  0xfffffe46 (PmmC func) args[2] r=1  (not used)
file_Read                           -432  0xfffffe50 (PmmC func) args[3] r=1  (not used)
file_Rename                         -455  0xfffffe39 (PmmC func) args[2] r=1  (not used)
file_Rewind                         -447  0xfffffe41 (PmmC func) args[1] r=1  (not used)
file_Run                            -449  0xfffffe3f (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -439  0xfffffe49 (PmmC func) args[5] r=1  (not used)
file_Seek                           -433  0xfffffe4f (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_SetDate                        -456  0xfffffe38 (PmmC func) args[7] r=1  (not used)
file_Size                           -437  0xfffffe4b (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -435  0xfffffe4d (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -453  0xfffffe3b (PmmC func) args[0] r=0  (not used)
file_Write                          -436  0xfffffe4c (PmmC func) args[3] r=1  (not used)
FILLPATTERN_0                      65504  0x0000ffe0 (const dword)  (not used)
FILLPATTERN_1                      65505  0x0000ffe1 (const ??? 0)  (not used)
FILLPATTERN_10                     65514  0x0000ffea (const ??? 0)  (not used)
FILLPATTERN_11                     65515  0x0000ffeb (const ??? 0)  (not used)
FILLPATTERN_12                     65516  0x0000ffec (const ??? 0)  (not used)
FILLPATTERN_13                     65517  0x0000ffed (const ??? 0)  (not used)
FILLPATTERN_14                     65518  0x0000ffee (const ??? 0)  (not used)
FILLPATTERN_15                     65519  0x0000ffef (const ??? 0)  (not used)
FILLPATTERN_16                     65520  0x0000fff0 (const ??? 0)  (not used)
FILLPATTERN_17                     65521  0x0000fff1 (const ??? 0)  (not used)
FILLPATTERN_18                     65522  0x0000fff2 (const ??? 0)  (not used)
FILLPATTERN_19                     65523  0x0000fff3 (const ??? 0)  (not used)
FILLPATTERN_2                      65506  0x0000ffe2 (const ??? 0)  (not used)
FILLPATTERN_20                     65524  0x0000fff4 (const ??? 0)  (not used)
FILLPATTERN_21                     65525  0x0000fff5 (const ??? 0)  (not used)
FILLPATTERN_22                     65526  0x0000fff6 (const ??? 0)  (not used)
FILLPATTERN_23                     65527  0x0000fff7 (const ??? 0)  (not used)
FILLPATTERN_24                     65528  0x0000fff8 (const ??? 0)  (not used)
FILLPATTERN_25                     65529  0x0000fff9 (const ??? 0)  (not used)
FILLPATTERN_26                     65530  0x0000fffa (const ??? 0)  (not used)
FILLPATTERN_27                     65531  0x0000fffb (const ??? 0)  (not used)
FILLPATTERN_28                     65532  0x0000fffc (const ??? 0)  (not used)
FILLPATTERN_29                     65533  0x0000fffd (const ??? 0)  (not used)
FILLPATTERN_3                      65507  0x0000ffe3 (const ??? 0)  (not used)
FILLPATTERN_30                     65534  0x0000fffe (const ??? 0)  (not used)
FILLPATTERN_31                     65535  0x0000ffff (const ??? 0)  (not used)
FILLPATTERN_4                      65508  0x0000ffe4 (const ??? 0)  (not used)
FILLPATTERN_5                      65509  0x0000ffe5 (const ??? 0)  (not used)
FILLPATTERN_6                      65510  0x0000ffe6 (const ??? 0)  (not used)
FILLPATTERN_7                      65511  0x0000ffe7 (const ??? 0)  (not used)
FILLPATTERN_8                      65512  0x0000ffe8 (const ??? 0)  (not used)
FILLPATTERN_9                      65513  0x0000ffe9 (const ??? 0)  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_Bank                          -498  0xfffffe0e (PmmC func) args[0] r=1  (not used)
flash_Blit1                         -507  0xfffffe05 (PmmC func) args[4] r=1  (not used)
flash_Blit16                        -503  0xfffffe09 (PmmC func) args[3] r=1  (not used)
flash_Blit2                         -506  0xfffffe06 (PmmC func) args[4] r=1  (not used)
flash_Blit4                         -505  0xfffffe07 (PmmC func) args[4] r=1  (not used)
flash_Blit8                         -504  0xfffffe08 (PmmC func) args[3] r=1  (not used)
flash_Copy                          -496  0xfffffe10 (PmmC func) args[4] r=1  (not used)
flash_EraseBank                     -499  0xfffffe0d (PmmC func) args[2] r=1  (not used)
flash_Exec                          -508  0xfffffe04 (PmmC func) args[2] r=1  (not used)
flash_FunctionCall                  -624  0xfffffd90 (PmmC func) args[7] r=1  (not used)
flash_GetByte                       -494  0xfffffe12 (PmmC func) args[2] r=1  (not used)
flash_GetWord                       -495  0xfffffe11 (PmmC func) args[2] r=1  (not used)
flash_LoadFile                      -500  0xfffffe0c (PmmC func) args[2] r=1  (not used)
flash_LoadSPIflash                  -625  0xfffffd8f (PmmC func) args[3] r=1  (not used)
flash_putstr                        -502  0xfffffe0a (PmmC func) args[2] r=1  (not used)
FLASH_READ_PROTECT                    16  0x00000010 (const dword)  (not used)
flash_Run                           -497  0xfffffe0f (PmmC func) args[1] r=1  (not used)
FLASH_WRITE_PROTECT                   32  0x00000020 (const dword)  (not used)
flash_WriteBlock                    -501  0xfffffe0b (PmmC func) args[3] r=1  (not used)
FLASHBANK_0                            0  0x00000000 (const dword)  (not used)
FLASHBANK_1                            1  0x00000001 (const dword)  (usage 3)
FLASHBANK_2                            2  0x00000002 (const dword)  (not used)
FLASHBANK_3                            3  0x00000003 (const dword)  (not used)
FLASHBANK_4                            4  0x00000004 (const dword)  (not used)
FLASHBANK_5                            5  0x00000005 (const dword)  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
flt_ABS                              -84  0xffffffac (PmmC func) args[2] r=1  (not used)
flt_ACOS                             -85  0xffffffab (PmmC func) args[2] r=1  (not used)
flt_ADD                              -97  0xffffff9f (PmmC func) args[3] r=1  (not used)
flt_ASIN                             -86  0xffffffaa (PmmC func) args[2] r=1  (not used)
flt_ATAN                             -87  0xffffffa9 (PmmC func) args[2] r=1  (not used)
flt_CEIL                             -90  0xffffffa6 (PmmC func) args[2] r=1  (not used)
flt_COS                              -88  0xffffffa8 (PmmC func) args[2] r=1  (not used)
flt_DIV                             -100  0xffffff9c (PmmC func) args[3] r=1  (not used)
flt_EQ                              -101  0xffffff9b (PmmC func) args[2] r=1  (not used)
flt_EXP                              -89  0xffffffa7 (PmmC func) args[2] r=1  (not used)
flt_FLOOR                            -91  0xffffffa5 (PmmC func) args[2] r=1  (not used)
flt_FTOI                            -108  0xffffff94 (PmmC func) args[1] r=1  (not used)
flt_GE                              -104  0xffffff98 (PmmC func) args[2] r=1  (not used)
flt_GT                              -103  0xffffff99 (PmmC func) args[2] r=1  (not used)
flt_ITOF                             -79  0xffffffb1 (PmmC func) args[2] r=1  (not used)
flt_LE                              -106  0xffffff96 (PmmC func) args[2] r=1  (not used)
flt_LOG                              -93  0xffffffa3 (PmmC func) args[2] r=1  (not used)
flt_LT                              -105  0xffffff97 (PmmC func) args[2] r=1  (not used)
flt_LTOF                             -81  0xffffffaf (PmmC func) args[2] r=1  (not used)
flt_MUL                              -99  0xffffff9d (PmmC func) args[3] r=1  (not used)
flt_NE                              -102  0xffffff9a (PmmC func) args[2] r=1  (not used)
flt_POW                              -96  0xffffffa0 (PmmC func) args[3] r=1  (not used)
flt_PRINT                            -83  0xffffffad (PmmC func) args[2] r=1  (not used)
flt_PRINTxy                         -109  0xffffff93 (PmmC func) args[4] r=1  (not used)
flt_SGN                             -107  0xffffff95 (PmmC func) args[1] r=1  (not used)
flt_SIN                              -92  0xffffffa4 (PmmC func) args[2] r=1  (not used)
flt_SQR                              -94  0xffffffa2 (PmmC func) args[2] r=1  (not used)
flt_SUB                              -98  0xffffff9e (PmmC func) args[3] r=1  (not used)
flt_TAN                              -95  0xffffffa1 (PmmC func) args[2] r=1  (not used)
flt_UITOF                            -80  0xffffffb0 (PmmC func) args[2] r=1  (not used)
flt_ULTOF                            -82  0xffffffae (PmmC func) args[2] r=1  (not used)
flt_VAL                              -78  0xffffffb2 (PmmC func) args[2] r=1  (not used)
FONT1                                  1  0x00000001 (const dword)  (not used)
FONT2                                  2  0x00000002 (const dword)  (not used)
FONT3                                  3  0x00000003 (const dword)  (not used)
FONT_1                                 1  0x00000001 (const dword)  (not used)
FONT_10                               10  0x0000000a (const dword)  (not used)
FONT_11                               11  0x0000000b (const dword)  (not used)
FONT_2                                 2  0x00000002 (const dword)  (not used)
FONT_3                                 3  0x00000003 (const dword)  (not used)
FONT_4                                 4  0x00000004 (const dword)  (not used)
FONT_5                                 5  0x00000005 (const dword)  (not used)
FONT_6                                 6  0x00000006 (const dword)  (not used)
FONT_7                                 7  0x00000007 (const dword)  (not used)
FONT_8                                 8  0x00000008 (const dword)  (not used)
FONT_9                                 9  0x00000009 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                         764  0x000002fcFormBGcolors                         764  0x000002fc (mem) word[7] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
FormEndIndex                         290  0x00000122FormEndIndex                         290  0x00000122 (mem) word[7] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
FormStartIndex                       276  0x00000114FormStartIndex                       276  0x00000114 (mem) word[7] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAUGE_COLOR                           18  0x00000012 (const dword)  (not used)
GAUGE_F_HORZ                         N/A         N/A (macro)    0x0002   (not used)
GAUGE_F_TOPRIGHT                     N/A         N/A (macro)    0x0001   (not used)
GAUGE_FLAGS                           36  0x00000024 (const dword)  (not used)
GAUGE_H                                6  0x00000006 (const dword)  (not used)
GAUGE_MAXV                            12  0x0000000c (const dword)  (not used)
GAUGE_MINV                            10  0x0000000a (const dword)  (not used)
GAUGE_P1                              34  0x00000022 (const dword)  (not used)
GAUGE_P1H                             22  0x00000016 (const dword)  (not used)
GAUGE_P1L                             20  0x00000014 (const dword)  (not used)
GAUGE_P2                              32  0x00000020 (const dword)  (not used)
GAUGE_P2H                             26  0x0000001a (const dword)  (not used)
GAUGE_P2L                             24  0x00000018 (const dword)  (not used)
GAUGE_P3H                             30  0x0000001e (const dword)  (not used)
GAUGE_P3L                             28  0x0000001c (const dword)  (not used)
GAUGE_SPACING                         16  0x00000010 (const dword)  (not used)
GAUGE_T                                8  0x00000008 (const dword)  (not used)
GAUGE_TICKH                           14  0x0000000e (const dword)  (not used)
GAUGE_W                                4  0x00000004 (const dword)  (not used)
GAUGE_X                                0  0x00000000 (const dword)  (not used)
GAUGE_Y                                2  0x00000002 (const dword)  (not used)
Gen4_ULCD_43D_CLB_DIABLO16_GFX         0  0x00000000 (const ??? 0)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                        -165  0xffffff5b (PmmC func) args[1] r=1  (not used)
gfx_565to332                        -166  0xffffff5a (PmmC func) args[1] r=1  (not used)
gfx_AngularMeter                    -582  0xfffffdba (PmmC func) args[3] r=0  (not used)
gfx_Arc                             -172  0xffffff54 (PmmC func) args[7] r=0  (not used)
gfx_BevelRadius                     -194  0xffffff3e (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -196  0xffffff3c (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -195  0xffffff3d (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                        -184  0xffffff48 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                           -149  0xffffff6b (PmmC func) args[2] r=0  (not used)
gfx_Bullet                          -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
gfx_Button                          -155  0xffffff65 (PmmC func) args[9] r=1  (not used)
gfx_Button2                         -156  0xffffff64 (PmmC func) args[8] r=0  (not used)
gfx_Button3                         -157  0xffffff63 (PmmC func) args[8] r=0  (not used)
gfx_Button4                         -603  0xfffffda5 (PmmC func) args[3] r=0  (not used)
gfx_ChangeColour                    -151  0xffffff69 (PmmC func) args[2] r=0  (not used)
gfx_CheckBox                        -158  0xffffff62 (PmmC func) args[8] r=0  (not used)
gfx_Circle                          -136  0xffffff78 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                    -137  0xffffff77 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                        -186  0xffffff46 (PmmC func) args[1] r=1  (not used)
gfx_ClipWindow                      -150  0xffffff6a (PmmC func) args[4] r=0  (not used)
gfx_Cls                             -126  0xffffff82 (PmmC func) args[0] r=0  (usage 6)
gfx_Contrast                        -192  0xffffff40 (PmmC func) args[1] r=1  (usage 3)
gfx_Dial                            -585  0xfffffdb7 (PmmC func) args[3] r=0  (not used)
gfx_Dot                             -145  0xffffff6f (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                         -153  0xffffff67 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                   -154  0xffffff66 (PmmC func) args[5] r=0  (not used)
gfx_FillPattern                     -170  0xffffff56 (PmmC func) args[2] r=1  (not used)
gfx_FrameDelay                      -189  0xffffff43 (PmmC func) args[1] r=1  (not used)
gfx_Gauge                           -586  0xfffffdb6 (PmmC func) args[3] r=0  (not used)
gfx_Get                             -182  0xffffff4a (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                        -139  0xffffff75 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -176  0xffffff50 (PmmC func) args[7] r=0  (not used)
gfx_GradientColor                   -627  0xfffffd8d (PmmC func) args[6] r=1  (not used)
gfx_GradientShape                   -626  0xfffffd8e (PmmC func) args[19] r=0  (not used)
gfx_GradTriangleFilled              -628  0xfffffd8c (PmmC func) args[12] r=0  (not used)
gfx_Hline                           -132  0xffffff7c (PmmC func) args[4] r=1  (not used)
gfx_IncX                            -147  0xffffff6d (PmmC func) args[0] r=1  (not used)
gfx_IncY                            -148  0xffffff6c (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
gfx_Led                             -604  0xfffffda4 (PmmC func) args[3] r=0  (not used)
gfx_LedDigit                        -588  0xfffffdb4 (PmmC func) args[6] r=0  (not used)
gfx_LedDigits                       -587  0xfffffdb5 (PmmC func) args[3] r=0  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
gfx_Line                            -131  0xffffff7d (PmmC func) args[5] r=0  (not used)
gfx_LinePattern                     -193  0xffffff3f (PmmC func) args[1] r=1  (not used)
gfx_LineRel                         -130  0xffffff7e (PmmC func) args[2] r=0  (not used)
gfx_LineTo                          -129  0xffffff7f (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                         -128  0xffffff80 (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                          -127  0xffffff81 (PmmC func) args[2] r=0  (not used)
gfx_Needle                          -584  0xfffffdb8 (PmmC func) args[3] r=0  (not used)
gfx_ObjectColour                    -185  0xffffff47 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                           -142  0xffffff72 (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                       -141  0xffffff73 (PmmC func) args[2] r=0  (not used)
gfx_Origin                          -169  0xffffff57 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                   -191  0xffffff41 (PmmC func) args[1] r=1  (not used)
gfx_Panel                           -161  0xffffff5f (PmmC func) args[6] r=0  (not used)
gfx_Panel2                          -583  0xfffffdb9 (PmmC func) args[10] r=0  (not used)
gfx_PenSize                         -183  0xffffff49 (PmmC func) args[1] r=1  (not used)
gfx_PieSlice                        -171  0xffffff55 (PmmC func) args[9] r=0  (not used)
gfx_PointWithinBox                  -199  0xffffff39 (PmmC func) args[3] r=1  (not used)
gfx_PointWithinRectangle            -200  0xffffff38 (PmmC func) args[3] r=1  (not used)
gfx_Polygon                         -144  0xffffff70 (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                   -168  0xffffff58 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                        -143  0xffffff71 (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                        -138  0xffffff76 (PmmC func) args[3] r=0  (not used)
gfx_RadioButton                     -159  0xffffff61 (PmmC func) args[8] r=0  (not used)
gfx_ReadBresLine                    -178  0xffffff4e (PmmC func) args[5] r=1  (not used)
gfx_ReadGRAMarea                    -180  0xffffff4c (PmmC func) args[5] r=1  (not used)
gfx_Rectangle                       -134  0xffffff7a (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                 -135  0xffffff79 (PmmC func) args[5] r=0  (not used)
gfx_RGBto565                        -164  0xffffff5c (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
gfx_RingSegment                     -581  0xfffffdbb (PmmC func) args[7] r=0  (not used)
gfx_RoundGradient                   -177  0xffffff4f (PmmC func) args[8] r=0  (not used)
gfx_RoundPanel                      -175  0xffffff51 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -173  0xffffff53 (PmmC func) args[6] r=0  (not used)
gfx_RulerGauge                      -606  0xfffffda2 (PmmC func) args[3] r=0  (not used)
gfx_Scale                           -605  0xfffffda3 (PmmC func) args[2] r=0  (not used)
gfx_Scope                           -532  0xfffffdec (PmmC func) args[19] r=0  (not used)
gfx_ScreenCopyPaste                 -163  0xffffff5d (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                      -190  0xffffff42 (PmmC func) args[1] r=1  (usage 3)
gfx_Set                             -125  0xffffff83 (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                   -152  0xffffff68 (PmmC func) args[0] r=0  (not used)
gfx_Slider                          -162  0xffffff5e (PmmC func) args[8] r=1  (not used)
gfx_Slider2                         -160  0xffffff60 (PmmC func) args[8] r=1  (not used)
gfx_Slider5                         -601  0xfffffda7 (PmmC func) args[3] r=0  (not used)
gfx_Surround                        -174  0xffffff52 (PmmC func) args[7] r=0  (not used)
gfx_Switch                          -602  0xfffffda6 (PmmC func) args[3] r=0  (usage 3)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                    -188  0xffffff44 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour               -187  0xffffff45 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                        -140  0xffffff74 (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                  -167  0xffffff59 (PmmC func) args[7] r=0  (not used)
gfx_Vline                           -133  0xffffff7b (PmmC func) args[4] r=1  (not used)
gfx_WriteBresLine                   -179  0xffffff4d (PmmC func) args[5] r=0  (not used)
gfx_WriteGRAMarea                   -181  0xffffff4b (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
gfx_XYlinToVal                      -634  0xfffffd86 (PmmC func) args[7] r=1  (usage 3)
gfx_XYrotToVal                      -633  0xfffffd87 (PmmC func) args[7] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -198  0xffffff3a (PmmC func) args[1] r=1  (not used)
gfxInternals                          43  0x0000002bgfxInternals                          43  0x0000002b (mem) word[29] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
gfxIntParms                          101  0x00000065gfxIntParms                          101  0x00000065 (mem) word[29] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
gfxIntStrings                        159  0x0000009fgfxIntStrings                        159  0x0000009f (mem) word[29] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectDATA                          112  0x00000070 (mem) word (global)  (usage 6)
GObjectFunc                          108  0x0000006c (mem) word (global)  (usage 6)
GObjectIdx                           106  0x0000006a (mem) word (global)  (usage 24)
GObjectParms                         114  0x00000072 (mem) word (global)  (usage 3)
GObjectRAM                           110  0x0000006e (mem) word (global)  (usage 15)
GObjectStrings                       116  0x00000074 (mem) word (global)  (usage 3)
GObjectType                          264  0x00000108 (mem) word (global)  (usage 93)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                               -48  0xffffffd0 (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 111)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
HYPER                                  3  0x00000003 (const dword)  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -305  0xfffffecf (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -314  0xfffffec6 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -311  0xfffffec9 (PmmC func) args[0] r=1  (not used)
I2C1_Close                          -287  0xfffffee1 (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -323  0xfffffebd (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -320  0xfffffec0 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -317  0xfffffec3 (PmmC func) args[0] r=1  (not used)
I2C1_Nack                           -308  0xfffffecc (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -284  0xfffffee4 (PmmC func) args[3] r=1  (not used)
I2C1_Putn                           -329  0xfffffeb7 (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -299  0xfffffed5 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -290  0xfffffede (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -293  0xfffffedb (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -302  0xfffffed2 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -306  0xfffffece (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -315  0xfffffec5 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -312  0xfffffec8 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -288  0xfffffee0 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -321  0xfffffebf (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -318  0xfffffec2 (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -309  0xfffffecb (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -285  0xfffffee3 (PmmC func) args[3] r=1  (not used)
I2C2_Putn                           -330  0xfffffeb6 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -327  0xfffffeb9 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -300  0xfffffed4 (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -297  0xfffffed7 (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -291  0xfffffedd (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -294  0xfffffeda (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -303  0xfffffed1 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -307  0xfffffecd (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -316  0xfffffec4 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -313  0xfffffec7 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -289  0xfffffedf (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -322  0xfffffebe (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -319  0xfffffec1 (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -310  0xfffffeca (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
I2C3_Putn                           -331  0xfffffeb5 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -328  0xfffffeb8 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -301  0xfffffed3 (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -298  0xfffffed6 (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -292  0xfffffedc (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -295  0xfffffed9 (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -304  0xfffffed0 (PmmC func) args[1] r=1  (not used)
I2C_10KHZ                              3  0x00000003 (const dword)  (not used)
I2C_20KHZ                              4  0x00000004 (const dword)  (not used)
I2C_250KHZ                             6  0x00000006 (const dword)  (not used)
I2C_50KHZ                              5  0x00000005 (const dword)  (not used)
I2C_CLOCK_STRETCHING               32768  0x00008000 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2CS_Close                          -636  0xfffffd84 (PmmC func) args[0] r=0  (not used)
I2CS_Count                          -638  0xfffffd82 (PmmC func) args[0] r=1  (not used)
I2CS_Open                           -635  0xfffffd85 (PmmC func) args[6] r=1  (not used)
I2CS_Overflow                       -641  0xfffffd7f (PmmC func) args[0] r=1  (not used)
I2CS_Read                           -639  0xfffffd81 (PmmC func) args[0] r=1  (not used)
I2CS_Release                        -640  0xfffffd80 (PmmC func) args[0] r=0  (not used)
I2CS_Write                          -637  0xfffffd83 (PmmC func) args[1] r=0  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 6)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                           0  0x00000000 (const dword)  (not used)
iFormEndIndex                        318  0x0000013eiFormEndIndex                        318  0x0000013e (mem) word[7] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
iFormStartIndex                      304  0x00000130iFormStartIndex                      304  0x00000130 (mem) word[7] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
iiFormEndIndex                       346  0x0000015aiiFormEndIndex                       346  0x0000015a (mem) word[7] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (not used)
iiFormStartIndex                     332  0x0000014ciiFormStartIndex                     332  0x0000014c (mem) word[7] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (not used)
iiLeddigits0                           5  0x00000005 (const ??? 0)  (not used)
iiLeddigits1                          38  0x00000026 (const ??? 0)  (not used)
iImage0                                0  0x00000000 (const ??? 0)  (usage 3)
iISwitch0                              0  0x00000000 (const ??? 0)  (not used)
IISwitch0                            223  0x000000dfIISwitch0                            223  0x000000df (mem) word[17] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
iKeyboard0                            23  0x00000017 (const ??? 0)  (usage 3)
iKeyboard0_0                          24  0x00000018 (const ??? 0)  (not used)
iKeyboard0_1                          25  0x00000019 (const ??? 0)  (not used)
iKeyboard0_10                         34  0x00000022 (const ??? 0)  (not used)
iKeyboard0_11                         35  0x00000023 (const ??? 0)  (not used)
iKeyboard0_2                          26  0x0000001a (const ??? 0)  (not used)
iKeyboard0_3                          27  0x0000001b (const ??? 0)  (not used)
iKeyboard0_4                          28  0x0000001c (const ??? 0)  (not used)
iKeyboard0_5                          29  0x0000001d (const ??? 0)  (not used)
iKeyboard0_6                          30  0x0000001e (const ??? 0)  (not used)
iKeyboard0_7                          31  0x0000001f (const ??? 0)  (not used)
iKeyboard0_8                          32  0x00000020 (const ??? 0)  (not used)
iKeyboard0_9                          33  0x00000021 (const ??? 0)  (not used)
iKeyboard0keystrokes                   7  0x00000007iKeyboard0keystrokes                   7  0x00000007 (mem) byte[12] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
iLeddigits0                            4  0x00000004 (const ??? 0)  (usage 3)
iLeddigits1                           37  0x00000025 (const ??? 0)  (usage 3)
ILINEARIP_COLOR1                      12  0x0000000c (const dword)  (not used)
ILINEARIP_COLOR2                      14  0x0000000e (const dword)  (not used)
ILINEARIP_COLOR3                      16  0x00000010 (const dword)  (not used)
ILINEARIP_COLOR4                      18  0x00000012 (const dword)  (not used)
ILINEARIP_COLOR5                      20  0x00000014 (const dword)  (not used)
ILINEARIP_COLOR6                      22  0x00000016 (const dword)  (not used)
ILINEARIP_H                            6  0x00000006 (const dword)  (not used)
ILINEARIP_INDEX                        8  0x00000008 (const dword)  (not used)
ILINEARIP_MAXVAL                      42  0x0000002a (const dword)  (not used)
ILINEARIP_MINVAL                      44  0x0000002c (const dword)  (not used)
ILINEARIP_OFFSET_BR                   46  0x0000002e (const dword)  (not used)
ILINEARIP_OFFSET_TL                   48  0x00000030 (const dword)  (not used)
ILINEARIP_ORIENTATION                 10  0x0000000a (const dword)  (not used)
ILINEARIP_TEXT1                       36  0x00000024 (const dword)  (not used)
ILINEARIP_TEXT2                       38  0x00000026 (const dword)  (not used)
ILINEARIP_TEXT3                       40  0x00000028 (const dword)  (not used)
ILINEARIP_VALUE1                      24  0x00000018 (const dword)  (not used)
ILINEARIP_VALUE2                      26  0x0000001a (const dword)  (not used)
ILINEARIP_VALUE3                      28  0x0000001c (const dword)  (not used)
ILINEARIP_VALUE4                      30  0x0000001e (const dword)  (not used)
ILINEARIP_VALUE5                      32  0x00000020 (const dword)  (not used)
ILINEARIP_VALUE6                      34  0x00000022 (const dword)  (not used)
ILINEARIP_W                            4  0x00000004 (const dword)  (not used)
ILINEARIP_X                            0  0x00000000 (const dword)  (not used)
ILINEARIP_Y                            2  0x00000002 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (usage 3)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 45)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 12)
IMAGE_TAG2                            13  0x0000000d (const dword)  (usage 9)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (usage 3)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
ImageTouched                         258  0x00000102 (mem) word (global)  (usage 93)
img_ClearAttributes                 -383  0xfffffe81 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -376  0xfffffe88 (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -375  0xfffffe89 (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
img_FileExec                        -619  0xfffffd95 (PmmC func) args[3] r=1  (not used)
img_FileGetC                        -613  0xfffffd9b (PmmC func) args[2] r=1  (not used)
img_FileGetS                        -615  0xfffffd99 (PmmC func) args[4] r=1  (not used)
img_FileGetW                        -614  0xfffffd9a (PmmC func) args[2] r=1  (not used)
img_FileIndex                       -610  0xfffffd9e (PmmC func) args[5] r=1  (not used)
img_FileLoadFunction                -617  0xfffffd97 (PmmC func) args[2] r=1  (not used)
img_FilePlayWAV                     -620  0xfffffd94 (PmmC func) args[2] r=1  (not used)
img_FileRead                        -608  0xfffffda0 (PmmC func) args[4] r=1  (not used)
img_FileRewind                      -616  0xfffffd98 (PmmC func) args[2] r=1  (not used)
img_FileRun                         -618  0xfffffd96 (PmmC func) args[3] r=1  (not used)
img_FileSeek                        -609  0xfffffd9f (PmmC func) args[4] r=1  (not used)
img_FileSize                        -612  0xfffffd9c (PmmC func) args[4] r=1  (not used)
img_FileTell                        -611  0xfffffd9d (PmmC func) args[4] r=1  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -380  0xfffffe84 (PmmC func) args[3] r=1  (usage 45)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SelectReadPosition              -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_SequentialRead                  -386  0xfffffe7e (PmmC func) args[2] r=1  (not used)
img_SetAttributes                   -382  0xfffffe82 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -374  0xfffffe8a (PmmC func) args[4] r=1  (not used)
img_SetWord                         -379  0xfffffe85 (PmmC func) args[4] r=1  (usage 27)
img_Show                            -381  0xfffffe83 (PmmC func) args[2] r=1  (usage 18)
img_Touched                         -384  0xfffffe80 (PmmC func) args[2] r=1  (usage 3)
img_TxtFontID                       -621  0xfffffd93 (PmmC func) args[2] r=1  (not used)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
InputControls                        360  0x00000168InputControls                        360  0x00000168 (mem) word[37] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
InputCS                              512  0x00000200 (mem) word (global)  (usage 15)
InputData                            436  0x000001b4InputData                            436  0x000001b4 (mem) word[121] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 27)
InternalInputControls                434  0x000001b2InternalInputControls                434  0x000001b2 (mem) word[1] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
INVERSE                               64  0x00000040 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
IROTARYIP_COLOR1                      10  0x0000000a (const dword)  (not used)
IROTARYIP_COLOR2                      12  0x0000000c (const dword)  (not used)
IROTARYIP_COLOR3                      14  0x0000000e (const dword)  (not used)
IROTARYIP_COLOR4                      16  0x00000010 (const dword)  (not used)
IROTARYIP_COLOR5                      18  0x00000012 (const dword)  (not used)
IROTARYIP_COLOR6                      20  0x00000014 (const dword)  (not used)
IROTARYIP_H                            6  0x00000006 (const dword)  (not used)
IROTARYIP_INDEX                        8  0x00000008 (const dword)  (not used)
IROTARYIP_MAXANGLE                    40  0x00000028 (const dword)  (not used)
IROTARYIP_MAXVALUE                    42  0x0000002a (const dword)  (not used)
IROTARYIP_MINANGLE                    44  0x0000002c (const dword)  (not used)
IROTARYIP_MINVALUE                    46  0x0000002e (const dword)  (not used)
IROTARYIP_TEXT1                       34  0x00000022 (const dword)  (not used)
IROTARYIP_TEXT2                       36  0x00000024 (const dword)  (not used)
IROTARYIP_TEXT3                       38  0x00000026 (const dword)  (not used)
IROTARYIP_VALUE1                      22  0x00000016 (const dword)  (not used)
IROTARYIP_VALUE2                      24  0x00000018 (const dword)  (not used)
IROTARYIP_VALUE3                      26  0x0000001a (const dword)  (not used)
IROTARYIP_VALUE4                      28  0x0000001c (const dword)  (not used)
IROTARYIP_VALUE5                      30  0x0000001e (const dword)  (not used)
IROTARYIP_VALUE6                      32  0x00000020 (const dword)  (not used)
IROTARYIP_W                            4  0x00000004 (const dword)  (not used)
IROTARYIP_X                            0  0x00000000 (const dword)  (not used)
IROTARYIP_Y                            2  0x00000002 (const dword)  (not used)
isalnum                              -41  0xffffffd7 (PmmC func) args[1] r=1  (not used)
isalpha                              -40  0xffffffd8 (PmmC func) args[1] r=1  (not used)
isdigit                              -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
islower                              -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
isprint                              -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
isspace                              -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
iStatictext0                           6  0x00000006 (const ??? 0)  (usage 3)
iStatictext1                           7  0x00000007 (const ??? 0)  (usage 3)
iStatictext10                         39  0x00000027 (const ??? 0)  (usage 3)
iStatictext2                           8  0x00000008 (const ??? 0)  (usage 3)
iStatictext3                           9  0x00000009 (const ??? 0)  (usage 3)
iStatictext4                          12  0x0000000c (const ??? 0)  (usage 3)
iStatictext5                          13  0x0000000d (const ??? 0)  (usage 3)
iStatictext6                          14  0x0000000e (const ??? 0)  (usage 3)
iStatictext7                          17  0x00000011 (const ??? 0)  (usage 3)
iStatictext8                          18  0x00000012 (const ??? 0)  (usage 3)
iStatictext9                          22  0x00000016 (const ??? 0)  (usage 3)
isupper                              -38  0xffffffda (PmmC func) args[1] r=1  (not used)
iswhite                              -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
isxdigit                             -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -404  0xfffffe6c (PmmC func) args[1] r=0  (not used)
ITOGGLEIP_COLOR1                      10  0x0000000a (const dword)  (not used)
ITOGGLEIP_COLOR2                      12  0x0000000c (const dword)  (not used)
ITOGGLEIP_COLOR3                      14  0x0000000e (const dword)  (not used)
ITOGGLEIP_COLOR4                      16  0x00000010 (const dword)  (not used)
ITOGGLEIP_COLOR5                      18  0x00000012 (const dword)  (not used)
ITOGGLEIP_COLOR6                      20  0x00000014 (const dword)  (not used)
ITOGGLEIP_H                            6  0x00000006 (const dword)  (not used)
ITOGGLEIP_INDEX                        8  0x00000008 (const dword)  (not used)
ITOGGLEIP_MATRIX                      40  0x00000028 (const dword)  (not used)
ITOGGLEIP_MOMENTARY                   42  0x0000002a (const dword)  (not used)
ITOGGLEIP_TEXT1                       34  0x00000022 (const dword)  (not used)
ITOGGLEIP_TEXT2                       36  0x00000024 (const dword)  (not used)
ITOGGLEIP_TEXT3                       38  0x00000026 (const dword)  (not used)
ITOGGLEIP_VALUE1                      22  0x00000016 (const dword)  (not used)
ITOGGLEIP_VALUE2                      24  0x00000018 (const dword)  (not used)
ITOGGLEIP_VALUE3                      26  0x0000001a (const dword)  (not used)
ITOGGLEIP_VALUE4                      28  0x0000001c (const dword)  (not used)
ITOGGLEIP_VALUE5                      30  0x0000001e (const dword)  (not used)
ITOGGLEIP_VALUE6                      32  0x00000020 (const dword)  (not used)
ITOGGLEIP_W                            4  0x00000004 (const dword)  (not used)
ITOGGLEIP_X                            0  0x00000000 (const dword)  (not used)
ITOGGLEIP_Y                            2  0x00000002 (const dword)  (not used)
IUSERGAUGE_COLOR1                     10  0x0000000a (const dword)  (not used)
IUSERGAUGE_COLOR2                     12  0x0000000c (const dword)  (not used)
IUSERGAUGE_COLOR3                     14  0x0000000e (const dword)  (not used)
IUSERGAUGE_COLOR4                     16  0x00000010 (const dword)  (not used)
IUSERGAUGE_COLOR5                     18  0x00000012 (const dword)  (not used)
IUSERGAUGE_COLOR6                     20  0x00000014 (const dword)  (not used)
IUSERGAUGE_H                           6  0x00000006 (const dword)  (not used)
IUSERGAUGE_INDEX                       8  0x00000008 (const dword)  (not used)
IUSERGAUGE_TEXT1                      34  0x00000022 (const dword)  (not used)
IUSERGAUGE_TEXT2                      36  0x00000024 (const dword)  (not used)
IUSERGAUGE_TEXT3                      38  0x00000026 (const dword)  (not used)
IUSERGAUGE_VALUE1                     22  0x00000016 (const dword)  (not used)
IUSERGAUGE_VALUE2                     24  0x00000018 (const dword)  (not used)
IUSERGAUGE_VALUE3                     26  0x0000001a (const dword)  (not used)
IUSERGAUGE_VALUE4                     28  0x0000001c (const dword)  (not used)
IUSERGAUGE_VALUE5                     30  0x0000001e (const dword)  (not used)
IUSERGAUGE_VALUE6                     32  0x00000020 (const dword)  (not used)
IUSERGAUGE_W                           4  0x00000004 (const dword)  (not used)
IUSERGAUGE_X                           0  0x00000000 (const dword)  (not used)
IUSERGAUGE_Y                           2  0x00000002 (const dword)  (not used)
iUserled0                             10  0x0000000a (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton0                            1  0x00000001 (const ??? 0)  (usage 3)
iWinbutton1                            2  0x00000002 (const ??? 0)  (usage 3)
iWinbutton2                            3  0x00000003 (const ??? 0)  (usage 3)
iWinbutton3                           11  0x0000000b (const ??? 0)  (usage 3)
iWinbutton4                           15  0x0000000f (const ??? 0)  (usage 3)
iWinbutton5                           16  0x00000010 (const ??? 0)  (usage 3)
iWinbutton6                           19  0x00000013 (const ??? 0)  (usage 3)
iWinbutton7                           20  0x00000014 (const ??? 0)  (usage 3)
iWinbutton8                           21  0x00000015 (const ??? 0)  (usage 3)
iWinbutton9                           36  0x00000024 (const ??? 0)  (usage 3)
KbCapsBit                              2  0x00000002 (const dword)  (usage 12)
KbCtrlBit                              4  0x00000004 (const dword)  (usage 21)
kbDown                              5779  0x00001693 (User func) args[4] r=0  (usage 3)
KbShiftBit                             1  0x00000001 (const dword)  (usage 18)
KbShiftCapsBits                        3  0x00000003 (const dword)  (usage 18)
kbUp                                5612  0x000015ec (User func) args[2] r=0  (usage 3)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                  778  0x0000030akKeyboardKeystrokes                  778  0x0000030a (mem) word[1] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LED1_cbe                              10  0x0000000a (const dword)  (not used)
LED1_cbs                               8  0x00000008 (const dword)  (not used)
LED1_cOff                             16  0x00000010 (const dword)  (not used)
LED1_cOn                              14  0x0000000e (const dword)  (not used)
LED1_cs                               12  0x0000000c (const dword)  (not used)
LED1_h                                 6  0x00000006 (const dword)  (not used)
LED1_iBr                              18  0x00000012 (const dword)  (not used)
LED1_iLr                              22  0x00000016 (const dword)  (not used)
LED1_oBr                              20  0x00000014 (const dword)  (not used)
LED1_oLr                              24  0x00000018 (const dword)  (not used)
LED1_sh                               26  0x0000001a (const dword)  (not used)
LED1_w                                 4  0x00000004 (const dword)  (not used)
LED1_x                                 0  0x00000000 (const dword)  (not used)
LED1_y                                 2  0x00000002 (const dword)  (not used)
LEDDIGIT_F_DP_COMMA                  N/A         N/A (macro)   0x0400   (not used)
LEDDIGIT_F_DP_ON                     N/A         N/A (macro)   0x0200   (not used)
LEDDIGIT_F_SET_SEGMENTS              N/A         N/A (macro)   0x1000   (not used)
LEDDIGIT_F_SHOW_DP                   N/A         N/A (macro)   0x0800   (not used)
LEDDIGITS_decimals                    10  0x0000000a (const dword)  (not used)
LEDDIGITS_digits                       8  0x00000008 (const dword)  (not used)
LEDDIGITS_digsize                     14  0x0000000e (const dword)  (not used)
LEDDIGITS_F_DP_COMMA                 N/A         N/A (macro)   0x0040   (not used)
LEDDIGITS_F_DP_DOT                   N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_FIXED                    N/A         N/A (macro)   0x0002   (not used)
LEDDIGITS_F_FLOAT                    N/A         N/A (macro)   0x0008   (not used)
LEDDIGITS_F_FLOATFORMATS             N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_GENERAL                  N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_INT16                    N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_INT32                    N/A         N/A (macro)   0x0004   (not used)
LEDDIGITS_F_LEADING0                 N/A         N/A (macro)   0x0020   (not used)
LEDDIGITS_F_LEADINGb                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_SCIENTIFIC               N/A         N/A (macro)   0x0001   (not used)
LEDDIGITS_F_SIGNED                   N/A         N/A (macro)   0x0010   (not used)
LEDDIGITS_F_TYPES                    N/A         N/A (macro)   0x000c   (not used)
LEDDIGITS_F_UNSIGNED                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_flags                       20  0x00000014 (const dword)  (not used)
LEDDIGITS_gap                         12  0x0000000c (const dword)  (not used)
LEDDIGITS_h                            6  0x00000006 (const dword)  (not used)
LEDDIGITS_offcolour                   18  0x00000012 (const dword)  (not used)
LEDDIGITS_oncolour                    16  0x00000010 (const dword)  (not used)
LEDDIGITS_w                            4  0x00000004 (const dword)  (not used)
LEDDIGITS_x                            0  0x00000000 (const dword)  (not used)
LEDDIGITS_y                            2  0x00000002 (const dword)  (not used)
ledDigitsDisplay                    4263  0x000010a7 (User func) args[3] r=0  (usage 6)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                               -47  0xffffffd1 (PmmC func) args[1] r=1  (not used)
LOCAL                                N/A         N/A (macro) //   (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
M_PA0                                  1  0x00000001 (const dword)  (not used)
M_PA1                                  2  0x00000002 (const dword)  (not used)
M_PA10                              1024  0x00000400 (const dword)  (not used)
M_PA11                              2048  0x00000800 (const dword)  (not used)
M_PA12                              4096  0x00001000 (const dword)  (not used)
M_PA13                              8192  0x00002000 (const dword)  (not used)
M_PA14                             16384  0x00004000 (const dword)  (not used)
M_PA15                             32768  0x00008000 (const dword)  (not used)
M_PA2                                  4  0x00000004 (const dword)  (not used)
M_PA3                                  8  0x00000008 (const dword)  (not used)
M_PA4                                 16  0x00000010 (const dword)  (not used)
M_PA5                                 32  0x00000020 (const dword)  (not used)
M_PA6                                 64  0x00000040 (const dword)  (not used)
M_PA7                                128  0x00000080 (const dword)  (not used)
M_PA8                                256  0x00000100 (const dword)  (not used)
M_PA9                                512  0x00000200 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                 905  0x00000389 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -55  0xffffffc9 (PmmC func) args[2] r=1  (not used)
MaxIntObjects                         27  0x0000001b (const dword)  (usage 3)
MaxTotObjects                         67  0x00000043 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
media_Flush                         -218  0xffffff26 (PmmC func) args[0] r=1  (not used)
media_Image                         -217  0xffffff27 (PmmC func) args[2] r=0  (not used)
media_Init                          -219  0xffffff25 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -213  0xffffff2b (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -214  0xffffff2a (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                       93  0x0000005d (const dword)  (not used)
MEDIA_SECTOR_LO                       92  0x0000005c (const dword)  (not used)
media_SetAdd                        -209  0xffffff2f (PmmC func) args[2] r=0  (not used)
media_SetSector                     -210  0xffffff2e (PmmC func) args[2] r=0  (not used)
media_Video                         -207  0xffffff31 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -208  0xffffff30 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
media_WrSector                      -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -413  0xfffffe63 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -414  0xfffffe62 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -415  0xfffffe61 (PmmC func) args[1] r=1  (not used)
mem_ArrayOp1                         -67  0xffffffbd (PmmC func) args[4] r=0  (not used)
mem_ArrayOp2                         -68  0xffffffbc (PmmC func) args[5] r=0  (not used)
mem_Compare                         -421  0xfffffe5b (PmmC func) args[3] r=1  (not used)
mem_Copy                            -420  0xfffffe5c (PmmC func) args[3] r=1  (not used)
mem_Free                            -417  0xfffffe5f (PmmC func) args[1] r=1  (not used)
mem_Heap                            -418  0xfffffe5e (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -416  0xfffffe60 (PmmC func) args[2] r=1  (not used)
mem_Set                             -419  0xfffffe5d (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -54  0xffffffca (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                5426  0x00001532 (User func) args[0] r=0  (usage 12)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NEEDLE_bgcol                          12  0x0000000c (const dword)  (not used)
NEEDLE_ccol                           36  0x00000024 (const dword)  (not used)
NEEDLE_colour                         32  0x00000020 (const dword)  (not used)
NEEDLE_crad                           34  0x00000022 (const dword)  (not used)
NEEDLE_cxx                             8  0x00000008 (const dword)  (not used)
NEEDLE_cyx                            10  0x0000000a (const dword)  (not used)
NEEDLE_extra                          30  0x0000001e (const dword)  (not used)
NEEDLE_F_DOUBLETRIANGLE                4  0x00000004 (const dword)  (not used)
NEEDLE_F_LINE                          0  0x00000000 (const dword)  (not used)
NEEDLE_F_POINTRECTANGLE                2  0x00000002 (const dword)  (not used)
NEEDLE_F_RECTANGLE                     1  0x00000001 (const dword)  (not used)
NEEDLE_F_ROUNDEDRECTANGLE              5  0x00000005 (const dword)  (not used)
NEEDLE_F_TRIANGLE                      3  0x00000003 (const dword)  (not used)
NEEDLE_h                               6  0x00000006 (const dword)  (not used)
NEEDLE_icol                           40  0x00000028 (const dword)  (not used)
NEEDLE_irad                           38  0x00000026 (const dword)  (not used)
NEEDLE_len                            22  0x00000016 (const dword)  (not used)
NEEDLE_maxa                           16  0x00000010 (const dword)  (not used)
NEEDLE_maxv                           20  0x00000014 (const dword)  (not used)
NEEDLE_mina                           14  0x0000000e (const dword)  (not used)
NEEDLE_minv                           18  0x00000012 (const dword)  (not used)
NEEDLE_offs                           26  0x0000001a (const dword)  (not used)
NEEDLE_rad                            28  0x0000001c (const dword)  (not used)
NEEDLE_style                          24  0x00000018 (const dword)  (not used)
NEEDLE_w                               4  0x00000004 (const dword)  (not used)
NEEDLE_x                               0  0x00000000 (const dword)  (not used)
NEEDLE_y                               2  0x00000002 (const dword)  (not used)
nInputs                               11  0x0000000b (const dword)  (usage 3)
nKeyboards                             1  0x00000001 (const dword)  (usage 9)
nObjects                              40  0x00000028 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
NP_565                                 0  0x00000000 (const dword)  (not used)
NP_RGB                                 1  0x00000001 (const dword)  (not used)
NP_Write                            -535  0xfffffde9 (PmmC func) args[7] r=1  (not used)
NP_XRGB                                2  0x00000002 (const dword)  (not used)
NybleSwap                            -50  0xffffffce (PmmC func) args[1] r=1  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                          678  0x000002a6oDipSwitchs                          678  0x000002a6 (mem) word[1] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 177)
OFF                                    0  0x00000000 (const dword)  (not used)
oForms                               702  0x000002beoForms                               702  0x000002be (mem) word[8] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (usage 9)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (usage 3)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (usage 3)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (usage 3)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (usage 3)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 6)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 12)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 21)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 33)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 9)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 6)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 9)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 18)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 9)
Ofs_kb_Buttons                        10  0x0000000a (const ??? 0)  (usage 12)
Ofs_kb_Caps                            4  0x00000004 (const ??? 0)  (usage 12)
Ofs_kb_Ctrl1                           7  0x00000007 (const ??? 0)  (usage 12)
Ofs_kb_Ctrl2                           8  0x00000008 (const ??? 0)  (usage 12)
Ofs_kb_Down                            0  0x00000000 (const ??? 0)  (usage 9)
Ofs_kb_Ign                             3  0x00000003 (const ??? 0)  (usage 18)
Ofs_kb_Lock                            9  0x00000009 (const ??? 0)  (usage 6)
Ofs_kb_Mvt                             1  0x00000001 (const ??? 0)  (usage 18)
Ofs_kb_Shift1                          5  0x00000005 (const ??? 0)  (usage 6)
Ofs_kb_Shift2                          6  0x00000006 (const ??? 0)  (usage 6)
Ofs_kb_ShiftCaps                      11  0x0000000b (const ??? 0)  (usage 3)
Ofs_kb_State                           2  0x00000002 (const ??? 0)  (usage 63)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (not used)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (not used)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (not used)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (not used)
Ofs_String_Form                       24  0x00000018 (const dword)  (not used)
Ofs_String_GciFSFontIdx               26  0x0000001a (const dword)  (not used)
Ofs_String_Size                        4  0x00000004 (const dword)  (not used)
Ofs_String_StartH                      0  0x00000000 (const dword)  (not used)
Ofs_String_StartL                      2  0x00000002 (const dword)  (not used)
Ofs_String_Transparent                20  0x00000014 (const dword)  (not used)
Ofs_String_x1                          6  0x00000006 (const dword)  (not used)
Ofs_String_x2                         10  0x0000000a (const dword)  (not used)
Ofs_String_y1                          8  0x00000008 (const dword)  (not used)
Ofs_String_y2                         12  0x0000000c (const dword)  (not used)
oImages                              718  0x000002ceoImages                              718  0x000002ce (mem) word[2] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
oiSwitchs                            760  0x000002f8oiSwitchs                            760  0x000002f8 (mem) word[2] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
oiviSwitch                           217  0x000000d9oiviSwitch                           217  0x000000d9 (mem) word[1] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
oKeyboard0                             2  0x00000002 (mem) word[12] (global)  (usage 3)
oKeyboards                           722  0x000002d2oKeyboards                           722  0x000002d2 (mem) word[2] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 30)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 256  0x00000100 (mem) word (global)  (usage 42)
oLedDigitsn                          782  0x0000030eoLedDigitsn                          782  0x0000030e (mem) word[10] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 6)
oLeddigitss                          726  0x000002d6oLeddigitss                          726  0x000002d6 (mem) word[3] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 9)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (not used)
oObjects                             118  0x00000076 (mem) word[68] (global)  (usage 222)
OP1_ADD                                5  0x00000005 (const dword)  (not used)
OP1_AND                                2  0x00000002 (const dword)  (not used)
OP1_BLACKEN                           16  0x00000010 (const dword)  (not used)
OP1_DARKEN                            18  0x00000012 (const dword)  (not used)
OP1_DIV                                8  0x00000008 (const dword)  (not used)
OP1_GRAY                              14  0x0000000e (const dword)  (not used)
OP1_IOR                                3  0x00000003 (const dword)  (not used)
OP1_LIGHTEN                           17  0x00000011 (const dword)  (not used)
OP1_MUL                                7  0x00000007 (const dword)  (not used)
OP1_NOP                                0  0x00000000 (const dword)  (not used)
OP1_REV                                9  0x00000009 (const dword)  (not used)
OP1_ROL                               12  0x0000000c (const dword)  (not used)
OP1_ROR                               13  0x0000000d (const dword)  (not used)
OP1_SET                                1  0x00000001 (const dword)  (not used)
OP1_SHL                               10  0x0000000a (const dword)  (not used)
OP1_SHR                               11  0x0000000b (const dword)  (not used)
OP1_SUB                                6  0x00000006 (const dword)  (not used)
OP1_WHITEN                            15  0x0000000f (const dword)  (not used)
OP1_XOR                                4  0x00000004 (const dword)  (not used)
OP2_ADD                                4  0x00000004 (const dword)  (not used)
OP2_AND                                1  0x00000001 (const dword)  (not used)
OP2_BLEND                              9  0x00000009 (const dword)  (not used)
OP2_COPY                               8  0x00000008 (const dword)  (not used)
OP2_DIV                                7  0x00000007 (const dword)  (not used)
OP2_IOR                                2  0x00000002 (const dword)  (not used)
OP2_MUL                                6  0x00000006 (const dword)  (not used)
OP2_SUB                                5  0x00000005 (const dword)  (not used)
OP2_XOR                                3  0x00000003 (const dword)  (not used)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oStaticTexts                         736  0x000002e0oStaticTexts                         736  0x000002e0 (mem) word[12] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 3)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 3)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (not used)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (not used)
OT_REPORT                            100  0x00000064 (const dword)  (usage 3)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 3)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
oUserleds                            732  0x000002dcoUserleds                            732  0x000002dc (mem) word[2] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OutputCS                             514  0x00000202 (mem) word (global)  (usage 9)
OVF                                  -63  0xffffffc1 (PmmC func) args[0] r=1  (usage 3)
OW_Read                             -523  0xfffffdf5 (PmmC func) args[1] r=1  (not used)
OW_Read9                            -524  0xfffffdf4 (PmmC func) args[1] r=1  (not used)
OW_Reset                            -522  0xfffffdf6 (PmmC func) args[1] r=1  (not used)
OW_Write                            -525  0xfffffdf3 (PmmC func) args[2] r=0  (not used)
oWinButtons                          680  0x000002a8oWinButtons                          680  0x000002a8 (mem) word[11] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 9)
PA0                                    1  0x00000001 (const dword)  (not used)
PA1                                    2  0x00000002 (const dword)  (not used)
PA10                                  11  0x0000000b (const dword)  (not used)
PA11                                  12  0x0000000c (const dword)  (not used)
PA12                                  13  0x0000000d (const dword)  (not used)
PA13                                  14  0x0000000e (const dword)  (not used)
PA14                                  15  0x0000000f (const dword)  (not used)
PA15                                  16  0x00000010 (const dword)  (not used)
PA2                                    3  0x00000003 (const dword)  (not used)
PA3                                    4  0x00000004 (const dword)  (not used)
PA4                                    5  0x00000005 (const dword)  (not used)
PA5                                    6  0x00000006 (const dword)  (not used)
PA6                                    7  0x00000007 (const dword)  (not used)
PA7                                    8  0x00000008 (const dword)  (not used)
PA8                                    9  0x00000009 (const dword)  (not used)
PA9                                   10  0x0000000a (const dword)  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL2_FILLED                      32768  0x00008000 (const dword)  (not used)
PANEL_FRAME                            3  0x00000003 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -34  0xffffffde (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PIN_AN                                 5  0x00000005 (const dword)  (not used)
PIN_ANAVG                              6  0x00000006 (const dword)  (not used)
pin_Counter                         -514  0xfffffdfe (PmmC func) args[3] r=1  (not used)
PIN_COUNTER_PA4                      123  0x0000007b (const dword)  (not used)
PIN_COUNTER_PA5                      124  0x0000007c (const dword)  (not used)
PIN_COUNTER_PA6                      125  0x0000007d (const dword)  (not used)
PIN_COUNTER_PA7                      126  0x0000007e (const dword)  (not used)
PIN_COUNTER_PA8                      127  0x0000007f (const dword)  (not used)
PIN_COUNTER_PA9                      128  0x00000080 (const dword)  (not used)
PIN_EVENT_PA4                        129  0x00000081 (const dword)  (not used)
PIN_EVENT_PA5                        130  0x00000082 (const dword)  (not used)
PIN_EVENT_PA6                        131  0x00000083 (const dword)  (not used)
PIN_EVENT_PA7                        132  0x00000084 (const dword)  (not used)
PIN_EVENT_PA8                        133  0x00000085 (const dword)  (not used)
PIN_EVENT_PA9                        134  0x00000086 (const dword)  (not used)
pin_HI                              -113  0xffffff8f (PmmC func) args[1] r=1  (not used)
PIN_INP                                0  0x00000000 (const dword)  (not used)
PIN_INP_HI                             1  0x00000001 (const dword)  (not used)
PIN_INP_LO                             2  0x00000002 (const dword)  (not used)
pin_LO                              -114  0xffffff8e (PmmC func) args[1] r=1  (not used)
PIN_OUT                                3  0x00000003 (const dword)  (not used)
PIN_OUT_OD                             4  0x00000004 (const dword)  (not used)
pin_Pulseout                        -512  0xfffffe00 (PmmC func) args[2] r=1  (not used)
pin_PulseoutB                       -513  0xfffffdff (PmmC func) args[2] r=1  (not used)
pin_PulseoutCount                   -519  0xfffffdf9 (PmmC func) args[4] r=1  (not used)
pin_Read                            -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
pin_Set                             -112  0xffffff90 (PmmC func) args[2] r=1  (not used)
pin_Val                             -115  0xffffff8d (PmmC func) args[2] r=0  (not used)
PINK                               65049  0x0000fe19 (const dword)  (usage 3)
pInputIndex                          270  0x0000010e (mem) word (global)  (usage 18)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -35  0xffffffdd (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PTN_BDIAGONAL                      65518  0x0000ffee (const ??? 0)  (not used)
PTN_BRICKS                         65521  0x0000fff1 (const ??? 0)  (not used)
PTN_BS_HORIZONTAL                  65510  0x0000ffe6 (const ??? 0)  (not used)
PTN_BS_VERTICAL                    65509  0x0000ffe5 (const ??? 0)  (not used)
PTN_BSHORIZONTAL                   65516  0x0000ffec (const ??? 0)  (not used)
PTN_BSVERTICAL                     65515  0x0000ffeb (const ??? 0)  (not used)
PTN_CARGONET                       65522  0x0000fff2 (const ??? 0)  (not used)
PTN_CIRCUITS                       65523  0x0000fff3 (const ??? 0)  (not used)
PTN_COBBLESTONES                   65524  0x0000fff4 (const ??? 0)  (not used)
PTN_COURSE_B_DIAGONAL              65512  0x0000ffe8 (const ??? 0)  (not used)
PTN_COURSE_CROSS                   65513  0x0000ffe9 (const ??? 0)  (not used)
PTN_COURSE_DIAGONALCROSS           65514  0x0000ffea (const ??? 0)  (not used)
PTN_COURSE_DOTS                    65508  0x0000ffe4 (const ??? 0)  (not used)
PTN_COURSE_F_DIAGONAL              65511  0x0000ffe7 (const ??? 0)  (not used)
PTN_CROSSES                        65535  0x0000ffff (const ??? 0)  (not used)
PTN_DAISIES                        65525  0x0000fff5 (const ??? 0)  (not used)
PTN_DIZZY                          65526  0x0000fff6 (const ??? 0)  (not used)
PTN_EMPTY                          65504  0x0000ffe0 (const dword)  (not used)
PTN_FDIAGONAL                      65517  0x0000ffed (const ??? 0)  (not used)
PTN_FIELDEFFECT                    65527  0x0000fff7 (const ??? 0)  (not used)
PTN_FINE_CROSS                     65519  0x0000ffef (const ??? 0)  (not used)
PTN_FINE_DIAGONAL_CROSS            65520  0x0000fff0 (const ??? 0)  (not used)
PTN_FINE_DOTS                      65506  0x0000ffe2 (const ??? 0)  (not used)
PTN_KEY                            65528  0x0000fff8 (const ??? 0)  (not used)
PTN_MEDIUM_DOTS                    65507  0x0000ffe3 (const ??? 0)  (not used)
PTN_ROUNDER                        65529  0x0000fff9 (const ??? 0)  (not used)
PTN_SCALES                         65530  0x0000fffa (const ??? 0)  (not used)
PTN_SOLID                          65505  0x0000ffe1 (const ??? 0)  (not used)
PTN_STONE                          65531  0x0000fffb (const ??? 0)  (not used)
PTN_THATCHES                       65532  0x0000fffc (const ??? 0)  (not used)
PTN_TILE                           65533  0x0000fffd (const ??? 0)  (not used)
PTN_WAFFLESREVENGE                 65534  0x0000fffe (const ??? 0)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putchXY                               -3  0xfffffffd (PmmC func) args[3] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (usage 3)
putnumXY                             -51  0xffffffcd (PmmC func) args[4] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
putstrCentred                         -5  0xfffffffb (PmmC func) args[3] r=0  (not used)
putstrXY                              -4  0xfffffffc (PmmC func) args[3] r=0  (not used)
PWM_10KHZ                              6  0x00000006 (const dword)  (not used)
PWM_15KHZ                              7  0x00000007 (const dword)  (not used)
PWM_1KHZ                              14  0x0000000e (const dword)  (not used)
PWM_200HZ                             12  0x0000000c (const dword)  (not used)
PWM_20KHZ                              8  0x00000008 (const dword)  (not used)
PWM_25KHZ                              9  0x00000009 (const dword)  (not used)
PWM_30KHZ                             10  0x0000000a (const dword)  (not used)
PWM_35KHZ                             11  0x0000000b (const dword)  (not used)
PWM_500HZ                             13  0x0000000d (const dword)  (not used)
PWM_5KHZ                               5  0x00000005 (const dword)  (not used)
PWM_625HZ                              4  0x00000004 (const dword)  (not used)
PWM_BINARY                             3  0x00000003 (const dword)  (not used)
pwm_Init                            -521  0xfffffdf7 (PmmC func) args[3] r=1  (not used)
PWM_OFF                                0  0x00000000 (const dword)  (not used)
PWM_PLAIN                              1  0x00000001 (const dword)  (not used)
PWM_SERVO                              2  0x00000002 (const dword)  (not used)
QEN1_COUNTER_HI                      136  0x00000088 (const dword)  (not used)
QEN1_COUNTER_LO                      135  0x00000087 (const dword)  (not used)
QEN1_DELTA                           137  0x00000089 (const dword)  (not used)
QEN2_COUNTER_HI                      139  0x0000008b (const dword)  (not used)
QEN2_COUNTER_LO                      138  0x0000008a (const dword)  (not used)
QEN2_DELTA                           140  0x0000008c (const dword)  (not used)
Qencoder1                           -515  0xfffffdfd (PmmC func) args[3] r=1  (not used)
Qencoder1Reset                      -517  0xfffffdfb (PmmC func) args[0] r=0  (not used)
Qencoder2                           -516  0xfffffdfc (PmmC func) args[3] r=1  (not used)
Qencoder2Reset                      -518  0xfffffdfa (PmmC func) args[0] r=0  (not used)
RAND                                 -59  0xffffffc5 (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
RANDVAL                              -60  0xffffffc4 (PmmC func) args[2] r=1  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
READ_PAGE                             34  0x00000022 (const dword)  (not used)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          5110  0x000013f6 (User func) args[2] r=0  (usage 3)
RED                                63488  0x0000f800 (const dword)  (usage 3)
refreshstate                        6300  0x0000189c (User func) args[2] r=0  (usage 9)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 6)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                    780  0x0000030crKeyboardRoutines                    780  0x0000030c (mem) word[1] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 1)
rKeyboardRoutines                 UNRESOLVED  (usage 2)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RULERGAUGE_F_ORIENT_VERT               2  0x00000002 (const dword)  (not used)
RULERGAUGE_F_TICKS_BOTTOM              0  0x00000000 (const dword)  (not used)
RULERGAUGE_F_TICKS_TOP                 1  0x00000001 (const dword)  (not used)
RULERGAUGE_HC                         24  0x00000018 (const dword)  (not used)
RULERGAUGE_height                      6  0x00000006 (const dword)  (not used)
RULERGAUGE_IC                         30  0x0000001e (const dword)  (not used)
RULERGAUGE_LC                         22  0x00000016 (const dword)  (not used)
RULERGAUGE_majorTickSize              16  0x00000010 (const dword)  (not used)
RULERGAUGE_MC                         26  0x0000001a (const dword)  (not used)
RULERGAUGE_medium                     18  0x00000012 (const dword)  (not used)
RULERGAUGE_minorTicks                 12  0x0000000c (const dword)  (not used)
RULERGAUGE_minorTickSize              14  0x0000000e (const dword)  (not used)
RULERGAUGE_options                    32  0x00000020 (const dword)  (not used)
RULERGAUGE_range                       8  0x00000008 (const dword)  (not used)
RULERGAUGE_TC                         28  0x0000001c (const dword)  (not used)
RULERGAUGE_threshold                  20  0x00000014 (const dword)  (not used)
RULERGAUGE_ticks                      10  0x0000000a (const dword)  (not used)
RULERGAUGE_width                       4  0x00000004 (const dword)  (not used)
RULERGAUGE_XP                          0  0x00000000 (const dword)  (not used)
RULERGAUGE_YP                          2  0x00000002 (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SAVE_TO_DISK                           7  0x00000007 (const dword)  (not used)
SCALE_BC                              20  0x00000014 (const dword)  (not used)
SCALE_BR                             N/A         N/A (macro)    0x0002   (not used)
SCALE_CenterGap                       26  0x0000001a (const dword)  (not used)
SCALE_CENTRE                         N/A         N/A (macro)    0x0003   (not used)
SCALE_END_ALIGN                      N/A         N/A (macro)    0x0020   (not used)
SCALE_FONT                            24  0x00000018 (const dword)  (not used)
SCALE_HIDE_ZERO                      N/A         N/A (macro)    0x0000   (not used)
SCALE_HORZ                           N/A         N/A (macro)    0x0000   (not used)
SCALE_length                           4  0x00000004 (const dword)  (not used)
SCALE_max                              8  0x00000008 (const dword)  (not used)
SCALE_min                              6  0x00000006 (const dword)  (not used)
SCALE_NO_END_ALIGN                   N/A         N/A (macro)    0x0000   (not used)
SCALE_NONE                           N/A         N/A (macro)    0x0000   (not used)
SCALE_SHOW_ZERO                      N/A         N/A (macro)    0x0040   (not used)
SCALE_TC                              18  0x00000012 (const dword)  (not used)
SCALE_ticklength                      12  0x0000000c (const dword)  (not used)
SCALE_ticklengthMinor                 16  0x00000010 (const dword)  (not used)
SCALE_ticks                           10  0x0000000a (const dword)  (not used)
SCALE_TICKS_BOTH                     N/A         N/A (macro)    0x000c   (not used)
SCALE_TICKS_BR                       N/A         N/A (macro)    0x0008   (not used)
SCALE_TICKS_NONE                     N/A         N/A (macro)    0x0000   (not used)
SCALE_TICKS_TL                       N/A         N/A (macro)    0x0004   (not used)
SCALE_ticksMinor                      14  0x0000000e (const dword)  (not used)
SCALE_TL                             N/A         N/A (macro)    0x0001   (not used)
SCALE_type                            28  0x0000001c (const dword)  (not used)
SCALE_VERT                           N/A         N/A (macro)    0x0010   (not used)
SCALE_XC                              22  0x00000016 (const dword)  (not used)
SCALE_XP                               0  0x00000000 (const dword)  (not used)
SCALE_YP                               2  0x00000002 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -61  0xffffffc3 (PmmC func) args[1] r=0  (not used)
SendReport                          5359  0x000014ef (User func) args[4] r=0  (usage 9)
serin                               -236  0xffffff14 (PmmC func) args[0] r=1  (usage 3)
serin1                              -237  0xffffff13 (PmmC func) args[0] r=1  (not used)
serin2                              -238  0xffffff12 (PmmC func) args[0] r=1  (not used)
serin3                              -239  0xffffff11 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                              -240  0xffffff10 (PmmC func) args[1] r=0  (usage 15)
serout1                             -241  0xffffff0f (PmmC func) args[1] r=0  (not used)
serout2                             -242  0xffffff0e (PmmC func) args[1] r=0  (not used)
serout3                             -243  0xffffff0d (PmmC func) args[1] r=0  (not used)
seroutCS                            5442  0x00001542 (User func) args[1] r=0  (usage 15)
seroutOcs                           5409  0x00001521 (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                             -224  0xffffff20 (PmmC func) args[1] r=0  (not used)
setkeystate                         5754  0x0000167a (User func) args[2] r=0  (usage 33)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -57  0xffffffc7 (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER5_base_color                    14  0x0000000e (const dword)  (not used)
SLIDER5_F_ORIENT_VERT                N/A         N/A (macro)     0x0001    /* Switch orientation (0 - horizontal, 1 - vertical) */   (not used)
SLIDER5_F_PROGRESSBAR                N/A         N/A (macro)     0x0008    /* Progress Bar mode */   (not used)
SLIDER5_F_TICKS                      N/A         N/A (macro)     0x0002    /* Enable Marker Ticks*/   (not used)
SLIDER5_F_VALUE_IND                  N/A         N/A (macro)     0x0004    /* Enable slider value indicator */   (not used)
SLIDER5_font_c                        38  0x00000026 (const dword)  (not used)
SLIDER5_font_s                        36  0x00000024 (const dword)  (not used)
SLIDER5_knob_f_c_1                    46  0x0000002e (const dword)  (not used)
SLIDER5_knob_f_c_2                    48  0x00000030 (const dword)  (not used)
SLIDER5_knob_f_g                      50  0x00000032 (const dword)  (not used)
SLIDER5_knob_o_c_1                    40  0x00000028 (const dword)  (not used)
SLIDER5_knob_o_c_2                    42  0x0000002a (const dword)  (not used)
SLIDER5_knob_o_g                      44  0x0000002c (const dword)  (not used)
SLIDER5_len                            4  0x00000004 (const dword)  (not used)
SLIDER5_max_val                       12  0x0000000c (const dword)  (not used)
SLIDER5_min_val                       10  0x0000000a (const dword)  (not used)
SLIDER5_num_ticks_L_1                 24  0x00000018 (const dword)  (not used)
SLIDER5_num_ticks_L_2                 26  0x0000001a (const dword)  (not used)
SLIDER5_options                        8  0x00000008 (const dword)  (not used)
SLIDER5_thk                            6  0x00000006 (const dword)  (not used)
SLIDER5_tick_maj_c                    30  0x0000001e (const dword)  (not used)
SLIDER5_tick_maj_l                    28  0x0000001c (const dword)  (not used)
SLIDER5_tick_min_c                    34  0x00000022 (const dword)  (not used)
SLIDER5_tick_min_l                    32  0x00000020 (const dword)  (not used)
SLIDER5_total_tick_B_R                22  0x00000016 (const dword)  (not used)
SLIDER5_total_tick_T_L                20  0x00000014 (const dword)  (not used)
SLIDER5_track_color                   18  0x00000012 (const dword)  (not used)
SLIDER5_track_empty                   16  0x00000010 (const dword)  (not used)
SLIDER5_x_pos                          0  0x00000000 (const dword)  (not used)
SLIDER5_y_pos                          2  0x00000002 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -461  0xfffffe33 (PmmC func) args[1] r=0  (not used)
snd_Continue                        -464  0xfffffe30 (PmmC func) args[0] r=0  (not used)
snd_Freq                            -466  0xfffffe2e (PmmC func) args[2] r=1  (not used)
snd_Pause                           -463  0xfffffe31 (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -460  0xfffffe34 (PmmC func) args[1] r=1  (not used)
snd_Playing                         -465  0xfffffe2f (PmmC func) args[0] r=1  (not used)
snd_Stop                            -462  0xfffffe32 (PmmC func) args[0] r=0  (not used)
snd_Volume                          -459  0xfffffe35 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SPI0                                   0  0x00000000 (const dword)  (not used)
SPI1                                   1  0x00000001 (const dword)  (not used)
SPI16_MODE_0                           8  0x00000008 (const dword)  (not used)
SPI16_MODE_1                           9  0x00000009 (const dword)  (not used)
SPI16_MODE_2                          10  0x0000000a (const dword)  (not used)
SPI16_MODE_3                          11  0x0000000b (const dword)  (not used)
SPI16_MODE_4                          12  0x0000000c (const dword)  (not used)
SPI16_MODE_5                          13  0x0000000d (const dword)  (not used)
SPI16_MODE_6                          14  0x0000000e (const dword)  (not used)
SPI16_MODE_7                          15  0x0000000f (const dword)  (not used)
SPI1_Init                           -349  0xfffffea3 (PmmC func) args[3] r=1  (not used)
SPI1_Read                           -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
spi1_ReadBlock                      -333  0xfffffeb3 (PmmC func) args[2] r=0  (not used)
SPI1_SCK_pin                        -346  0xfffffea6 (PmmC func) args[1] r=1  (not used)
SPI1_SDI_pin                        -343  0xfffffea9 (PmmC func) args[1] r=1  (not used)
SPI1_SDO_pin                        -340  0xfffffeac (PmmC func) args[1] r=1  (not used)
SPI1_Write                          -355  0xfffffe9d (PmmC func) args[1] r=1  (not used)
spi1_WriteBlock                     -359  0xfffffe99 (PmmC func) args[2] r=0  (not used)
SPI2                                   2  0x00000002 (const dword)  (not used)
SPI2_Init                           -350  0xfffffea2 (PmmC func) args[3] r=1  (not used)
SPI2_Read                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
spi2_ReadBlock                      -334  0xfffffeb2 (PmmC func) args[2] r=0  (not used)
SPI2_SCK_pin                        -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
SPI2_SDI_pin                        -344  0xfffffea8 (PmmC func) args[1] r=1  (not used)
SPI2_SDO_pin                        -341  0xfffffeab (PmmC func) args[1] r=1  (not used)
SPI2_Write                          -356  0xfffffe9c (PmmC func) args[1] r=1  (not used)
spi2_WriteBlock                     -360  0xfffffe98 (PmmC func) args[2] r=0  (not used)
SPI3                                   3  0x00000003 (const dword)  (not used)
SPI3_Init                           -351  0xfffffea1 (PmmC func) args[3] r=1  (not used)
SPI3_Read                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
spi3_ReadBlock                      -335  0xfffffeb1 (PmmC func) args[2] r=0  (not used)
SPI3_SCK_pin                        -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
SPI3_SDI_pin                        -345  0xfffffea7 (PmmC func) args[1] r=1  (not used)
SPI3_SDO_pin                        -342  0xfffffeaa (PmmC func) args[1] r=1  (not used)
SPI3_Write                          -357  0xfffffe9b (PmmC func) args[1] r=1  (not used)
spi3_WriteBlock                     -361  0xfffffe97 (PmmC func) args[2] r=0  (not used)
SPI8_MODE_0                            0  0x00000000 (const dword)  (not used)
SPI8_MODE_1                            1  0x00000001 (const dword)  (not used)
SPI8_MODE_2                            2  0x00000002 (const dword)  (not used)
SPI8_MODE_3                            3  0x00000003 (const dword)  (not used)
SPI8_MODE_4                            4  0x00000004 (const dword)  (not used)
SPI8_MODE_5                            5  0x00000005 (const dword)  (not used)
SPI8_MODE_6                            6  0x00000006 (const dword)  (not used)
SPI8_MODE_7                            7  0x00000007 (const dword)  (not used)
SPI_ADDRESS_MODE4                  32768  0x00008000 (const dword)  (not used)
spi_Disable                         -339  0xfffffead (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -336  0xfffffeb0 (PmmC func) args[2] r=0  (not used)
SPI_INIT                               3  0x00000003 (const dword)  (not used)
SPI_IS_FLASH                       32768  0x00008000 (const dword)  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -337  0xfffffeaf (PmmC func) args[0] r=1  (not used)
spi_ReadBlock                       -332  0xfffffeb4 (PmmC func) args[2] r=0  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -338  0xfffffeae (PmmC func) args[1] r=0  (not used)
spi_WriteBlock                      -358  0xfffffe9a (PmmC func) args[2] r=0  (not used)
spiflash_Block32Erase               -622  0xfffffd92 (PmmC func) args[2] r=1  (not used)
spiflash_BlockErase                 -541  0xfffffde3 (PmmC func) args[3] r=0  (not used)
spiflash_BulkErase                  -540  0xfffffde4 (PmmC func) args[2] r=0  (not used)
spiflash_Exec                       -554  0xfffffdd6 (PmmC func) args[3] r=1  (not used)
spiflash_GetC                       -547  0xfffffddd (PmmC func) args[2] r=1  (not used)
spiflash_GetS                       -551  0xfffffdd9 (PmmC func) args[4] r=1  (not used)
spiflash_GetW                       -549  0xfffffddb (PmmC func) args[2] r=1  (not used)
SPIFLASH_HOLDCS                    32768  0x00008000 (const dword)  (not used)
spiflash_ID                         -539  0xfffffde5 (PmmC func) args[2] r=1  (not used)
spiflash_Image                      -545  0xfffffddf (PmmC func) args[4] r=1  (not used)
spiflash_LoadFunction               -552  0xfffffdd8 (PmmC func) args[2] r=1  (not used)
spiflash_LoadGCFImageControl        -632  0xfffffd88 (PmmC func) args[2] r=1  (not used)
spiflash_LoadImageControl           -555  0xfffffdd5 (PmmC func) args[2] r=1  (not used)
spiflash_PlayWAV                    -556  0xfffffdd4 (PmmC func) args[2] r=1  (not used)
spiflash_PutC                       -546  0xfffffdde (PmmC func) args[3] r=0  (not used)
spiflash_PutS                       -550  0xfffffdda (PmmC func) args[3] r=1  (not used)
spiflash_PutW                       -548  0xfffffddc (PmmC func) args[3] r=0  (not used)
spiflash_Read                       -543  0xfffffde1 (PmmC func) args[4] r=1  (not used)
spiflash_ReadByte                   -629  0xfffffd8b (PmmC func) args[3] r=1  (not used)
spiflash_Run                        -553  0xfffffdd7 (PmmC func) args[3] r=1  (not used)
spiflash_Sector4Erase               -623  0xfffffd91 (PmmC func) args[2] r=1  (not used)
spiflash_SetAdd                     -542  0xfffffde2 (PmmC func) args[3] r=0  (not used)
spiflash_SetMode                    -631  0xfffffd89 (PmmC func) args[2] r=0  (not used)
spiflash_SIG                        -538  0xfffffde6 (PmmC func) args[2] r=1  (not used)
spiflash_Write                      -544  0xfffffde0 (PmmC func) args[4] r=1  (not used)
spiflash_WriteByte                  -630  0xfffffd8a (PmmC func) args[3] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -62  0xffffffc2 (PmmC func) args[1] r=1  (not used)
SSD1963_ENTER_IDLE_MODE               57  0x00000039 (const dword)  (not used)
SSD1963_ENTER_INVERT_MODE             33  0x00000021 (const dword)  (not used)
SSD1963_ENTER_NORMAL_MODE             19  0x00000013 (const dword)  (not used)
SSD1963_ENTER_PARTIAL_MODE            18  0x00000012 (const dword)  (not used)
SSD1963_ENTER_SLEEP_MODE              16  0x00000010 (const dword)  (not used)
SSD1963_EXIT_IDLE_MODE                56  0x00000038 (const dword)  (not used)
SSD1963_EXIT_INVERT_MODE              32  0x00000020 (const dword)  (not used)
SSD1963_EXIT_SLEEP_MODE               17  0x00000011 (const dword)  (not used)
SSD1963_GET_ADDRESS_MODE              11  0x0000000b (const dword)  (not used)
SSD1963_GET_DBC_CONF                 209  0x000000d1 (const dword)  (not used)
SSD1963_GET_DBC_TH                   213  0x000000d5 (const dword)  (not used)
SSD1963_GET_DISPLAY_MODE              13  0x0000000d (const dword)  (not used)
SSD1963_GET_GPIO0_ROP                201  0x000000c9 (const dword)  (not used)
SSD1963_GET_GPIO1_ROP                203  0x000000cb (const dword)  (not used)
SSD1963_GET_GPIO2_ROP                205  0x000000cd (const dword)  (not used)
SSD1963_GET_GPIO3_ROP                207  0x000000cf (const dword)  (not used)
SSD1963_GET_GPIO_CONFIG              185  0x000000b9 (const dword)  (not used)
SSD1963_GET_GPIO_STATUS              187  0x000000bb (const dword)  (not used)
SSD1963_GET_HORZ_PERIOD              181  0x000000b5 (const dword)  (not used)
SSD1963_GET_LCD_GEN0                 192  0x000000c0 (const dword)  (not used)
SSD1963_GET_LCD_GEN1                 194  0x000000c2 (const dword)  (not used)
SSD1963_GET_LCD_GEN2                 196  0x000000c4 (const dword)  (not used)
SSD1963_GET_LCD_GEN3                 198  0x000000c6 (const dword)  (not used)
SSD1963_GET_LCD_MODE                 177  0x000000b1 (const dword)  (not used)
SSD1963_GET_LSHIFT_FREQ              231  0x000000e7 (const dword)  (not used)
SSD1963_GET_PIXEL_DATA_INTERFACE     241  0x000000f1 (const dword)  (not used)
SSD1963_GET_PLL_MN                   227  0x000000e3 (const dword)  (not used)
SSD1963_GET_PLL_STATUS               228  0x000000e4 (const dword)  (not used)
SSD1963_GET_POST_PROC                189  0x000000bd (const dword)  (not used)
SSD1963_GET_POWER_MODE                10  0x0000000a (const dword)  (not used)
SSD1963_GET_PWM_CONFIG               191  0x000000bf (const dword)  (not used)
SSD1963_GET_SCANLINE                  69  0x00000045 (const dword)  (not used)
SSD1963_GET_TEAR_EFFECT_STATUS        14  0x0000000e (const dword)  (not used)
SSD1963_GET_VERT_PERIOD              183  0x000000b7 (const dword)  (not used)
SSD1963_NOP                            0  0x00000000 (const dword)  (not used)
SSD1963_READ_DDB                     161  0x000000a1 (const dword)  (not used)
SSD1963_READ_MEMORY_CONTINUE          62  0x0000003e (const dword)  (not used)
SSD1963_READ_MEMORY_START             46  0x0000002e (const dword)  (not used)
SSD1963_SET_ADDRESS_MODE              54  0x00000036 (const dword)  (not used)
SSD1963_SET_COLUMN_ADDRESS            42  0x0000002a (const dword)  (not used)
SSD1963_SET_DBC_CONF                 208  0x000000d0 (const dword)  (not used)
SSD1963_SET_DBC_TH                   212  0x000000d4 (const dword)  (not used)
SSD1963_SET_DEEP_SLEEP               229  0x000000e5 (const dword)  (not used)
SSD1963_SET_DISPLAY_OFF               40  0x00000028 (const dword)  (not used)
SSD1963_SET_DISPLAY_ON                41  0x00000029 (const dword)  (not used)
SSD1963_SET_GAMMA_CURVE               38  0x00000026 (const dword)  (not used)
SSD1963_SET_GPIO0_ROP                200  0x000000c8 (const dword)  (not used)
SSD1963_SET_GPIO1_ROP                202  0x000000ca (const dword)  (not used)
SSD1963_SET_GPIO2_ROP                204  0x000000cc (const dword)  (not used)
SSD1963_SET_GPIO3_ROP                206  0x000000ce (const dword)  (not used)
SSD1963_SET_GPIO_CONFIG              184  0x000000b8 (const dword)  (not used)
SSD1963_SET_GPIO_VALUE               186  0x000000ba (const dword)  (not used)
SSD1963_SET_HORZ_PERIOD              180  0x000000b4 (const dword)  (not used)
SSD1963_SET_LCD_GEN0                 193  0x000000c1 (const dword)  (not used)
SSD1963_SET_LCD_GEN1                 195  0x000000c3 (const dword)  (not used)
SSD1963_SET_LCD_GEN2                 197  0x000000c5 (const dword)  (not used)
SSD1963_SET_LCD_GEN3                 199  0x000000c7 (const dword)  (not used)
SSD1963_SET_LCD_MODE                 176  0x000000b0 (const dword)  (not used)
SSD1963_SET_LSHIFT_FREQ              230  0x000000e6 (const dword)  (not used)
SSD1963_SET_PAGE_ADDRESS              43  0x0000002b (const dword)  (not used)
SSD1963_SET_PARTIAL_AREA              48  0x00000030 (const dword)  (not used)
SSD1963_SET_PLL                      224  0x000000e0 (const dword)  (not used)
SSD1963_SET_PLL_MN                   226  0x000000e2 (const dword)  (not used)
SSD1963_SET_POST_PROC                188  0x000000bc (const dword)  (not used)
SSD1963_SET_PWM_CONFIG               190  0x000000be (const dword)  (not used)
SSD1963_SET_REAR_ON                   53  0x00000035 (const dword)  (not used)
SSD1963_SET_SCROLL_AREA               51  0x00000033 (const dword)  (not used)
SSD1963_SET_SCROLL_START              55  0x00000037 (const dword)  (not used)
SSD1963_SET_TEAR_OFF                  52  0x00000034 (const dword)  (not used)
SSD1963_SET_TEAR_SCANLINE             68  0x00000044 (const dword)  (not used)
SSD1963_SET_VERT_PERIOD              182  0x000000b6 (const dword)  (not used)
SSD1963_SOFT_RESET                     1  0x00000001 (const dword)  (not used)
SSD1963_WRITE_MEMORY_CONTINUE         60  0x0000003c (const dword)  (not used)
SSD1963_WRITE_MEMORY_START            44  0x0000002c (const dword)  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -487  0xfffffe19 (PmmC func) args[3] r=1  (not used)
str_Cat                             -485  0xfffffe1b (PmmC func) args[2] r=1  (not used)
str_CatN                            -486  0xfffffe1a (PmmC func) args[3] r=1  (not used)
str_Copy                            -488  0xfffffe18 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -489  0xfffffe17 (PmmC func) args[3] r=1  (not used)
str_Find                            -481  0xfffffe1f (PmmC func) args[2] r=1  (not used)
str_FindI                           -482  0xfffffe1e (PmmC func) args[2] r=1  (not used)
str_GetByte                         -475  0xfffffe25 (PmmC func) args[1] r=1  (usage 3)
str_GetC                            -474  0xfffffe26 (PmmC func) args[2] r=1  (not used)
str_GetD                            -471  0xfffffe29 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -473  0xfffffe27 (PmmC func) args[2] r=1  (not used)
str_GetW                            -472  0xfffffe28 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -476  0xfffffe24 (PmmC func) args[1] r=1  (not used)
str_Length                          -483  0xfffffe1d (PmmC func) args[1] r=1  (not used)
str_Match                           -479  0xfffffe21 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -480  0xfffffe20 (PmmC func) args[2] r=1  (not used)
str_Printf                          -484  0xfffffe1c (PmmC func) args[2] r=1  (not used)
str_Ptr                             -470  0xfffffe2a (PmmC func) args[1] r=1  (usage 3)
str_PutByte                         -477  0xfffffe23 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -478  0xfffffe22 (PmmC func) args[2] r=0  (not used)
strheight                            -14  0xfffffff2 (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                             -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -56  0xffffffc8 (PmmC func) args[2] r=0  (not used)
SWITCH1_cOff                          20  0x00000014 (const dword)  (not used)
SWITCH1_cOn                           18  0x00000012 (const dword)  (not used)
SWITCH1_dshd                          12  0x0000000c (const dword)  (not used)
SWITCH1_F_ORIENT_VERT                N/A         N/A (macro)   0x0001  /* switch orientation (0: Horizontal, 1: Vertical) */   (not used)
SWITCH1_fcOff                         32  0x00000020 (const dword)  (not used)
SWITCH1_fcOn                          30  0x0000001e (const dword)  (not used)
SWITCH1_flg                            8  0x00000008 (const dword)  (not used)
SWITCH1_fnt                           26  0x0000001a (const dword)  (not used)
SWITCH1_fsz                           28  0x0000001c (const dword)  (not used)
SWITCH1_len                            4  0x00000004 (const dword)  (not used)
SWITCH1_lshd                          10  0x0000000a (const dword)  (not used)
SWITCH1_oBz                           14  0x0000000e (const dword)  (not used)
SWITCH1_tBz                           16  0x00000010 (const dword)  (not used)
SWITCH1_thk                            6  0x00000006 (const dword)  (not used)
SWITCH1_tOff                          24  0x00000018 (const dword)  (not used)
SWITCH1_tOn                           22  0x00000016 (const dword)  (not used)
SWITCH1_x                              0  0x00000000 (const dword)  (not used)
SWITCH1_y                              2  0x00000002 (const dword)  (not used)
sys_DeepSleep                       -405  0xfffffe6b (PmmC func) args[1] r=1  (not used)
sys_Driver                          -531  0xfffffded (PmmC func) args[0] r=0  (not used)
sys_ErrorMessage                    -534  0xfffffdea (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -396  0xfffffe74 (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -397  0xfffffe73 (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -398  0xfffffe72 (PmmC func) args[0] r=0  (usage 3)
sys_GetDate                         -401  0xfffffe6f (PmmC func) args[0] r=0  (not used)
sys_GetDateVar                      -528  0xfffffdf0 (PmmC func) args[3] r=0  (not used)
sys_GetTime                         -399  0xfffffe71 (PmmC func) args[0] r=0  (not used)
sys_GetTimer                        -394  0xfffffe76 (PmmC func) args[1] r=1  (not used)
sys_GetTimeVar                      -529  0xfffffdef (PmmC func) args[4] r=0  (not used)
sys_PmmC                            -530  0xfffffdee (PmmC func) args[0] r=1  (not used)
sys_SetDate                         -402  0xfffffe6e (PmmC func) args[3] r=1  (not used)
sys_SetTime                         -400  0xfffffe70 (PmmC func) args[3] r=1  (not used)
sys_SetTimer                        -393  0xfffffe77 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -403  0xfffffe6d (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -368  0xfffffe90 (PmmC func) args[0] r=1  (not used)
sys_T                               -391  0xfffffe79 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -392  0xfffffe78 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 18)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
TB1                                  100  0x00000064 (const dword)  (not used)
TB2                                  101  0x00000065 (const dword)  (not used)
TB3                                  102  0x00000066 (const dword)  (not used)
TB4                                  103  0x00000067 (const dword)  (not used)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 6)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ANGLE                            15  0x0000000f (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tiAngularMeter                        39  0x00000027 (const dword)  (usage 21)
tiButtonD                             51  0x00000033 (const dword)  (usage 3)
tiButtonE                             52  0x00000034 (const dword)  (usage 3)
tiDial                                55  0x00000037 (const dword)  (usage 3)
tiGauge                               40  0x00000028 (const dword)  (usage 3)
tiLabelB                              41  0x00000029 (const dword)  (usage 6)
tiLed                                 45  0x0000002d (const dword)  (usage 3)
tiLedDigit                            50  0x00000032 (const dword)  (usage 9)
tiLedDigits                           47  0x0000002f (const dword)  (usage 6)
tiLedDigitsH                          38  0x00000026 (const dword)  (usage 12)
tiLinearInput                         67  0x00000043 (const dword)  (usage 9)
tImage                                12  0x0000000c (const dword)  (usage 3)
tiMediaButton                         53  0x00000035 (const dword)  (usage 3)
tiMediaGauge                          43  0x0000002b (const dword)  (usage 3)
tiMediaLed                            46  0x0000002e (const dword)  (usage 3)
tiMediaRotary                         56  0x00000038 (const dword)  (usage 3)
tiMediaSlider                         61  0x0000003d (const dword)  (usage 3)
tiMediaThermometer                    44  0x0000002c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tiNeedle                              48  0x00000030 (const dword)  (usage 3)
tiRotaryInput                         57  0x00000039 (const dword)  (usage 6)
tiRuler                               49  0x00000031 (const dword)  (usage 3)
tiSliderC                             66  0x00000042 (const dword)  (usage 3)
tiSliderD                             65  0x00000041 (const dword)  (usage 3)
tiSliderE                             60  0x0000003c (const dword)  (usage 3)
tiSliderF                             64  0x00000040 (const dword)  (usage 3)
tiSliderG                             63  0x0000003f (const dword)  (usage 3)
tiSliderH                             62  0x0000003e (const dword)  (usage 3)
tiSwitch                              58  0x0000003a (const dword)  (usage 6)
tiSwitchB                             59  0x0000003b (const dword)  (usage 6)
tiToggleInput                         54  0x00000036 (const dword)  (usage 6)
tiUserGauge                           42  0x0000002a (const dword)  (usage 3)
tKeyboard                             13  0x0000000d (const dword)  (usage 6)
tKnob                                  1  0x00000001 (const dword)  (usage 6)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 12)
tMagicObject                          34  0x00000022 (const dword)  (usage 6)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -1  0xffffffff (PmmC func) args[1] r=0  (usage 3)
tolower                              -46  0xffffffd2 (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -406  0xfffffe6a (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -408  0xfffffe68 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 12)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 21)
touch_Set                           -407  0xfffffe69 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
touch_TestArea                      -410  0xfffffe66 (PmmC func) args[1] r=1  (not used)
touch_TestBox                       -409  0xfffffe67 (PmmC func) args[1] r=1  (not used)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           266  0x0000010a (mem) word (global)  (usage 24)
TouchXpos                            260  0x00000104 (mem) word (global)  (usage 15)
TouchYpos                            262  0x00000106 (mem) word (global)  (usage 12)
toupper                              -45  0xffffffd3 (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSmartGauge                           35  0x00000023 (const dword)  (usage 6)
tSmartKnob                            37  0x00000025 (const dword)  (usage 6)
tSmartSlider                          36  0x00000024 (const dword)  (usage 6)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 3)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 6)
TurnOffButtons                      4559  0x000011cf (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 12)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 51)
txt_Angle                            -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Attributes                       -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -19  0xffffffed (PmmC func) args[1] r=1  (not used)
txt_Bold                             -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Delay                            -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -18  0xffffffee (PmmC func) args[1] r=1  (not used)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontBank                         -52  0xffffffcc (PmmC func) args[2] r=1  (not used)
txt_FontID                           -20  0xffffffec (PmmC func) args[1] r=1  (not used)
txt_Height                           -22  0xffffffea (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Italic                           -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -26  0xffffffe6 (PmmC func) args[1] r=1  (not used)
txt_Set                              -17  0xffffffef (PmmC func) args[2] r=0  (not used)
txt_Underline                        -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Width                            -21  0xffffffeb (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -23  0xffffffe9 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -24  0xffffffe8 (PmmC func) args[1] r=1  (not used)
uadd_3232                            -71  0xffffffb9 (PmmC func) args[3] r=1  (not used)
ucmp_3232                            -75  0xffffffb5 (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                            -74  0xffffffb6 (PmmC func) args[3] r=1  (not used)
umul_1616                            -73  0xffffffb7 (PmmC func) args[3] r=1  (not used)
UNCHECKED                              1  0x00000001 (const dword)  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                         -15  0xfffffff1 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       3161  0x00000c59 (User func) args[1] r=0  (usage 6)
USD_ENABLE                            18  0x00000012 (const dword)  (not used)
usub_3232                            -72  0xffffffb8 (PmmC func) args[3] r=1  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
vISwitch0                             26  0x0000001a (mem) word[10] (global)  (usage 3)
vObjects                              50  0x00000032 (mem) word[28] (global)  (usage 12)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (usage 3)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
widget_Add                          -590  0xfffffdb2 (PmmC func) args[3] r=1  (usage 3)
widget_ClearAttributes              -599  0xfffffda9 (PmmC func) args[3] r=1  (usage 3)
widget_Create                       -589  0xfffffdb3 (PmmC func) args[1] r=1  (usage 3)
WIDGET_DECIMALS                       11  0x0000000b (const dword)  (not used)
WIDGET_DELAY                          10  0x0000000a (const dword)  (not used)
widget_Delete                       -591  0xfffffdb1 (PmmC func) args[2] r=1  (not used)
widget_Disable                      -596  0xfffffdac (PmmC func) args[2] r=1  (usage 3)
widget_Enable                       -595  0xfffffdad (PmmC func) args[2] r=1  (usage 3)
WIDGET_F_DISABLED                   2048  0x00000800 (const dword)  (not used)
WIDGET_F_FLASH                      1024  0x00000400 (const dword)  (not used)
WIDGET_F_INITIALISED                8192  0x00002000 (const dword)  (usage 3)
WIDGET_F_INTERNAL                  16384  0x00004000 (const dword)  (not used)
WIDGET_F_RESERVED                    960  0x000003c0 (const dword)  (not used)
WIDGET_F_TOUCH_ENABLE              32768  0x00008000 (const dword)  (usage 3)
WIDGET_F_UNDRAW_ONLY                4096  0x00001000 (const dword)  (not used)
WIDGET_FLAGS                           6  0x00000006 (const dword)  (not used)
WIDGET_FRAMES                         11  0x0000000b (const dword)  (not used)
widget_GetWord                      -593  0xfffffdaf (PmmC func) args[3] r=1  (not used)
WIDGET_HEIGHT                          3  0x00000003 (const dword)  (not used)
WIDGET_HI_WORD                         5  0x00000005 (const dword)  (not used)
WIDGET_LO_WORD                         4  0x00000004 (const dword)  (not used)
WIDGET_RAM_SPACE                      10  0x0000000a (const dword)  (usage 3)
widget_Realloc                      -592  0xfffffdb0 (PmmC func) args[2] r=1  (not used)
widget_SetAttributes                -598  0xfffffdaa (PmmC func) args[3] r=1  (usage 3)
widget_Setposition                  -594  0xfffffdae (PmmC func) args[4] r=1  (not used)
widget_SetWord                      -597  0xfffffdab (PmmC func) args[4] r=1  (not used)
WIDGET_TAG                             7  0x00000007 (const dword)  (not used)
WIDGET_TAG2                            8  0x00000008 (const dword)  (not used)
widget_Touched                      -600  0xfffffda8 (PmmC func) args[2] r=1  (usage 3)
WIDGET_VAL1                            9  0x00000009 (const dword)  (usage 9)
WIDGET_VAL2                           10  0x0000000a (const dword)  (not used)
WIDGET_WIDTH                           2  0x00000002 (const dword)  (not used)
WIDGET_XOTHER                          4  0x00000004 (const dword)  (not used)
WIDGET_XPOS                            0  0x00000000 (const dword)  (not used)
WIDGET_YOTHER                          5  0x00000005 (const dword)  (not used)
WIDGET_YPOS                            1  0x00000001 (const dword)  (not used)
wp                                   516  0x00000204 (mem) word (global)  (usage 21)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_LABEL                           12  0x0000000c (const dword)  (not used)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_PAGE                            35  0x00000023 (const dword)  (not used)
WRITE_STR                              2  0x00000002 (const dword)  (not used)
WRITE_STRU                             3  0x00000003 (const dword)  (not used)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         4708  0x00001264 (User func) args[3] r=0  (usage 18)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
xobj2iiobj                           219  0x000000dbxobj2iiobj                           219  0x000000db (mem) word[1] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
xobj2iobj                            221  0x000000ddxobj2iobj                            221  0x000000dd (mem) word[1] (member of C:\Users\oars0\Documents\GitHub\Team-4\HMIContentRedo\HMI-Control.4DWork\HMI-Control.4DGenieS)  (usage 3)
XYLIN_X                                1  0x00000001 (const dword)  (not used)
XYLIN_Y                                0  0x00000000 (const dword)  (not used)
XYROT_EAST                             0  0x00000000 (const dword)  (not used)
XYROT_SOUTH                            1  0x00000001 (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
